<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="KPI Embaresa">
    <meta name="theme-color" content="#0f172a">
    <meta name="description" content="Sistema de KPIs - Produção e Encomendas Embaresa PT">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjogIlNpc3RlbWEgS1BJcyBFbWJhcmVzYSIsICJzaG9ydF9uYW1lIjogIktQSSBFbWJhcmVzYSIsICJkZXNjcmlwdGlvbiI6ICJTaXN0ZW1hIGRlIEtQSXMgLSBQcm9kdcOnw6NvIGUgRW5jb21lbmRhcyBFbWJhcmVzYSBQVCIsICJzdGFydF91cmwiOiAiLiIsICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLCAiYmFja2dyb3VuZF9jb2xvciI6ICIjMGYxNzJhIiwgInRoZW1lX2NvbG9yIjogIiMwZjE3MmEiLCAib3JpZW50YXRpb24iOiAiYW55IiwgImljb25zIjogW3sic3JjIjogImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTUFBQUFEQUNBWUFBQUJTM0d3SEFBQUxQa2xFUVZSNDJ1M2RlMWhVWlFMSDhkOE1nMkt0Z0x0cFhzSDdYUkVRZXJTN2FlYVZ2SkVDM3RiczBiUm4yMzIyM1VyTDNFeE56VXZlMHV5MnR1V3RkaXZMVkZTOEFDb2dnaUtvYVdKNEliVUViOEFBczMrWXBBTEREQ0RDelBmelBEMzVNT2NjM3pubi9UTG40TXhCQWdBQUFBQUFBQUFBQUFBQWNCZ0dleGIydUwrdHBUSU11bTN2blFVRHYvbi8xcjkyL1U4R2kwcS9ybXhZMTFMVWNnYmIxcFdONjFwa3gvWU05dis5bHRLdHUyelRBNVZtWW1la0g3SnBiaHY1SGdCblJnQWdBSUFBQUFJQUNBQWdBSUFBQUFJQUNBQWdBTURSVk1uM0FnRWw0YjFBQUFFQUJBQVFBRUFBQUFFQUJBQVFBRUFBSUFDQUFBQUNBQWdBSUFDQUFBQUNBQWdBSUFDQUFBQUNBQWdBSUFDQUFBQUNBQWdBSUFDZ3FqQ3hDeHhQK3dteHhUNTJjSEZuZHRCTnVEZW9FMHg2WjR5QmU0TXkrZS9ZZWx3RG9NcFBmaUlnQUlBQVFBQUFBUUFFQUJBQVFBQUFBUUFFQUJBQVFBQUFBUUNPaE04RDNHUndVSFN4ajYzN3FnczdpQUNjYTlJWHR4d3hjQXJrVkpPL3ZOWURyd0JWZnZMZnZMNHp2eEk0eXVraTF3Qnc2dE5GZmdvRXB6NWRKQUJVeU9raUFRQUVBQkFBUUFBQUFRQUVBQkFBUUFCQVJlT3RFQlZzY28vaTc4VTViVE8zTGljQUo1djB4UzFIREp3Q09kWGtMNi8xUUFCVmZ2SVRBUUVBQkFBUUFFQUF3SjFSWlg0TXlxLytoTk1GWU9zdmNMdDVPV0tBUTV3Qzhhcy80YlFCOEtzL3dVVXdRQUFBQVFBRUFCQUFRQUFBQVFBRUFCQUFRQUFBQVFBRUFCQUFRQUFBQVFBRUFCQUFRQUFBQVFBRUFCQUFDSUJkQUFJQUNBQWdBSUFBQUFJQW5JREJub1U5N205cllaZWhLc2hJUDJUVDNPWVZBSndDQVFRQUVBQkFBQUFCQUFRQUVBQkFBQUFCQUFRQUVBQkFBQUFCQUFRQUVBQkFBRUNWWW5LbUo5dTBpWmYyUlc4bzl2SEk2QmoxR1RES3BtMkZEUnVvaFhQL0pZUEJZSFY3UTBMSDYrclZhemFQb1RoWjJkbkt6THlzaXhtWlNrbjVRZnNUazdRMUlrcjdFNU1xL0xuekN1RGtob2NNS25IeTc0cUswZUNRY2JkTS9ySndxMTVkZFdyL1NTMmJOMUgvdmozMCtxc3ZLbUxUR3UzWXZFNUJmWi9rb0JCQXhSZ1pObGp2dmpPMXhNay9KSFNjcmwzTHV1UGo2ZGloalQ1Wk1VK2ZmcmhBOTk1N0R3ZUlBTzZjVWNPSGFQN3NONnhPL3AyUmV5dHM4dCtzYisvdVdyMXlpZHpjM0RoUUJGRCtSbzhJMXJ4WlU2eE8vaDI3OWlnNGJIeUZULzRiSHVvYW9EY212Y2pCSW9EeU5XYlVVTTE5KzNVYkp2L3pkMjN5My9EczZCQTFiOWFZZzBZQTVUU2hSZzNUbkJtVHJVNys3VHQzS3pqc2VXVmxsWDN5UjBiSHlMTnV1MXYrcTlPb2szd0NlK3JGbDk1UTJxa3pWdGMzbVZ3MGVFQWZEaHdCbE4zWTBjTTBaMmJKay8rWjRSUEtaZklYSjhkc1Z1ckpOSDI4Y3EwZWZtS1Fmamgyd3VyeVBaNTRtSU5IQUdYejNKOUROSHZHWkt2TFJPeUl2dU9ULzNhL1hzelE5Rm1MckM3VHJLazNCNUFBU20vY3MyR2FOWDJTMVdXMmJZL1MwQkVUSzNUeTN4QVRsMkQxY1U4UGQ3bTZtamlRTm1BdjNUNzV4dzdYekRkZkxuSHlEeHN4VVZuWjJYZGxqTlpPeVNUSll1RVdyZ1JRQ3AwNnR0T0RYUUtzTHJNMUlrb2hJKy9lNUpla3dNNCtWaCsvbUpFcHN6bVhBOG9wa0gxSytwZlV5akQ1YTNsNjZKV1hKbHBkNXRqeFZBNG1BWlN2TGRzaTc5cmtkM1UxeWF0UkE0ME1HNnlkVzc0bzhTSTNmT3RPRGhpblFPVW42ZEFSaFk1Nm9VSW0vNE5kQW5UeGJGS3AxemViYzdYMnkyODVhTHdDbEo4MnJadHI0Tk85cXNSWVYzejBHYWRBQkZET084bG8xS0o1YjJwWWNGQ2xIbWRrZEl5bVRsL0FBU09BT3hQQjR2blROTFNTUnJEK3UvQnllenNHMXdCT3ltek90Zm9QU0VhalVVdm1UNU1rclZyelZhVVk4NEdES1hwbndYTDk3NXVOSEVBQ0tKdTlzZkdLMzUra2llTkhsUnlCeGFKVmE3K3VzTEZsNStUODlwSElEQjArZkV6eENVbmFzaTNTNW85RWdnQnNNbm5xYkJrTUJrMFlOOUo2QkF2ZWtzVmkwZXAxMzVUN2Vid3pmamFYYTRCS1pOSWJzN1JrMmI5THZDWlkrdTUwQlEvcXl3NGpBTWZ6NnBTM2JZNWd5RURlZjA4QURockIwdVhXSTNCeGNkRjdDMmRvOElEZTdEQUNjRHl2dkc1YkJNc1d6U1FDQW5EY0NONTdmNlZORVF4Nm1nZ0l3QUc5L05wTW15Sll2bmltQmdiMVlvY1JnSU5Hc09MVEVpTjRmOG5iR3REL0tYWVlBVGhnQkpObmFOa0gvN0VoZ2xsNnVsOVBkaGdCT0o1L1RwcGVZZ1FtazR0V0xKM05mVHNKd0hFaldQN2haeVZHOE1GN2M0aWdFalBZczdESC9XMnIxS2V0ZS9icHEwY2U3MWJrWS85ZHUwYXhlM1lYTEhQaC9Ebk5uVG5qMXU4T1JxUCs4ZG9VMWF4WlUrSGZiOUMyOE0xRmJ0ZHNOdXVYQytlMUp5cFNlNktpaXQ3UkJvTmVtdlNhUER3OU5YL1dUSjM3K1dlclk3MTY1WXJTejU3UnR2RE5PbmIwcUYzUDZYcDhKajMwNkdQeThmT1haNjFhdW5idHF0SlNUeXBxNXc2ZCtQRzQzZU9yYWpMU0Q5azB0eDMrdlVBNU9UbWErcXIxdXp6a1pHZkxzOVlmNWVYZFdDZFRUeFI4dlVXclZxcm02cXI4L0h5cjI2MVd2Ym82ZHZMVmdDSEJ5czNOVTl6ZVBZV1diOTZpcGR3OVBIVDUwaVg1QlFScTQ3ZnJyVzdUM2NORHZmc0ZhY1NZc1ZvMDd4MmRTMCszNnprTmVtYW9tclZvcVM5V2Y2NGZqeCtYcTZ1cnZMeTkxZjJwWHZyNC9XWEt6YzIxZTN5Y0FqbHdKQ2xKU2ZMdDNQbVdyL3Y2QitoQVlrS1JBZHdlVU95ZTNUcVZscWEyN1RzVXVZeGZZS0JTZnp5dXZidWo1ZXZmV1VhajlWMmZtWkdoRGV1L2xzbGtVb3VXcmV4K1R1MDYraWgyN3g0ZFRrNVdUbmEycmx5K3JPU2tKSzFZdXJqUTVDL04rQWpBd2V5TGpWR0hUcjR5bWE2L0tMcTV1YWxOKy9hS2o0MjE3NXl5aUh2MnVOV29vYmJ0T3lnK0xrNzc0MkpWMDkxZExWcTF0bm1iTjhaa2o4eU1ERFZ1MGxSdU5XcVV1R3haeDBjQUR1QklTckx5OC9MVXVtMDdTVklIbjA2NmxKbXAxQ0xPbDI5WHJYcDErUWNFcW42REJvcVBqU24wdUkrdnJ5VHBZTUorWFRoL1hpZFRUOGcvSU5EcU50M2QzZFdyYjMrWnpUbEtPcEJvOS9QNWF0MWEzVmU3dGw2Wk1sVmpuNStnWHYzNnEwbXpaa1V1VzVyeE9RcUh2d2FvVnEyYTNwb3p0OURYYjcvUXk4L1BWMEw4UHZsMkR0REJ4QVQ1QmdRb1BpNjIyTHVzRmJYZDNaRzdpcHlzZmdHQlNrbEtLdmk0NHY2NFdQVUpHcUI3N3JsWFY2OWVLWGFiV1ZsWldyRjBpUzZjUDIvM2N6cDY1TEJtdnpWTlRaczNrNWQzRXpWcDNrd1BQZnFZVWc0ZDBtZWZmS1M4dkR5N3gwY0FEbm9SZkVOOGJJekcvK1d2OHZKdUxDL3Z4dnBpMWVjMmJkZGtNcWxlL1FZYUVoS3E0TkF3clZyNSs1dm42dFN0cTRhTnZCVHgyMCtRSkNreFBsNTlnZ2JJeDg5UDBidDJGdHFtMFdoVTNYcjFGVEp5bExyMWVGSXJQL3pnbGhCdGZVNW1jNDRPSnlmcmNITHk5ZS8wZnY0S0RnbFZZSmV1QlgrdlBlTWpBQWQzK3RRcG5VdFAxek5ody9WVGFtcWg3N3pGeWMzTjFVOG5VeFc1STBMOUJ3N1d4bS9YNjlkZmZwR2tnbE9Kc05GakNxM25IeGhZNUFUTHo4L1g2Vk5wK25MTmFvMFpOMTd0Ty9yb1FNTCtNaisvaEgxeDZ0TS9TQTBiZWYwK2hsS01qd0FjL0dLNFY3LysycjQxdkJSclg3OEFkbkZ4dVg2QlpUU3FrNSsvdG03YXFDMmJidjNRdW5makpucHU0Z3VxVjcrQnpwdytWZVRXanY5d1ZDZU9IOU5qM2J2YkhVRDNuazhwZk9QM3Qzek4xZFZWMWQzY2xQM2JEYjdLT2o0dWdoM1FydTBSbXZUM3YybHZkTFRONjdpNHVLaWhsNWNlZk9SUm5UbDlxdUNWbzFXYk52cER6Wm82a0ZqNGR1WW5VMDhvTXlORC9vSFdMelozYk51cXV2WHFxMlhyTm5ZOWo0Y2Y3NmFSejQ1VncwWmVNcGxNdXE5MkhRMEpDWlhCWU5DK21MM2xOajVlQWFyb1JYQkVlTGcyZi85ZHVXdzNMeTlQbHpJemRTUWxXVnMzYlN3NFgvY0xDTlM1OUhUOWZQWnNvZlV0Rm91U0RpVEt4ODlQRzc0cC91NFNoNU9UbFg3bWpCNTV2SnVPcENUYi9KeVdMWHhYRDNUdHF1RFFVSGw0MXRLVks1ZDFPaTFOeXhjdlZOcFBKKzBlMzgwWHpZN0VvZDhLQWVkbDYxc2hPQVVDQUFBQUFBQUFBQUFBQUFBTzVQOU4yVUZuQlNhUXpnQUFBQUJKUlU1RXJrSmdnZz09IiwgInR5cGUiOiAiaW1hZ2UvcG5nIiwgInNpemVzIjogIjE5MngxOTIiLCAicHVycG9zZSI6ICJhbnkgbWFza2FibGUifSwgeyJzcmMiOiAiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFnQUFBQUlBQ0FZQUFBRDBlTlQ2QUFBaThFbEVRVlI0MnUzZGQzaFY5ZjNBOFU5aUpBa1FsZ3daQ3NwU2xMM1UybHBIYTJ1dFc1eFZxUXVyMXRaUnRkbzY2cWk3VmR0cXRWYjcwN29RVkhBVTkwTDJFcEdwb0FnQ0twc000T2IzaDIza01qU0JuTXpYNjNuNlBMMkIzSFB2OTF6NXZzODNKK2RFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREF0c3FvckEwM2JOR2wyUEJYbkM2SHZMWFpIWjVSaWc5RStmeWRqTTMvbmVLSzJIWnAzM2RHeFcrN3VLemZrNUhBK3k3dnY1TlJ0dWNwcmtLZng2aUV6Mk54RmZvOC92Znh2U1A2KzBlemdpMWZOSzNDNStOTXd3NEF0WThBQUFBQkFBQUlBQUJBQUFBQUFnQUFFQUFBZ0FBQUFBUUFBQ0FBQUFBQkFBQUlBQUJBQUFBQUFnQUFFQUFBZ0FBQUFBUUFBQ0FBQUFBQkFBQUNBQUFRQUFDQUFBQUFCQUFBSUFBQUFBRUFBQWdBQUVBQUFBQUNBQUFRQUFDQUFBQUF5bDFHWlcyNFlZc3V4WVlmQUNLV0w1cFc0Zk94RlFBQXFJVUVBQUFJQUFCQUFBQUFBZ0FBRUFBQWdBQUFBQVFBQUNBQUFBQUJBQUFJQUFCQUFBQUFBZ0FBRUFBQWdBQUFBQVFBQUNBQUFBQUJBQUFJQUFBUUFBQ0FBQUFBQkFBQUlBQUFBQUVBQUFnQUFFQUFBQUFDQUFBUUFBQ0FBQUFBQkFBQUlBQUFBQUVBQUFnQUFFQUFBQUFDQUFBUUFBQWdBQUFBQVFBQUNBQUFRQUFBQUFJQUFCQUFBSUFBQUFBRUFBQWdBQUFBQVFBQUNBQUFRQUFBQUFJQUFCQUFBSUFBQUFBRUFBQWdBQUJBQUFBQUFnQUFFQUFBZ0FBQUFBUUFBQ0FBQUFBQkFBQUlBQUJBQUFBQUFnQUFFQUFBZ0FBQUFBUUFBQ0FBQUFBQkFBQUlBQUJBQUFDQUFBQUFhcHNzUXdEVUZudWVPNjdNM3pQMUwzME1IRFZTUm1WdHVHR0xMc1dHSDZoS2s3MG9vTElzWHpTdHd1ZGpBUUNZK0lVQUFrQUFBQ1o5TVVCdENBQW5BUUltL3hyME9zQUtBR0RpdHhxQUZRQXJBSURKMytzREFRQUFBZ0RBMGI5VkFBUUFnRWxWQkNBQUFBQUJBQUFJQUFCQUFBQUFBZ0FBRUFBQWdBQUFBQVFBQUNBQUFBQUJBQUFJQUFCQUFBQUFBZ0FBRUFBQWdBQUFBQUVBQUFnQUFFQUFBQUFDQUFBUUFBQ0FBQUFBQkFBQUlBQUFBQUVBQUFnQUFFQUFBQUFDQUFBUUFBQ0FBQUFBQkFBQUlBQUFnSTFsR1FKcW9tTU9mN2ZNM3pQNG1iME5IQ0FBb0NaUDlxVjlIbEVBQ0FDb29STi9hYlloQkFBQkFEVjgwdisyN1lvQm9DWndFaUFtLzJyNk9nQ3NBR0RpcjZUWFpEVUFzQUlBdGZCbzIyb0FJQUFBQUFFQXRlWG8yaW9BSUFDZ2xrNnFJZ0NvYnB3RUNDQ3lTOFZKcndJQWdCbysyWmYyZVVTQkFBQ2doazc4cGRtR0VCQUFBTlR3U2YvYnRpc0dxZ2NuQVFLWS9Hdms2OEFLQUlDSnY1SmVrOVVBS3dBQTFNS2piYXNCQWdBQUVBQUExSmFqYTZzQUFnQ0FXanFwaWdBQkFBQUlBQUJBQUFBQUFnQUFFQUFBZ0FBQUFBUUFBQ0FBQUFBQkFBQUlBQUFRQUFDQUFBQUFCQUFBSUFBQUFBRUFBQWdBQUVBQUFBQUNBQUFRQUFDQUFBQUFCQUFBa0pnc1F3QTEyNVUvR0ZmbTc3bnVwVDRHRGdRQVVKTW4rOUkranlnQUFRRFUwSW0vTk5zUUFpQUFnQm8rNlgvYmRzVUFWRjlPQWdTVGY3Vi9IWUFWQUREeFY5SnJzaG9BVmdDQVduaTBiVFVBQkFBQUlBQ0EybkowYlJVQUJBQlFTeWRWRVFBQ0FBQVFBQUNBQUFBQUJBQUFJQUFBQUFFQUFBZ0FBRUFBQUFBQ0FBQVFBQURBeHR3T3VBYlo4OXl5WDRKMTZsL2N3aFZBQUZDakovdlNQbzhvQUJBQTFOQ0p2elRiRUFJQUFvQWFQdWwvMjNiRkFFRE40aVJBazMrMWVoMEFXQUV3OFZmU2E3SWFBR0FGZ0ZwNHRHMDFBRUFBQUFBQ2dOcHlkRzBWQUVBQVVFc25WUkVBSUFBQUFBRUFBQWdBQUVBQUFBQUNBQUFRQUFDQUFBQUFCQUFBSUFBQUFBRUFBQWdBQUVBQUFBQUNBQUFFQUFBZ0FBQUFBUUFBQ0FBQVFBQUFBQUlBQUJBQUFJQUFBQUFFQUFBZ0FBQUFBUUFBQ0FBQVFBQUFBQUlBQUJBQUFJQUFBQUFFQUFBSUFBQkFBQUFBQWdBQUVBQUFnQUFBQUFRQUFDQUFBQUFCQUFBSUFBQkFBQUFBQWdBQUVBQUFnQUFBQUFRQUFDQUFBQUFCQUFBSUFBQVFBQUNBQUFBQUJBQUFJQUFBQUFFQUFBZ0FBRUFBQUFBQ0FBQVFBQUNBQUFBQUJBQUFJQUFBQUFFQUFBZ0FBRUFBQUFBQ0FBQVFBQUNBQUFBQUFRQUFDQUFBUUFBQUFBSUFBQkFBQUlBQUFBQUVBQUFnQUFDQVNwUlJXUnR1MktKTHNlRUhnSWpsaTZaVitIeHNCUUFBYWlFQkFBQUNBQUFRQUFDQUFBQUFCQUFBSUFBQUFBRUFBQWdBQUVBQUFBQUNBQUFRQUFDQUFBQUFCQUFBSUFBQUFBRUFBQWdBQUVBQUFBQUNBQUFFQUFBZ0FBQUFBUUFBQ0FBQVFBQUFBQUlBQUJBQUFJQUFBQUFFQUFBZ0FBQUFBUUFBQ0FBQVFBQUFBQUlBQUJBQUFJQUFBQUFFQUFBSUFBQkFBQUFBQWdBQUVBQUFnQUFBQUFRQUFDQUFBQUFCQUFBSUFBQkFBQUFBQWdBQUVBQUFnQUFBQUFRQUFDQUFBSUF0eVRJRVZLYW5IdjE3SExqL2Q4cjFPVThmZEVrODlmVHpGZm8rNnRXckcwOCs4cmZZWjY4K2lXM2ozNDgvSGVmOStuZVJTcVVxYld5M1ZpcVZpcUtpb2lnb0xJckN3cUpZc1hKbExGbnlSU3hlOGtWOHRtaEp6Smt6TjZiUG5CTXpaMzBZaXhaLzdqTUtBZ0NxdnZyMTY4WGdmOThiZS9Ycm1kZzJIbjUwU1B6eW9xdEtQZmxYTlptWm1aR1RreE01T1RrUkVkR2llZFBvMkg2WHpmN2RCUXNYeFR2dmpvdVJvOGJGUzYrOEZmTS9YZWhEQmdJQXFwYTh2UHJ4MUtQM1JyOCtQUkxieGtNUEQ0NWZYWEoxRkJjWDE0b3hiZFd5UlJ4NzFFL2kyS04rRXNYRnhURnV3cFFZOHN5TDhmaVR6OGFYUzVmNTBFRjVoYmtoZ0szVG9FRmVESDM4dmtRbi8zODgrRml0bXZ3M2xwR1JFWDE3ZDQ4YnI3MDBwazE4SmU2NCthcm8wTDZkRHg4SUFLZ2NqUm8yaUdlZS9FZjA2ZFV0c1czYzk4OUg0NkxML2xCckovK041ZVRreE1CVEJzU29ONTZObTIrNElobzNhbWhRUUFCQXhXbmNxR0U4TS9nZjBiUDdIb2x0NDU3N0g0NUxMci9PWUc5R1Z0WjJjZGJQVDR3Sm8xNklJMzU2c0FFQkFRREphOUs0VVR3NytJSG8zclZMWXR2NDY3My9pc3V1dk5GZ2x5TEVIcnp2OXZqenJkZVVuRndJQ0FBb2QwMTNhQkxEbnZwbmROMXp0OFMyY2VkZkg0amZYbldUd1M2RFUwOCtKcDUrL0w1bzBDRFBZSUFBZ1BMVnJHbVRHUGJVQTdGSGwwNkpiZU9PdSs2UDMxOTdtOEhlQ252MTd4WFBEMzBvZG1qUzJHQ0FBSUR5MGFKNTB4Zys5S0hZZmJlT2lXM2oxai9kRzlkY2Y0ZkIzZ1o3N3RFNS92M1EzWkZkcDQ3QkFBRUEyMmJIRnMxaStOQUhvM1BIWFJQYnhrMjMvUzJ1KytPZEJyc2M5Ty9iSSs2OC9Wb0RBUUlBdGw3TGxpMWkrSkFIdDNqRnV2Snc0eTEzeDQyMzNHMnd5OUZ4eC93MGpqN2lFQU1CQWdES3JuV3JIZVA1b1E4bGV0R1o2LzU0Wjl4MDI5OE1kZ0p1dnVHMzBYU0hKZ1lDQkFDVVhwdldMZU81b1EvRkx1MTJTbXdiVjE5M2U5ejZwM3NOZGtKMmFOSTRMcnJnVEFNQkFnQktaK2VkV3NmelR6OFU3ZHEyU1d3YnY3djIxdmpUM2Y4dzJBa2JlTXFBYU5HOHFZR0FMWEF6SVBpdmRtM2J4UEFoRDBhYjFpMFQyOFp2cjdvcC9ucnZ2NnJ0R0pYMU5yWTVPVG5ScUdGZU5HcllJRHAzYWg5OWUzZVA3KzdiTDlFTEtXMjQ3VE1HbmhEWDMzU1hEemRZQVlETjIzV1huZVA1cC8rVjZPUi8yWlUzVnV2SmYyc1VGQlRFWjR1V3hQU1pjK0taNFNQaXltdHVpZjErY0d3YytPUGpZK2l6THlhKy9RRkhIK3JERFFJQU5xOUQrM2J4M0pBSG8xWExGb2s4ZjNGeGNWeDgyWFZ4ei8wUEcrei9Hai94dlJoNDFrWHhzOU12U1BRV3YyMTNiaFA5Ky9ZdzRDQUFJRjJuRHJ2RThDRVBSc3NFSi8rTEx2dEQzUC9nb3daN000WTk5M0ljY3NTcHNYejV5c1Myc2Y5KzN6SFFJQURnYTd0MWFoL0RoejRVTzdab2x0amsvNnRMcm80SEhucmNZSCtENlRObXgwa0R6NDlVS3BYSTgrK3pWMitEREFJQXZyTDdiaDFqMkpBSG8zbXpIUko1L2xRcUZlZGYrUHQ0Nk9IQkJyc1UzaDQ1TnA0Yzhsd2l6OTIzZC9mSXpQUlBIUWdBYXIwOXVuU0s0VVArR2MyYUpuT2htRlFxRmVmKzZzcDQrTkVoQnJzTWJyajU3aWd1TGk3MzU4M056WW1XT3pZM3dDQUFxTTI2N3JsYkRIdnFuNG5kTlc3OSt2Vnh6aTkvRzQ4KzhZekJMcU41SDgrUHFlL1BTT1M1MjdYZHlRQ0RBS0MyNnQ2MVN6dzcrSUZvMHJoUllwUC9vUE12ajhjSER6UFlXK21WMTk5SjVIbDNhdFBTNE1KR1hBaUlXcUZYanoxajZPUDNSOE9HZVlrOC83cDE2K09zY3krTkljKzhZTEMzd2F6Wkh5WHl2UFhxMVRXNElBQ29iZnIwNmhaREh2dDdOR2lRM09SLytxQ0w0NW5oSXd6Mk52cmlpeThUZWQ2NmRYTU5MbXpFandDbzBmcjE2UkZESDc4dnNjbC83ZHAxTWZEc0MwMys1V1Q1aWxXSlBHOXVUcmJCQlNzQTFCWjc5ZThWZ3grNUorclhyNWZJOHhldFhSdW5uWGxoUFAvaXF3YTduRFJxMUNDUjU4MHZLRFM0SUFDb0RmYlpxMDhNL3ZjOWlTMzlGcTFkRzZmOC9JSjQ4YVUzREhZNVN1cTNNOWFzeVRlNElBQ282ZmJkcDI4Y2YreGhrWnViazhqekZ4WVZ4YzhHWGhBalhublRZSmV6M1RxMVQrUjVWNjFhYlhCQkFGRFREVHhsUUdMUFhWQllHQ2VkZG42ODh0bzdCam9CQjN4L24wU2U5NVA1Q3cwdUNBRFl5c20vb0NCT09QWDhlTzJOa1FZakFSM2F0NHN1dTNkSzVMay9tdmVKQVFZQkFHV1huMThReDU5eWJyengxaWlEa1pBckxqMC9rZWRkc3lZL1B2dHNzUUVHQVFCbG4wQUduSHhPdkQxeXJNRkl5UDc3N1JOSC9QVGdSSjU3ekxoSmlkeGpBQVFBMUdDclY2K0pZMDg2SjBhT0dtY3dFckpIbDA3eHIvdnZpSXlNakVTZS85M1I0dzB5YklZTEFjRVdyRnExT280KzhXeVRmNElPUC9TSDhkelFoeUl2cjM1aTIzanRqWGNOTkZnQmdOSlp1WEpWSEhQaTJURjY3Q1NEa1lBK3ZickZlZWVjbHRpeS8vL01uVGMveG95ekQwRUFRQ21zV0xFeWpqcityQmczWVlyQjJFWTUyZG5Sc0dGZU5HcllJRHAzYmgvOWV2ZUk3KzNiUDdwMTNiMUN0dS9PakNBQW9GUUtDZ3ZqaUFGbnhJUkpVdzNHWnZ6am5sdmlIL2ZjVWozMlpVRkIvT1BCUiswMDJBTG5BTUJHUjZ3SDdyK3ZnYWdCSG5qb2lWaTg1QXNEQVFJQVN1ZUtTOCtQMzF3NHlFQlVZMTk4dVRSdSsvUGZEUVFJQUNpYjMvN20vTGowb25NTVJEVjF5ZVhYeHhkZkxqVVFJQUNnN0M2LzVMeTQ3T0p6RFVRMTg4UlR3MlBJTXk4WUNCQUFzUFV1dS9nWGNma2w1eG1JYW1MMDJFbHgvcTkvWnlCQUFNQzJ1L1NpYytLM3Z6bmZRRlJ4NzArYkdTZWRkbjRVRmhVWkRCQUFVRDUrYytHZ3hHNVd3N1liTldaaUhITGtLZkg1RjE4YURCQUFVTDR1K2ZXZ3VQS3lYeHFJS3ViLy92MVVIREhnakZpK2ZLWEJnREp3SVNBb2c0dC9kWFprWkdURUgyNzhzOEdvWkV1WExZOExmM050REgzMlJZTUJBZ0NTZDlFRlowVm1abVpjYy8wZEJxTVNyRisvUGg3NDF4Tnh3MDEzeGRKbHl3MElDQUQ0eXBvMStWRzNibTZpMi9qMStXZEVSa1pHWEgzZDdRYThnaFFVRk1SalR3Nkx1Kzk1TUdiUG1XdEFRQUJBdWl1dnVTVitkdUxSMGJQN0hvbHU1MWZublI0WkdSRlgvVUVFSkduOHhQZGl5RE12eEdOUFBPdmlQaUFBWU11V0wxOFpoeDk3ZWd4OS9MN28zYk5yb3R1NjROelRJeU1qSTM1LzdXMEd2cHdzWExnbzNoazFQa2FPR2hjalhuNHo1bis2MEtDQUFJRFNXYkZpWlJ4NTNKa1ZFZ0cvL01YUEl5TXk0bmZYM21yZ3Q2QzR1RGdLaTRxaXFMQW9Db3ZXeG9vVksyUEpraTlpMFpMUDQ3TkZTMkxPbkxreFk5YUhNV1BtblBoczBSSURCZ0lBdGkwQ2poaHdSZ3g1N08vUnQzZjNSTGQxL2k4R1JtWm1abHh4OWMwMWVreFBIM1JKUFBYMDh6NWNVQU80RGdBMTJzcVZxK0tvNDgrS3NlTW5KNzZ0Y3dlZEdqZGNjNmxCQndRQVZKVUlPUEs0TTJQMDJFbUpiK3NYWjU4U04xNHJBZ0FCQUZYQ3FsV3I0K2dUenFxUUNEam5MQkVBQ0FDb1VoRncxUEZueHFqUkV5b2tBdjU0M2VVR0hSQUFVQldzWHIwbWpqN3g3QXFKZ0VGbm5CdzNYZjliZ3c0SUFLaEtFVEJ5MUxqRXQzWDI2U2ZGelRkY1lkQUJBUUJWSlFLT09YRlFoVVRBV1Q4L01XNjU4VXFERGdnQXFBcldyTW1QWTA0Y0ZHK1BISnY0dHM0Y2VFTGMrc2NySXlNanc4QURBZ0NxUWdRY2U5S2dlT3VkTVlsdjY0elRUb2hiYnhRQmdBQ0FLaUUvdnlBR25IeE92UG4yNk1TM2RmcHB4OGZ0Ti8xZUJBQUNBS3BPQlB3aTNuaHJWT0xiR25qS2dMamo1cXRFQUNBQW9Db29LQ2lJNDM1MmJyeis1cnVKYit1MG54MGJmN3JsYWhFQUNBQ29LaEZ3L0NubnhXdHZqRXg4VzZlZWZJd0lBQVFBVktVSU9PR1U4K0xWMXlzbUF2NThxd2dBQkFCVWpRZ29MSXdUVHowdlhubnRuY1MzZGNwSng4UmR0MThibVpuK2N3UUVBRlNaQ0hqcDFiY1MzOWJKSnh3bEFnQUJBRlZGWVZGUm5IemFMeXNrQWs0Ni9zaTQrNDQvaUFCQUFFQlZpb0QvdlB4RzR0czY4YmdqNGk5L3VrNEVBQUlBcWtvRS9HemdCZkhpUzhsSHdBa0REbysvaWdCQUFFRFZVTFIyYlp6eTh3dml4Ukd2Sjc2dDR3Y2NIbi85OC9VaUFCQUFVR1VpNFBSZnhRdi9lUzM1Q0RqMnNQamJuVGVJQUVBQVFKV0pnRE4rRmMrLytHcmkyenJ1bUovR1BYZmRHTnR0dDUyQkJ3UUFWTGExYTlmRnFXZitPcDU3NFpYRXR6WGc2RU5GQUNBQW9DcEZ3R2xuWFJqRG5uczU4VzBkZTlSUDR0NjcveWdDQUFFQVZTVUNCcDU5WVR3Ny9LWEV0M1hNa1lmRTMvOGlBZ0FCQUZYQ3VuWHI0K2VETG9wbmhvOUlmRnRISDNGSTNQZlhtMFFBSUFDZ3FrVEE2WU11anFlSC9TZnhiUjExK0kvai9yL2RIRmxaSWdBUUFGQWxJdUNNY3k2Sm9jKyttUGkyamp6c1IzSC8zMjRSQWNCV3E3UjdrRFpzMGFYWThBTkF4UEpGMHlwOFBzNHk3RUJ0VmFkT25lamF2VWUwYTk4K1dyZHBFL1hyNTBWT2JtNmtVcWtveU0rUHBVdS9qTThXTEl5UDUzMFVNNmRQajlXclZoazByQUJZQVdCejZ0YXJGMWRjODRkeWVhNG5IMzBrSm8wZlgrcHRGQlVXeG8zWFhoMUZoWVZsM3RiMzlqOGdEdjdKb1p0OGZkeVkwVEgwaWNmTDVmMnVXN2N1Q2dzS1lzV0s1YkZ3d1lLWU5XTkdmREIxYXF4ZFcxUXU0M1g2b0YvRXJoMDZsRHd1TGk2T1c2Ky9McFl0VzVyb3ZseTd0aWdLQ2dwanhmTGxzZURUK2ZIaHJGa3hiZXA3c1c3ZHVpcjF1ZG5RZHR0dEYvc2RlRkRzdTkvM0l6czd1MVRQVzF4Y0hQTSsrakRHamg0VlV5ZFBMdFA3UzNwZllRWEFDZ0MxKzJndU96dTZkZThSNDhhTUx2UDM5dXJiTC9uLzJMS3lJcXQrL2FoWHYzNjBiTlU2ZXZYcEcvbjUrZkhTQzgvRm1IZmZqZUxpclcvaXhrMmF4Qzd0MjZmWGZVWkc5T3JYTDE0ZGtleUppZHR2WHllMjM3NU81T1hsUmVzMmJhSnYvNzBpZjgyYStNOXp3MlBzNkZGVjduT1NXN2R1RER6ejdHaTkwMDVsTzFyS3lJaDJ1N2FQZHJ1Mmp6cDFzbVBNdXlPcjNiNENBVUNOMWJ0Zi96SUhRTnQydTBTejVzMHJaekxLelkzRGpqb21XclZ1RTA4UGZuS3JJNkIzMzM2UmtiSHBBVVN2UG4zanRaZEdiRk5jYk8wa2U4U3hBNkpOMjdiZnVJSlMwVEl6TStPME04N2FaUEtmUG0xYVRKNDRJVDc5NUpOWXVYSkZyRiszTHZMeUdrU3o1czJqMCs2N3h4N2R1a1hEaG8zSzV6TmF4ZllWQWdBU3NXenAwcmpsK2o4a3VvM0N3c0tTWmR5ZDI3V0xaczJieDVMRmkwdi9EM0wvL2w4L1YwRkJaT2ZrSlBKKzY5U3BFM2tOR2thN1hYYUp2ZmJkTjFxMWJsUHlaMzM2N3hXZnpwKy9WVWVWR1JrWmFTc1lxVlNxNUFaQ2paczBpVjA3ZElnNXMyWWx0aS9yWkdkSG8wYU5va09uenZHZDcrMFhqUm8zL3ZwOTllc2ZueTFZRU8rKy9WYVYrTnpzdmU5M284M09PNmZ0NzBjZWVqRG16SnE1Nld0WXRqU1dMVnNhczJiT2lCZUdQUnRkZS9TTTd4OTRVRFJ2MFdLcnQxOVIrd3BLRmNTR2dPcHV3Zno1OGZtU0pXbXJBS1ZWSnpzN3VuYnZVZko0eXFTSmliM09vcUtpK09MekpURis3Smo0NjUvdWlQRmp4NlQ5K1lFL1BIaXpSNGJmcGtPbnp0R3cwZGRIcDYrK05DTFdyMSsvVmVPeFZlK3JzREFXTDFvVUk5OTZNKzY4N1phWSsrR2N0RDgvNEljL2pEcWwvRGw3MHZiZTk3dHBqd2MvOXVobUovK05wVktwbUR4aGZOeDEyeTN4NHZCaFViZ1Y1NWxVaFgwRkFvQWFaOElHazJtUDNuMUtmUXZkYmoxNlJwMDZkVXFPQnQrZk1xVkNYbTl4Y1hFTUd6SWsxcXhaWGZLMStubDVaZjY1OUZlVHh0ZEhsT3ZXcll0MzMzNHJabnd3cmVScmUzVHRGam01dVJYeXZnb0xDdUt4aC84djdRUzV1blhyUlllT25TcjlNOUtzZWZObzNLUkp5ZU12UHY4OHBrMTlyMHpQa1VxbDRxM1hYNHZKRThadjFXdW9TdnNLQkFBMUl3REdqWTFVS2hVUkVYbDVlZEY1OTkxTDlYMTlOamppbWp4eFloU1YweG41cGJGMmJWRjhPR3QyMnRjMm5LQktJN2R1M2RoOWp6MUxIaytiK2w0VTVPZW5CVkZXVmxaMDc5bXp3dDdYeWhVcllzYTBhV2xmMi9pa3Q4cXc4ZGd1K0hSK2hXNi9LdTRyQkFCVWV5dFhySWlaMHovWTRFanIyNWRTbTdkb0VUdTFiVnZ5ZVB4Vy9QYkF0bHE5T3YzM3l1dHNYNmRNMzkralYrL0l5c3JhWUNWa2JFUkV6UGpnZzFpMWN1WFg0OUczWXBlV0Z5eEluMXdiTkd4WTZaK1I3T3owY3p0U0d5eTlWNFNxdXE4UUFGRHRqUnY5OVFUZWVmY3VVVDh2NzF1Ty92Y3ErZitMRmk2TStaOThYT0d2dVY2OSttbVBWNVh4UWpNYkxpa3ZYNzRzWnMrYzhkWGtsa3JGcEEyV3FWdnZ0Rk8wYU5teXd0NVhZVUg2ejhoenE4Q3lkbjcrbXZRQTNISEhDdDErVmQxWENBQ285bVo4TUsza1NDb3pNek42OXU2enhiKzczWGJiUlkvZXZiK09oMG80K3Q5Kyt6cWJYQXltTEJIU3VrMmJhTm1xZGNualNlUEhwLzBLMmNZbkdmYXB3QlBNY2piNlRZcWlvcUpLLzN3c1dyZ3c3WEhMVnEyamZjZU9GYkx0cXJ5dkVBQlE3YVZTcVpnNGZ0d0dSMXhiL2tkMHR5NTdSTDM2WHgxOXIxKy9QdTBJckNKa1pHVEVvVWNjRVhYcjFTdjUyclNwNzVYcFVyTWJ2NzhKRzAwaWl6LzdMRDc5NUpPU3h6MTY5YTZ3MndpM2F0TW03ZkVYbjM5ZTZaK1BsU3RYeGlmejVxVjk3Y1JUQjBidmZ2MUxmZExvMWgvOVY5MTloUUNBR21IREh3TTBhOTQ4ZG03Yjdsdi9RZjVnNnRSWXMzcDFCUnp4Yng4N05HMGF2ZnIwalVHL3ZDRDY5UC82UnhETGx5Mkw1NTUrdXRUUGxaV1ZGZDE2OWlwNS9QSGN1V20vQ3JtNUk4dTY5ZXJGYm52c2tmajdiTkN3WVhUYUxmMGt6Tkw4cWwxRmVPbkZGOUtPdkhOeWN1S29BY2ZGYjM1M1ZSeCs5TEhSdFVlUHRPc1lsSWVxdksrbzNWd0lpRVExYXR3NHJyLzE5akovMzd5NUg4WGY3NzZyek4vMytaTEY4ZkhjdWJGenU2OG0vdDc5KzhmSDgrWnVNa0YxN054NWczOTRSMWZhKzAybFV2SCtsQ254L0xOUHg0b1ZLMHI5Zlh0MDdaYjJjL1dOanlqL1o4ckVDWEhJWVllWG5Ield1Mi8vUkgvVk1UczdPNDQ3K1dkcEo3c3RXYnc0WnMrY1dTVStOM05tell6L1BEYzhEdjdKb1duWFhNakx5NHQrZSs4ZC9mYmVPeUlpOHZQelk4SDgrZkh4M0kvaW93L254RWR6NXBUOGxrbFpWZFY5QlFLQW1yY0tNR1owU1FCMDdkNGpubnQ2YU5yUG9IdjE3VnV5NUx0OCtiS1lOV05HcGJ6Ty9QejhlUFBWVjJMMHlIZktmR0daRFZjdzFxNWRHMU1tVDlyaU5qNllPalc2OXVnUkVSRWRPM2VPQmcwYWxDazJ2bjFsbzA0MGF0STRPblRzRk4vNTNuNXB2MjYzZnYzNkdQTEVZMXM5ZVNiaHJkZGZpOFdMRnNXaFJ4d1pUWGJZWWJOL0p6YzNOOXAzN0JqdE8zYU0vU05pOWFwVk1YN3NtSGp6dFZjamY4MmFhcnV2UUFCUW83MDNlVkljZXZnUlVTYzdPN0t6czJQUDd0MUxmdVVxSXlNajdkZXNKb3daVTJuWFhzL056WTJEZjNKbzdIZkFnVEhpaGVkajlNaDNTdlY5Lzd0azdQOU1lMjlLRkJZVWJQSHZqeDg3cG1SU3ljek1qSjU5K3NZYnI3NlMrT3JHNmxXcjR2RkhIbzZQNTg2dGNwK1JHUjlNaTFrenBzZWUzYnBIajk1OW9rT25UdC80TS9kNjlldkg5L1kvSVBydHRYY01mdXpSK09EOXFWVjZYNEVBb05KVnhMMEFObFpVV0JoVEprOHFPWk82VDcrOVNnSmdsL2J0UzQ3NmlvdUxOem43T3NuM201bVpHYmwxNjBhejVpMWl0eTVkb3Q5ZWUwZDJUazdrNU9iR1lVY2RIUzEyM0RHZUhmTFV0MjZqMTBZM2t4bi8zL2UySmJObnpvamx5NWVWM015bWQ3LytpVTRxNjlhdGk5ZGVIaEdqM240N0NyNWhzcXZzejAwcWxZb3BreWJHbEVrVFkvdnR0NCtkMnJhTm5YWnVHeTFidDQ1V3JkdkVEazJiYnZJOU9ibTVjZEpwQTJQd1kvLysxbHNPVjRkOVJlM21KRUJxcEEwdjZ0TjJsMTFpaDZiTi9oc0RYeC85ZnpSbmRpejk4c3NLZTAycFZDcFdyMW9WY3orY0V5OE9IeFozM25wTDJ0bngvZmY1enJmKytsZEdSa2IwNnRPMzVQSHlaY3ZpdzluZmZQT1k0dUxpbURqdTY5K08yS0ZwMDJpM2EzSlg1c3ZLeW9xZXZmdEVreDJhVnB2UHk5cTFhK1BEMmJQampWZGZpY2YrNzE5eCt4OXZpRDllYzFVODg5VGdXUFRad2szMndaSEhIdmV0VjIyc0R2c0tBUUExenNkejU4YVNSWXRLSHZmdTF5OXljbk9qUzlkdUpWL2I4RGNHS21WMVpOblNlT0xmRDZkOTdhQWZIL0tOUzlIdE8zWk1PMHQ5NHJoeHBmb1J4b1NOamp3M3ZDaE5XWTdLcjdqNHdyVC9YWDM1cFhISFRUZCt0ZFMvd2NtV1RaczFqek4rY1c3YW5mZXFtNVVyVjhhWWQwZkdYYmZkR2krOStQd21rYlBmQVFkKzQvZFg1cjZDVXNXNklhREdyZ0tNSFJNL092U25FUkhSczAvZldMbGlSV3kvL2ZZUkVWR1FueC92djFmNVoxalAvL2pqV0xoZ1FiUnMxU29pdmpvYnZYM0hUbW1YTmQ3UWhsY3ZqSWo0L2tFSHhmY1BPcWpNMjkyelcvY1lQblRJVnQvVmJzTWo1OCtYTEluUGx5eUpLUk1ueElFL1BEZ08rT0hCRWZIVmJ3U2NjTXFwY2ZmdHQ1WDV4TG1xcExpNE9GNS8rZVZvMkxCeHlXOEpSSHgxTFltSUo3ZjRmVlZ0WDRFVkFHcU5EVzhRMUtCQmcvakJqdzhwK2JQSkV5ZWszYkd1TWkzODlOTzB4MXM2YXM3TnpZM2Q5OXl6WExaWnAwNmQ2TnFqL0c4Njg4cUkvNlRkVXJsUm84Wng2T0ZIMW9qUDA4aTMzMHg3bk5lZ1FkU3RXNi9hN2lzUUFOUllxMWV0aXVuVDNpOTVuTDNCUGVrcmUvbC9RNFdGNlNmSzFhdTMrVW1sKzBZM2s5bFdTUzB0RHhzeUpPMkl2M3V2WG1rM1hhcXVQbCs4ZUpOZlo4eXRXN2RhN3l0cU56OENvRVliUDJaMGRObXphL29SOTRKUEsveFdzTjhrZTZQcjVtOXBaYUpQLzY5UEVDekl6NDhicnY1OXJDL2pIZTBPT2V6dytNNzM5b3VJaUozYnRvdG16WnZIa3NXTHkvWDlyRm16T2w1LzVlWDQ4VThQaTRpdlRvWTc1TERENDk2NzdxelduNldNakl5ME0vbzNGMi9WYlY5aEJRQnFySm5UcDI5eUlaWHhZOFpVcWRmWWVxUHI1cTlZc1h5VHY5T3lWZXUwbThsTW16cTF6Qk5LUk1UVXlaTTNPckpNNXFZem85NTVPMjNjZDI3YkxqcnZ2bnUxL2l5MWF0TW1MUURXclZ1MzJYczNWTGQ5aFJVQXFKRlNxVlRjZE8zVlZmYjE3ZHkyWGJUWU1mM1dyeC9ObnYyTlI1UVJFVk9uVE5xcTdYM3k4YnhZdm14Wk5HelVLQ0lpZXZUdUV5T2VmNjdjcjlTM2J0MjZlUDNsbCtLd280NHUrZHBCUC9weHpKdyt2ZEl1dk5TMjNTN1J2VmZ2ZUdYRWkyVzY2ZEwvYkh6Vy8reVpNemI3WHFyYnZzSUtBRkRCR2pkcEVnTk9Pam50YXdzWExJZ0ZHNTBVbUpXVkZkMTdmWDNyNG9MOC9ESmZXLzkvaW91TDAzNzdJUzh2TDdFajgzR2pSOFd5cFV1L1BvSnUzV2FUSDhkVTZEOTIyMjBYL2ZmWkp5NisvSXI0MGFFLzNleUZmalo3bEpTVkZZY2RkY3dtcjMzc3FIYzMrM2VyNDc3Q0NnQ1E1QVNVbVJrNU9iblJmTWNkdjdvUzRONzdwSjJZbUVxbFl0aG1yZ1RZWmMrdWFUZVRtZmIrMWkwcC84OTdreWZGUHQvOVhzbmozdjM2eHdmdnYxL3U3M2Y5K3ZYeDJzc3Z4WkhIRGlqNTJvRUhIeHpUcHI1WGFhc0FFUkYxc3JQanU5L2ZQL2JkNy9zeDc2TVBZL2FzV1RIM3d3OWo2WmRmeE9wVnF5T1ZXaDg1dWJuUnJGbnphTit4WS9UdTE3L2tLTHprcUg3eTVKZytiVnFOMlZjSUFDaDNXM3RYdDRpSVdUT214NFAzL2IxV3ZOOVVLaFZQUFBKd3pKdjcwU1ovdHZIUGZqZisyWEJaZlRKdlh0cmxaanZ2M2lYcTUrWEZxcFVyeTMwOEpvd2RFL3NkY0dESjVaZGI3Tmd5dXZYb0daTW5UcWowejAxR1JrYTAyN1Y5bWErMDk4SDdVK1BKUngvWjdKOVY1MzFGTFR3b01RUlF1ZWJOL1NqK2NzZnQ4ZDVtN2hMWHFGSGphTit4WThuamdvS0NtRDF6Mis1ZVdGeGNuSGFiMmN6TXpPalp1MDhpN3kyVlNzV3JJLzZUOXJVRER6NjQ1RzZNRldudWgzUGlnWHZ2aWZGangwUitmbjZadjMvcGwxL0drNDgrRW84OCtNL04vcVpHZGQ5WFdBRUFFbEpjWEJ5RmhZV1J2MlpOTEZtOEtENzk1Sk9ZT21WS2ZMWnd3UmEvcDFlLzlKdkpmTENOUzhvYkhwbW1MUzMzN1JkdnZmNWFJdTk3MG9UeHNkOEJCMGF6RmkwaUltS0hwczJpWjUrK2FmZHJxS2p4bnpOclpzeVpOVE9lZnZLSmFOMW1wOWkxUTRmWXNWV3JhTmE4UlRSbzBDQnkvcnQ4WDFoWUVBWDVCYkZrOGFMNGJPSENtUEhCdFBoNDd0eHYvTkZGVGRoWEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTnZrL3dHMi9pWTB5R2xIZVFBQUFBQkpSVTVFcmtKZ2dnPT0iLCAidHlwZSI6ICJpbWFnZS9wbmciLCAic2l6ZXMiOiAiNTEyeDUxMiIsICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSJ9XX0=">
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAALDUlEQVR42u3deVSU9QLG8YdhBmEEARXRbopFKIIbMs5IqDf1JrmC+3q0csfbdutY17y36CZZUpknM7WSOFluiVu5oLRYCAoKggjOVdy6wUwoiDIr894/LI4DM8MMBjLD8znHo877m3d+77xfx3feWQCIiIiIiIiIiIiIiIiIqPVxs3egb2CYcD8nGjb6WO1k7/7d+p/v/M1NsGds3fW62TdWqHuZmwO3YWW+ddZt93bCge0UHJ/vxsOK+x5rZVlhg72K+G+aXAmDJgZNxKCJGDQRgyYGTcSgiRg0EYMmspPTvPRNxJe+iYccRAyaiEETMWgiBk0MmohBEzFoIgZNxKCJQRMxaCIGTcSgiRg0MWgiBk3EoIkYNBGDJgZNxKCJGDQRgyaCmHeBc+m9NNvm8oJ1slZ9//CrwFwk5NYQtj1fBcagXSxkVw6b321HfFJIxKCJGDQRgyZi0MSgiRg0EYMmYtBEDJpagVb7brvJscdtLt+5J4p1MGjnD7nuOIbNoJ06ZIbNY2giPkITn1cwaOLzCgZNrel5BY+hiU8KiRg0EYMmYtDEoIkYNFGLw/PQTWDF47a/7ejNNBnvJAbt/CHXHcewGbRTh8yweQxNxKCJQRMxaCIGTdSEWvRZDv48EXKJoO39MQx/jGPY1CKDbuzPE2HYxGNoYtBEDJqIQRMxaCIGTQyaiEETMWgiBk0MmohBEzFoIgZNxKCJQRMxaCIGTcSgiRg0MWgiBk3EoIkYNBGDJgZN5Hzc7B3oGxgm8O6i+6myrLDBXvkITTzkIGLQRAyaiEETgyZi0EQMmohBEzFoYtBEDJqIQRMxaCIGTQyaiEETMWiiP5fY1Tdw4dMz8U7iqxaXqdTl6NFnaIPrCH44CPu+3owHugRaHfPmqrVIWrPBrtu1prpag8rKmyhV/YbcvLPIys7Fvm/ScPt2dbNtKx+hXVxoj2B8uzvFZswrElabxdxYUqkXunQJRES/cDw1Zyo+XpuI4rzvkZjwMtq2lXJnMOh70zu8J/anJiOwU0eLywVBwLLlK/Hh+uQmm4O3d1vEL5qDjO9S0Ss0hDuFQTfOgP69sX9XMjp2aG9xuclkwnMvvY6Nn33ZLPMJ6vYgUrdtQlC3B7lzGLRjBskjsGfHp/DzbWdxeU1NDeKfexUpW3Y267w6Bwbgvbf/zR3EoO03JFqOXVs3wcfH2+Jyo7EG85csw9Ydext9Gyp1Ofw6h5v96vJQJIY/MQ1bt++xed0Rw6IRpYjkjmLQDRsxLBo7tqyHVOplcbneYMCc+c8jde/BP/22NRotTuUWYPGzy7Eq6SObY8eN/ht3FoO2bVTMMHyVsg6enp4Wl2t1Osya+wy+PZje5HN594MNUKnLrS6PflTGHcagrYsbF4OUT9bAQyKx+ug5bXY80tKPNct8DAYjjmflWF0e2CmAO41BWzZ9ynh8+vFqSCSWX2O6des2Jk5fiB+OZTbrvG7cqLS6zM/Xh+VaIW7NG9/e3w8ffbASIpHlf9eVlVWYNGMhsk+duS9zs6ai4ibLZdAWNl7sbnXZ9RsVmDB1AfLyC5t9Xh4SCaIGWT+TUapSs1wGbT/1b9cRO2UeCs+dvy+3/+LzixDQsb3V5T9nZHMnMWj7HTiU3uwxe3p6olfPYCycNwszpsbaHLv/wFHuJAZtvzmzJuPWrWosf+3tJll/p4AOqCg926jrHkn/yeYZkNaOp+2siF80B0mrVsDNza3FzKm0TI0XX/kPdw6Dbpz5T87AmtWvt4ior1z9BROmLcDlK9e4Yxi0ZSp1eYNv/Zw7e7LNU3tN7fbtaqzfmIKox+JwrkjJYnkMbduKhNXQGwz4x7MLrI6ZMTUWYrEYi5/5J2pqappsLhqN9vdPrKiRm1eIrJOnsdeBT6wQgwYAvJG4Bnq9Aa+8FG91zJSJY+DhIcG8xS/BaLy3qFvLx6F4yHEfrUpahzcS19gcEzt2JD7f9L7V93wQg25R3lu7CSsSVtscM2bUCHyRvBZtPDx4hzHolu/D9cl4+dVEm2NGjhhq862mxKBblA2fbsELyxIgCNZ/eO7wxx61+WEAYtAtyuaU7fj7C/+CyWSyOmZItBy7vtoIb++2vMMYdMu3ZWsqljy73OapukGKAUjdtgnt2vE9ygzaCWzbuQ/zlyyzeapuYGQ/m58Sp+Zj92u6voFhgjNs0KTpMzBANrDe5e39vDFjbDQA4GhGPoou/g/dH+iAWTPnmo17Yuw4DHlsGJTFRUjetNHiOtt4SBDQvh2iIkLQqYNv7eX5BUWImzofbbykWPrCi+gc4IdJMQqz9f9x28Cd7/aorKhAYUE+jhw6CL1O1+B2qEpL8UHSOwDuvENv+MgYhPXuA28fH8BkxGB5H/QNDYJHnU/gnL9wFWnHC3Hl0iVs+HCtU8ZaWVbYYK8u+cJKyYUL+GT9unqXL7krloeDH4HSoEcbT0/otFoAgLu7OyIiZai4ccPmOr19fDB6fCyUF6/irYTX6h2SjJ84AteuXoEgCAjpNxzqsjKzUP392+OT9esgEonQNSgIs596GmKxBHt37bRrO/4wZeYs+Pn746uUZKjKyuDn748f+0dAq9Eg49iPdeY0GX/p+iC6BgUhIDDQbE485HABalUZSn/9FX37R9ReFhoWDp1Oi8slF21e91ZVFU5mZsJLKoWfv/kb8SUSCfoNGID0w4dwQamETK6wuh6TyYTLJSXIzclBz7BeDs1fLBajR2gv/PTD9/jl2jUYDAaoVSqkHz5UL2ZH5sSgnVhOVhYi5fLav8sUCuScONHg9dp6eyNSLsf18nJU3Lhutqx3337QabU4X1SEk5nHEREpg7u7e8OBujv2n2VNTQ30ej0eDg5pcP2NnZMzcslDjoeCg7Ey6T2zy7JPZCF1+zazy87knsbo2Dh06twZOo0WwSE9sGv7NowaO67BdVZVVWHL5s/qHW7IFApkn8iCIAg4d7YA4yZMRGh4OM6eqf9BW5FIhK7dgtA/MhK5OTkObYcgCNj79U7ETZmK0PAwXC65hCuXSlBYkI/f1OpGz4lBO9ExdF06nQ4FeXmQDVRAo9VAWVyEqps3G1ynl5cXooYMxZMLF2Hd++/ievmdL4Xp0LEjunV/CNu/3FL7KJpz8gRk8kFm8dQNtbAgHwf27XV4O/JOn4KyuBghPXuiW/fukCkUeHzUaOzfvQtZGRkOzYlBu4jsE5mYNfcp6PV6fLNnt13X0Wg0SD98CFHRgzFgoBxHDh74/ZFwEEQiEZatMP9CRUEQ4Ovnh8qKCrNQxWIxwvr0xaRp0xHWuw8KzuQ5PP/q6tvIO30KeadPwc3NDROnTceoceNxMjMTJpPJ7jkxaBdxuaQEGk01PD29UHzOwa8scEPtsahIJEKEbCC2fpGC/Nxcs2EL4pcicqAc6WmHzS43Go04c/oUOnfpgvETJ0FZXATdXafuHCUIAi6XlCAiUgaxRAKjweDwnPik0AW8//YqvJXwms2Xue/m5eWF4SNj4OnphXNnCwAAPXuFQSqV4nxRUb3xhQUFiJQrrH6U64ejRwAAQ4YNd+gsx4L4pQjv0xe+vn6QSCToGhSEwUP/iov/VUKv093TnPgI3cKfFOr1eiQsf+VPWadOq4VKVYYvP9+MK5cu1T7xuqBU1p7TNo8nH6PHx+KRkB5Wj+W/O5KGmDFjkJXxc+1xvK3tMBqNSDtwAFGDh2BMXByk0raounkTRYVnax917Z2T8nyxy+x7l3ulkFyXPa8U8pCDeAxNRERERERERERERERERE7u//kE/kRK3vb5AAAAAElFTkSuQmCC">
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABYElEQVR42mNgGGDAyMDAwMAvrvUfXULd6xADMwMjAzMDAwMLAwMD839GCA0T+w9hQ8Sg7P8MUPUQNQg9DAwzd5ljdQDToA0BeoEBD4FRB4w6gKoO0Mk+M3AOgFlOqiNIckCI//GBiwKY5aQ4ghi1FEVBjesZih3MRKnl+BxBcRSQk6qp5gByU/VoSTjkHDDaIBkaDggP8WV4du8MAwsLM8PsaV0MB3atYkiKD2f48OIqw4cXVxluXjrIEBHqh6KW6iHAxMTIMH9mH4OcrDSDX0gyw9ev3xi+ffvOICqrz3Dx8jWGtORoskKAhViFHBwcDD5ezgyO7uEMnz59ZmBgYGDg4uJkeP34IsPLV28Y6pt7aeuAb9++Myxcspph1dLpDP6hyXAxKSUTitIA0Q6Yv+4Qw+nL9xl+/dvBEJOSyfD7x1eGr99/MrT29MHVtNbVMsirajN8/f5ztBwYdQDRAAA4sW8Wdh0XxQAAAABJRU5ErkJggg==">
    <title>Sistema de KPIs v90 - Produção e Encomendas</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root { --bg-primary:#0f172a;--bg-secondary:#1e293b;--bg-card:#1e293b;--bg-card-hover:#334155;--text-primary:#f1f5f9;--text-secondary:#94a3b8;--text-muted:#64748b;--accent-green:#10b981;--accent-green-soft:rgba(16,185,129,0.15);--accent-blue:#3b82f6;--accent-blue-soft:rgba(59,130,246,0.15);--accent-amber:#f59e0b;--accent-amber-soft:rgba(245,158,11,0.15);--accent-red:#ef4444;--accent-red-soft:rgba(239,68,68,0.15);--accent-purple:#8b5cf6;--accent-purple-soft:rgba(139,92,246,0.15);--accent-cyan:#06b6d4;--accent-cyan-soft:rgba(6,182,212,0.15);--border-color:#334155;--shadow:0 4px 6px -1px rgba(0,0,0,0.3);--radius:12px;--radius-sm:8px; }
        * { box-sizing:border-box;margin:0;padding:0; }
        body { font-family:'DM Sans',-apple-system,sans-serif;background:var(--bg-primary);color:var(--text-primary);min-height:100vh;-webkit-tap-highlight-color:transparent; }
        
        /* PWA - Safe area para iPhones com notch */
        @supports (padding: max(0px)) {
            .app { padding: 20px; padding-top: max(20px, env(safe-area-inset-top)); padding-bottom: max(20px, env(safe-area-inset-bottom)); }
        }
        
        /* PWA - Standalone mode */
        @media all and (display-mode: standalone) {
            .header { padding-top: 10px; }
        }
        
        .app { max-width:1600px;margin:0 auto;padding:20px; }
        .header { display:flex;align-items:center;justify-content:space-between;padding:20px 0;margin-bottom:24px;border-bottom:1px solid var(--border-color);flex-wrap:wrap;gap:12px; }
        .header-left { display:flex;align-items:center;gap:16px; }
        .logo { width:48px;height:48px;background:linear-gradient(135deg,var(--accent-blue),var(--accent-purple));border-radius:var(--radius);display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0; }
        .header h1 { font-size:24px;font-weight:700; }
        .header p { font-size:13px;color:var(--text-muted); }
        
        /* Loading spinner */
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-spinner { display:inline-block;width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin 0.8s linear infinite;margin-right:8px; }
        .btn { display:inline-flex;align-items:center;gap:8px;padding:10px 16px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;cursor:pointer;transition:all 0.2s;border:none;font-family:inherit; }
        .btn-primary { background:var(--accent-blue);color:white; }
        .btn-primary:hover { background:#2563eb;transform:translateY(-1px); }
        .btn-secondary { background:var(--bg-card);color:var(--text-primary);border:1px solid var(--border-color); }
        .tabs { display:flex;gap:4px;background:var(--bg-secondary);padding:4px;border-radius:var(--radius);margin-bottom:24px; }
        .tab { padding:10px 20px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;cursor:pointer;transition:all 0.2s;border:none;background:transparent;color:var(--text-secondary);font-family:inherit; }
        .tab:hover { color:var(--text-primary);background:var(--bg-card-hover); }
        .tab.active { background:var(--accent-blue);color:white; }
        .kpi-grid { display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-bottom:24px; }
        .kpi-card { background:var(--bg-card);border-radius:var(--radius);padding:20px;border:1px solid var(--border-color);transition:all 0.2s; }
        .kpi-card:hover { border-color:var(--accent-blue);transform:translateY(-2px);box-shadow:var(--shadow); }
        .kpi-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:12px; }
        .kpi-icon { width:40px;height:40px;border-radius:var(--radius-sm);display:flex;align-items:center;justify-content:center;font-size:20px; }
        .kpi-icon.green { background:var(--accent-green-soft); }
        .kpi-icon.blue { background:var(--accent-blue-soft); }
        .kpi-icon.amber { background:var(--accent-amber-soft); }
        .kpi-icon.red { background:var(--accent-red-soft); }
        .kpi-icon.purple { background:var(--accent-purple-soft); }
        .kpi-icon.cyan { background:var(--accent-cyan-soft); }
        .kpi-trend { display:flex;align-items:center;gap:4px;font-size:12px;font-weight:500;padding:4px 8px;border-radius:20px; }
        .kpi-trend.up { background:var(--accent-green-soft);color:var(--accent-green); }
        .kpi-trend.down { background:var(--accent-red-soft);color:var(--accent-red); }
        .kpi-value { font-size:32px;font-weight:700;font-family:'JetBrains Mono',monospace;margin-bottom:4px; }
        .kpi-value.green { color:var(--accent-green); }
        .kpi-value.blue { color:var(--accent-blue); }
        .kpi-value.amber { color:var(--accent-amber); }
        .kpi-value.red { color:var(--accent-red); }
        .kpi-value.purple { color:var(--accent-purple); }
        .kpi-value.cyan { color:var(--accent-cyan); }
        .kpi-label { font-size:13px;color:var(--text-secondary);margin-bottom:8px; }
        .kpi-progress { height:6px;background:var(--bg-primary);border-radius:3px;overflow:hidden;margin-top:12px; }
        .kpi-progress-bar { height:100%;border-radius:3px;transition:width 0.5s ease; }
        .kpi-progress-bar.green { background:var(--accent-green); }
        .kpi-progress-bar.blue { background:var(--accent-blue); }
        .kpi-progress-bar.amber { background:var(--accent-amber); }
        .kpi-progress-bar.red { background:var(--accent-red); }
        .kpi-meta { display:flex;justify-content:space-between;margin-top:8px;font-size:11px;color:var(--text-muted); }
        .section { background:var(--bg-card);border-radius:var(--radius);padding:20px;border:1px solid var(--border-color);margin-bottom:24px; }
        .section-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:16px; }
        .section-title { font-size:16px;font-weight:600; }
        .chart-container { height:300px;position:relative; }
        .data-table { width:100%;border-collapse:collapse; }
        .data-table th,.data-table td { padding:12px 16px;text-align:left;border-bottom:1px solid var(--border-color); }
        .data-table th { font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);background:var(--bg-primary); }
        .data-table td { font-size:13px; }
        .data-table tr:hover td { background:var(--bg-card-hover); }
        .status-badge { display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:20px;font-size:11px;font-weight:500; }
        .status-badge.excellent { background:var(--accent-green-soft);color:var(--accent-green); }
        .status-badge.good { background:var(--accent-blue-soft);color:var(--accent-blue); }
        .status-badge.warning { background:var(--accent-amber-soft);color:var(--accent-amber); }
        .status-badge.critical { background:var(--accent-red-soft);color:var(--accent-red); }
        .upload-zone { border:2px dashed var(--border-color);border-radius:var(--radius);padding:40px;text-align:center;cursor:pointer;transition:all 0.2s; }
        .upload-zone:hover { border-color:var(--accent-blue);background:var(--accent-blue-soft); }
        .upload-zone input { display:none; }
        .upload-icon { font-size:48px;margin-bottom:16px; }
        .filter-bar { display:flex;gap:12px;margin-bottom:16px;flex-wrap:wrap; }
        .filter-select { padding:8px 12px;border-radius:var(--radius-sm);background:var(--bg-primary);border:1px solid var(--border-color);color:var(--text-primary);font-size:13px;font-family:inherit; }
        .filter-select:focus { outline:none;border-color:var(--accent-blue); }
        .gauge-container { display:flex;justify-content:center;align-items:center;padding:10px; }
        .gauge-needle { transition:transform 0.8s cubic-bezier(0.4,2,0.2,1); transform-origin:50% 50%; }
        .msg-toast { position:fixed;bottom:24px;right:24px;padding:12px 20px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;z-index:1000;animation:slideIn 0.3s ease; }
        .msg-toast.success { background:var(--accent-green);color:white; }
        .msg-toast.error { background:var(--accent-red);color:white; }
        .msg-toast.info { background:var(--accent-blue);color:white; }
        @keyframes slideIn { from{transform:translateX(100%);opacity:0;} to{transform:translateX(0);opacity:1;} }
        .empty-state { text-align:center;padding:60px 20px; }
        .empty-state-icon { font-size:64px;margin-bottom:16px;opacity:0.5; }
        .empty-state-title { font-size:18px;font-weight:600;margin-bottom:8px; }
        .empty-state-text { font-size:14px;color:var(--text-muted);max-width:400px;margin:0 auto; }
        .grid-2 { display:grid;grid-template-columns:repeat(2,1fr);gap:24px; }
        @media(max-width:1024px) { .grid-2{grid-template-columns:1fr;} }
        .summary-row { display:flex;justify-content:space-between;padding:10px 0;border-bottom:1px solid var(--border-color); }
        .summary-row:last-child { border-bottom:none; }
        .summary-label { color:var(--text-secondary);font-size:13px; }
        .summary-value { font-weight:600;font-family:'JetBrains Mono',monospace; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        const { useState, useEffect, useMemo, useRef } = React;
        const e = React.createElement;
        
        function findValue(row, keys) { for(let k of keys) if(row[k]!==undefined && row[k]!==null && row[k]!=='') return row[k]; return ''; }
        
        // Verificar se um valor é realmente um número de fatura válido
        function isFaturaValida(numFatura) {
            if(!numFatura) return false;
            const str = numFatura.toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
            if(str === '' || str === 'nan' || str === 'null' || str === 'undefined' || str === '0') return false;
            if(str.length < 2) return false;
            // Deve conter dígitos E pelo menos um separador (/, -)  OU começar com FAC/FT/ND/NC/REC (padrões de fatura portuguesa)
            const temDigitos = /\d/.test(str);
            const temSeparador = /[\/\-]/.test(str);
            const comecaComPrefixo = /^(fac|ft|nd|nc|rec|fat|inv)/i.test(str);
            // Se contém "fornecido" ou "ann" ou outros valores do EstadoFinal, NÃO é fatura
            const pareceEstado = /(fornecido|entregue|terminad|embalad|produzid|stock|pendente|ann\s)/i.test(numFatura.toString());
            if(pareceEstado) return false;
            return (temDigitos && temSeparador) || comecaComPrefixo || (temDigitos && str.length >= 4);
        }
        
        // Função para normalizar nomes de operações (remover espaços extras)
        function normalizarOperacao(op) {
            if(!op) return '';
            return op.toString().replace(/\s+/g, ' ').trim();
        }
        
        function parseExcelDate(serial) {
            if(!serial && serial!==0) return '';
            if(typeof serial==='string') { if(serial.includes('/')) return serial; const num=parseFloat(serial); if(!isNaN(num) && num>0) { const d=new Date((num-25569)*86400*1000); return String(d.getDate()).padStart(2,'0')+'/'+String(d.getMonth()+1).padStart(2,'0')+'/'+d.getFullYear(); } return serial; }
            if(typeof serial==='number' && serial>0) { const d=new Date((serial-25569)*86400*1000); return String(d.getDate()).padStart(2,'0')+'/'+String(d.getMonth()+1).padStart(2,'0')+'/'+d.getFullYear(); }
            return '';
        }
        
        function getMesAno(ds) { if(!ds) return ''; const p=ds.split('/'); return p.length===3 ? p[1]+'/'+p[2] : ''; }
        
        function parseExcelTime(tv) {
            if(!tv) return '';
            try {
                if(typeof tv==='string') { tv=tv.trim(); const m=tv.match(/^(\d{1,2}):(\d{2})/); if(m) return String(m[1]).padStart(2,'0')+':'+String(m[2]).padStart(2,'0'); const n=parseFloat(tv); if(!isNaN(n) && n>=0 && n<=1) { const tm=Math.round(n*24*60); return String(Math.floor(tm/60)).padStart(2,'0')+':'+String(tm%60).padStart(2,'0'); } }
                if(typeof tv==='number' && tv>=0 && tv<=1) { const tm=Math.round(tv*24*60); return String(Math.floor(tm/60)).padStart(2,'0')+':'+String(tm%60).padStart(2,'0'); }
            } catch(e){}
            return '';
        }
        
        function calcDuracao(ini, fim) { try { const i=parseExcelTime(ini), f=parseExcelTime(fim); if(!i||!f) return 0; const [hi,mi]=i.split(':').map(Number), [hf,mf]=f.split(':').map(Number); let d=((hf*60)+mf)-((hi*60)+mi); if(d<0) d=(24*60)+d; return d; } catch(e){return 0;} }
        
        function minutosParaHoras(m) { if(!m||m===0) return '0h'; const h=Math.floor(m/60), min=Math.round(m%60); return min===0 ? h+'h' : h+'h '+min+'m'; }
        function formatNumber(n, d=0) { if(n===undefined||n===null||isNaN(n)) return '0'; return n.toLocaleString('pt-PT',{minimumFractionDigits:d,maximumFractionDigits:d}); }
        function formatCurrency(n) { if(n===undefined||n===null||isNaN(n)) return '0 €'; return n.toLocaleString('pt-PT',{minimumFractionDigits:2,maximumFractionDigits:2})+' €'; }
        
        function KPICard({icon, iconColor, label, value, valueColor, progress, progressColor, meta, target}) {
            return e('div',{className:'kpi-card'},
                e('div',{className:'kpi-header'}, e('div',{className:`kpi-icon ${iconColor}`},icon)),
                e('div',{className:`kpi-value ${valueColor||''}`},value),
                e('div',{className:'kpi-label'},label),
                progress!==undefined && e('div',{className:'kpi-progress'}, e('div',{className:`kpi-progress-bar ${progressColor||'blue'}`,style:{width:Math.min(progress,100)+'%'}})),
                (meta||target) && e('div',{className:'kpi-meta'}, meta && e('span',null,meta), target && e('span',null,'Meta: '+target))
            );
        }
        
        function Gauge({value, label}) {
            const percentage = Math.min(Math.max(value, 0), 120);
            const clampedForColor = Math.min(value, 100);
            
            // Arco de 180° (de -90° a +90°, ou seja, de 9h a 3h)
            const cx = 120, cy = 110, r = 80, r2 = 65;
            const startAngle = -210; // graus (7h)
            const endAngle = 30;    // graus (5h)  
            const sweep = endAngle - startAngle; // 240°
            
            // Função para converter ângulo em coordenadas
            const polarToXY = (angle, radius) => {
                const rad = (angle * Math.PI) / 180;
                return { x: cx + radius * Math.cos(rad), y: cy + radius * Math.sin(rad) };
            };
            
            // Arco de fundo (track)
            const trackStart = polarToXY(startAngle, r);
            const trackEnd = polarToXY(endAngle, r);
            const trackPath = `M ${trackStart.x} ${trackStart.y} A ${r} ${r} 0 1 1 ${trackEnd.x} ${trackEnd.y}`;
            
            // Arco de preenchimento (fill)
            const fillAngle = startAngle + (percentage / 120) * sweep;
            const fillEnd = polarToXY(fillAngle, r);
            const largeArc = (fillAngle - startAngle) > 180 ? 1 : 0;
            const fillPath = `M ${trackStart.x} ${trackStart.y} A ${r} ${r} 0 ${largeArc} 1 ${fillEnd.x} ${fillEnd.y}`;
            
            // Cor baseada no valor
            const getColor = (v) => v >= 85 ? '#22c55e' : v >= 60 ? '#f59e0b' : '#ef4444';
            const fillColor = getColor(clampedForColor);
            
            // Agulha
            const needleAngle = startAngle + (percentage / 120) * sweep;
            const needleTip = polarToXY(needleAngle, r - 8);
            const needleBase1 = polarToXY(needleAngle + 90, 4);
            const needleBase2 = polarToXY(needleAngle - 90, 4);
            
            // Marcações
            const ticks = [0, 20, 40, 60, 80, 100, 120];
            
            return e('div',{className:'gauge-container',style:{flexDirection:'column'}},
                e('svg',{width:240,height:155,viewBox:'0 0 240 155',style:{overflow:'visible'}},
                    // Definições
                    e('defs',null,
                        e('linearGradient',{id:`grad_${label.replace(/\s/g,'')}`,x1:'0%',y1:'0%',x2:'100%',y2:'0%'},
                            e('stop',{offset:'0%',stopColor:'#ef4444'}),
                            e('stop',{offset:'40%',stopColor:'#f59e0b'}),
                            e('stop',{offset:'70%',stopColor:'#22c55e'}),
                            e('stop',{offset:'100%',stopColor:'#22c55e'})
                        ),
                        e('filter',{id:'needleShadow'},
                            e('feDropShadow',{dx:0,dy:1,stdDeviation:2,floodColor:'rgba(0,0,0,0.3)'})
                        )
                    ),
                    // Arco de fundo
                    e('path',{d:trackPath,fill:'none',stroke:'#1e293b',strokeWidth:14,strokeLinecap:'round'}),
                    // Arco de progresso com gradiente
                    percentage > 0.5 && e('path',{d:fillPath,fill:'none',stroke:`url(#grad_${label.replace(/\s/g,'')})`,strokeWidth:14,strokeLinecap:'round'}),
                    // Marcações e números
                    ...ticks.map(t => {
                        const tickAngle = startAngle + (t / 120) * sweep;
                        const outerP = polarToXY(tickAngle, r + 10);
                        const innerP = polarToXY(tickAngle, r + 3);
                        const labelP = polarToXY(tickAngle, r + 22);
                        return e('g',{key:t},
                            e('line',{x1:innerP.x,y1:innerP.y,x2:outerP.x,y2:outerP.y,stroke:'#64748b',strokeWidth:t%20===0?2:1}),
                            e('text',{x:labelP.x,y:labelP.y,textAnchor:'middle',dominantBaseline:'middle',fill:'#94a3b8',fontSize:9,fontFamily:'JetBrains Mono, monospace'},t.toString())
                        );
                    }),
                    // Sub-marcações pequenas
                    ...[10,30,50,70,90,110].map(t => {
                        const tickAngle = startAngle + (t / 120) * sweep;
                        const outerP = polarToXY(tickAngle, r + 7);
                        const innerP = polarToXY(tickAngle, r + 3);
                        return e('line',{key:'sub'+t,x1:innerP.x,y1:innerP.y,x2:outerP.x,y2:outerP.y,stroke:'#475569',strokeWidth:1});
                    }),
                    // Agulha
                    e('polygon',{
                        points:`${needleTip.x},${needleTip.y} ${needleBase1.x},${needleBase1.y} ${needleBase2.x},${needleBase2.y}`,
                        fill:fillColor,
                        filter:'url(#needleShadow)',
                        className:'gauge-needle'
                    }),
                    // Centro da agulha
                    e('circle',{cx:cx,cy:cy,r:8,fill:'#1e293b',stroke:'#334155',strokeWidth:2}),
                    e('circle',{cx:cx,cy:cy,r:3,fill:fillColor}),
                    // Valor digital
                    e('text',{x:cx,y:cy+32,textAnchor:'middle',fill:fillColor,fontSize:22,fontWeight:700,fontFamily:'JetBrains Mono, monospace'},value.toFixed(1)+'%'),
                    // Label
                    e('text',{x:cx,y:cy+48,textAnchor:'middle',fill:'#94a3b8',fontSize:11},label)
                )
            );
        }
        
        function App() {
            const [activeTab, setActiveTab] = useState('dashboard');
            const [msg, setMsg] = useState('');
            const [msgType, setMsgType] = useState('info');
            const [encomendas, setEncomendas] = useState([]);
            const [encomendasProducao, setEncomendasProducao] = useState([]); // Pendentes - só para OEE
            const [registosProducao, setRegistosProducao] = useState([]);
            const [registosOperacoes, setRegistosOperacoes] = useState([]);
            const [registosPerturbacoes, setRegistosPerturbacoes] = useState([]);
            const [objetivos, setObjetivos] = useState({});
            const [objetivosTipologia, setObjetivosTipologia] = useState({});
            const [mapCaixaEcode, setMapCaixaEcode] = useState({});
            const [mapaHoras, setMapaHoras] = useState({}); // {mesAno: totalMinutos} ex: {'01/2026': 109938}
            const [filtroMes, setFiltroMes] = useState('');
            const [filtroAno, setFiltroAno] = useState('2026');
            const [filtroTipologia, setFiltroTipologia] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [lastUpdate, setLastUpdate] = useState(null);
            const chartRefs = useRef({});
            
            const showMsg = (text, type='info') => { setMsg(text); setMsgType(type); setTimeout(()=>setMsg(''),4000); };
            
            // URL único do Power Automate que retorna todos os dados
            const [urlPowerAutomate, setUrlPowerAutomate] = useState(() => {
                try { 
                    return localStorage.getItem('kpi_url_powerautomate') || 'https://defaultcade90c14fe343a3860494c20418f8.fb.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d4580994e5004a7f9934f95e968ae3f5/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=fup1O88I7aEoSyDzrILnUSRbaCYbucNvpKktzTubedQ'; 
                } catch(e) { 
                    return 'https://defaultcade90c14fe343a3860494c20418f8.fb.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d4580994e5004a7f9934f95e968ae3f5/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=fup1O88I7aEoSyDzrILnUSRbaCYbucNvpKktzTubedQ'; 
                }
            });
            
            // Guardar URL quando muda
            useEffect(() => {
                if(urlPowerAutomate) {
                    try { localStorage.setItem('kpi_url_powerautomate', urlPowerAutomate); } catch(e) {}
                }
            }, [urlPowerAutomate]);
            
            // Função para carregar dados do Power Automate
            const carregarDadosPowerAutomate = async () => {
                if(!urlPowerAutomate) {
                    showMsg('⚠️ Configure o URL do Power Automate nas definições', 'error');
                    return;
                }
                
                setIsLoading(true);
                showMsg('🔄 A carregar dados...', 'info');
                console.log('📡 A fazer fetch para:', urlPowerAutomate.substring(0, 50) + '...');
                
                try {
                    const response = await fetch(urlPowerAutomate, {
                        method: 'POST',
                        mode: 'cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ acao: 'ler' })
                    });
                    
                    console.log('📡 Resposta recebida, status:', response.status);
                    
                    if(!response.ok) throw new Error('Erro na resposta: ' + response.status);
                    
                    const textRaw = await response.text();
                    console.log('📄 Resposta raw (primeiros 500 chars):', textRaw.substring(0, 500));
                    
                    let data;
                    try {
                        data = JSON.parse(textRaw);
                    } catch(parseErr) {
                        console.error('❌ Erro a fazer parse do JSON:', parseErr);
                        console.log('📄 Resposta completa:', textRaw);
                        throw new Error('JSON inválido recebido do Power Automate');
                    }
                    
                    console.log('📥 Dados recebidos do Power Automate:', data);
                    
                    // Processar Produção
                    if(data.producao && Array.isArray(data.producao)) {
                        const ops = data.producao.map(row => {
                            // Converter data Excel para formato dd/mm/yyyy
                            let dataFormatada = '';
                            const dataRaw = row['Data'] || row['data'];
                            if(dataRaw) {
                                if(typeof dataRaw === 'number' || /^\d+$/.test(dataRaw)) {
                                    const excelDate = parseInt(dataRaw);
                                    const jsDate = new Date((excelDate - 25569) * 86400 * 1000);
                                    dataFormatada = jsDate.toLocaleDateString('pt-PT');
                                } else {
                                    dataFormatada = dataRaw;
                                }
                            }
                            
                            // Extrair mês/ano
                            let mesAno = '';
                            if(dataFormatada) {
                                const parts = dataFormatada.split('/');
                                if(parts.length >= 3) {
                                    mesAno = parts[1] + '/' + parts[2];
                                }
                            }
                            
                            // Calcular duração a partir do campo Duração (formato "Xh Ymin")
                            let duracao = 0;
                            const duracaoStr = row['Duração'] || row['Duracao'] || row['duracao'] || '';
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            
                            return {
                                data: dataFormatada,
                                unidadeProducao: row['Unidade Produção'] || row['UnidadeProducao'] || row['unidadeProducao'],
                                tipologia: row['Tipo Caixa'] || row['TipoCaixa'] || row['tipologia'],
                                artigo: row['Artigo'] || row['artigo'],
                                caixa: row['Artigo'] || row['Programa ANN'] || row['ProgramaANN'] || row['caixa'],
                                operacao: row['Operação'] || row['Operacao'] || row['operacao'],
                                colaborador: row['Colaborador'] || row['colaborador'],
                                horaInicio: row['Hora Início'] || row['HoraInicio'] || row['horaInicio'],
                                horaFim: row['Hora Fim'] || row['HoraFim'] || row['horaFim'],
                                duracao: duracao,
                                mesAno: mesAno
                            };
                        }).filter(r => r.operacao);
                        setRegistosOperacoes(ops);
                        console.log('✅ Operações carregadas:', ops.length, 'Exemplo:', ops[0]);
                    }
                    
                    // Processar Perturbações
                    if(data.perturbacoes && Array.isArray(data.perturbacoes)) {
                        console.log('🔍 Primeira perturbação raw:', data.perturbacoes[0]);
                        const pert = data.perturbacoes.map(row => {
                            // Calcular duração a partir do campo Duração (formato "Xh Ymin")
                            let duracao = 0;
                            const duracaoStr = row['Duração'] || row['Duracao'] || row['duracao'] || '';
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            
                            // Converter data Excel para formato dd/mm/yyyy
                            let dataFormatada = '';
                            const dataRaw = row['Data'] || row['data'];
                            if(dataRaw) {
                                if(typeof dataRaw === 'number' || /^\d+$/.test(dataRaw)) {
                                    const excelDate = parseInt(dataRaw);
                                    const jsDate = new Date((excelDate - 25569) * 86400 * 1000);
                                    dataFormatada = jsDate.toLocaleDateString('pt-PT');
                                } else {
                                    dataFormatada = dataRaw;
                                }
                            }
                            
                            // Extrair mês/ano
                            let mesAno = '';
                            if(dataFormatada) {
                                const parts = dataFormatada.split('/');
                                if(parts.length >= 3) {
                                    mesAno = parts[1] + '/' + parts[2];
                                }
                            }
                            
                            return {
                                data: dataFormatada,
                                unidadeProducao: row['Unidade Produção'] || row['UnidadeProducao'] || row['Unidade'],
                                tipo: row['Tipo Perturbação'] || row['TipoPerturbação'] || row['Tipo'] || row['tipo'],
                                descricao: row['Descrição'] || row['Descricao'] || row['descricao'] || row['Comentários'],
                                colaborador: row['Colaborador'] || row['colaborador'],
                                duracao: duracao,
                                mesAno: mesAno
                            };
                        }).filter(r => r.tipo);
                        setRegistosPerturbacoes(pert);
                        console.log('✅ Perturbações carregadas:', pert.length, 'Exemplo:', pert[0]);
                    }
                    
                    // Processar Encomendas
                    if(data.encomendas && Array.isArray(data.encomendas)) {
                        console.log('🔍 Primeira encomenda raw:', data.encomendas[0]);
                        console.log('🔍 TODAS as colunas da 1ª encomenda:', JSON.stringify(Object.keys(data.encomendas[0])));
                        
                        const enc = data.encomendas.map(row => {
                            const mesEntrega = row['MesEntrega'] || row['Mês Entrega'] || row['Mes Entrega'];
                            const anoEntrega = row['AnoEntrega'] || row['Ano Entrega'];
                            const mesProducao = row['MesProducao'] || row['Mês Produção'] || row['Mes Producao'] || row['Mes Produção'];
                            const anoProducao = row['AnoProducao'] || row['Ano Produção'] || row['Ano Producao'];
                            const mesEmbalamento = row['MesEmbalamento'] || row['Mês Embalamento'] || row['Mes Embalamento'];
                            const anoEmbalamento = row['AnoEmbalamento'] || row['Ano Embalamento'];
                            
                            const buildMesAno = (mes, ano) => {
                                if(!mes || !ano) return '';
                                const mesesNome = {'janeiro':'01','fevereiro':'02','março':'03','marco':'03','abril':'04','maio':'05','junho':'06','julho':'07','agosto':'08','setembro':'09','outubro':'10','novembro':'11','dezembro':'12'};
                                let mesStr = mes.toString().toLowerCase().trim();
                                let mesNum = mesesNome[mesStr] || (parseInt(mesStr) > 0 ? parseInt(mesStr).toString().padStart(2,'0') : '');
                                return mesNum ? mesNum + '/' + ano : '';
                            };
                            
                            // Extrair mês/ano de uma data raw (número Excel ou string dd/mm/yyyy)
                            const mesAnoFromData = (dataRaw) => {
                                if(!dataRaw) return '';
                                const str = dataRaw.toString().trim();
                                if(!str || str === 'NaN' || str === 'nan') return '';
                                // Número Excel (ex: 46027)
                                if(/^\d{4,5}$/.test(str)) {
                                    const jsDate = new Date((parseInt(str) - 25569) * 86400 * 1000);
                                    if(!isNaN(jsDate.getTime())) {
                                        return (jsDate.getMonth()+1).toString().padStart(2,'0') + '/' + jsDate.getFullYear();
                                    }
                                }
                                // String dd/mm/yyyy ou mm/dd/yyyy
                                const parts = str.split(/[\/\-\.]/);
                                if(parts.length >= 3) {
                                    const d = parseInt(parts[0]), m = parseInt(parts[1]), y = parseInt(parts[2]);
                                    if(y > 2000) return m.toString().padStart(2,'0') + '/' + y;
                                }
                                return '';
                            };
                            
                            let mesAnoEntrega = buildMesAno(mesEntrega, anoEntrega);
                            // Fallback: usar DataEntregaReal se MesEntrega/AnoEntrega estão vazios
                            if(!mesAnoEntrega) {
                                mesAnoEntrega = mesAnoFromData(row['DataEntregaReal'] || row['Data Entrega Real'] || row['dataEntregaReal']);
                            }
                            
                            let mesAnoProducao = buildMesAno(mesProducao, anoProducao);
                            if(!mesAnoProducao) {
                                mesAnoProducao = mesAnoFromData(row['DataProducao'] || row['Data Produção'] || row['dataProducao']);
                            }
                            
                            let mesAnoEmbalamento = buildMesAno(mesEmbalamento, anoEmbalamento);
                            if(!mesAnoEmbalamento) {
                                mesAnoEmbalamento = mesAnoFromData(row['DataEmbalamento'] || row['Data Embalamento'] || row['dataEmbalamento']);
                            }
                            
                            // Fatura - procurar em todas as variantes possíveis de nome de coluna
                            const numFaturaRaw = row['NºFatura'] || row['Nº Fatura'] || row['numFatura'] || row['NumFatura'] || row['N_x00ba_Fatura'] || row['Fatura'] || row['N.º Fatura'] || row['Nº_Fatura'];
                            const numFaturaStr = (numFaturaRaw || '').toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
                            const faturada = isFaturaValida(numFaturaRaw);
                            
                            return {
                                tipologia: row['Tipologia'] || row['tipologia'],
                                caixa: row['Caixa'] || row['caixa'],
                                ligacao: row['Ligação'] || row['Ligacao'] || row['ligacao'],
                                po: row['PO'] || row['po'],
                                pos: row['POS'] || row['pos'] || row['Pos'] || '',
                                ecode: row['Ecode'] || row['ecode'],
                                valor: parseFloat(row['Valor'] || row['valor']) || 0,
                                quantidade: parseInt(row['Quantidade'] || row['quantidade']) || 1,
                                qtdEntregue: parseInt(row['QuantidadeEntregue'] || row['Quantidade Entregue'] || row['qtdEntregue']) || 0,
                                faturada,
                                numFatura: numFaturaRaw,
                                localizacao: row['Localização'] || row['Localizacao'] || row['localizacao'] || row['Local'] || '',
                                mesAnoEntrega,
                                mesAnoProducao,
                                mesAnoEmbalamento,
                                anoEntrega: anoEntrega ? parseInt(anoEntrega) : (mesAnoEntrega ? parseInt(mesAnoEntrega.split('/')[1]) : null),
                                mesEntrega: mesEntrega ? parseInt(mesEntrega) : (mesAnoEntrega ? parseInt(mesAnoEntrega.split('/')[0]) : null),
                                anoProducao: anoProducao ? parseInt(anoProducao) : (mesAnoProducao ? parseInt(mesAnoProducao.split('/')[1]) : null)
                            };
                        }).filter(r => r.tipologia || r.caixa);
                        enc.forEach(e => e._origem = 'terminada');
                        
                        // Debug completo
                        const com2026 = enc.filter(e => e.anoEntrega === 2026);
                        const localizacoes = [...new Set(enc.map(e => e.localizacao).filter(l => l))];
                        const comFatura = enc.filter(e => e.faturada);
                        const comMesEntrega = enc.filter(e => e.mesAnoEntrega);
                        const comMesProd = enc.filter(e => e.mesAnoProducao);
                        const comMesEmb = enc.filter(e => e.mesAnoEmbalamento);
                        console.log('✅ Encomendas carregadas:', enc.length, '| Com 2026:', com2026.length, '| Com fatura:', comFatura.length, '| Sem fatura:', enc.filter(e=>!e.faturada).length, '| Valor faturado:', comFatura.reduce((s,e)=>s+(e.valor||0),0).toFixed(2));
                        // Debug: valores de fatura
                        const valoresNumFatura = [...new Set(enc.map(e => (e.numFatura||'').toString().trim()))];
                        console.log('📋 Valores ÚNICOS de NumFatura (' + valoresNumFatura.length + '):', valoresNumFatura.slice(0,30));
                        // Debug: mostrar quais foram aceites e quais rejeitados
                        const rejeitados = enc.filter(e => !e.faturada && e.numFatura);
                        if(rejeitados.length > 0) console.log('⚠️ NumFatura REJEITADOS (não parecem faturas reais):', [...new Set(rejeitados.map(e => (e.numFatura||'').toString().trim()))].slice(0,20));
                        if(comFatura.length > 0) console.log('✅ NumFatura ACEITES:', [...new Set(comFatura.map(e => (e.numFatura||'').toString().trim()))].slice(0,20));
                        console.log('📅 Datas: mesEntrega:', comMesEntrega.length, '| mesProducao:', comMesProd.length, '| mesEmbalamento:', comMesEmb.length);
                        console.log('🔍 Localizações encontradas:', localizacoes);
                        // Debug: mostrar distribuição por mês de entrega
                        const distMesEntrega = {};
                        enc.forEach(e => { const m = e.mesAnoEntrega || 'SEM'; distMesEntrega[m] = (distMesEntrega[m]||0)+1; });
                        console.log('📅 Distribuição por mês ENTREGA:', distMesEntrega);
                        // Debug: ver colunas raw relacionadas com data de entrega
                        if(data.encomendas[0]) {
                            const rawKeys = Object.keys(data.encomendas[0]);
                            const dataKeys = rawKeys.filter(k => k.toLowerCase().includes('entrega') || k.toLowerCase().includes('data') || k.toLowerCase().includes('mes') || k.toLowerCase().includes('ano') || k.toLowerCase().includes('semana'));
                            console.log('🔍 Colunas RAW com data/entrega/mes/ano:', dataKeys);
                            dataKeys.forEach(k => console.log('   →', k, '=', JSON.stringify(data.encomendas[0][k])));
                        }
                        if(enc.length > 0) {
                            console.log('🔍 1ª enc:', { numFatura: enc[0].numFatura, faturada: enc[0].faturada, valor: enc[0].valor, mesAnoEntrega: enc[0].mesAnoEntrega, mesAnoProducao: enc[0].mesAnoProducao, mesAnoEmbalamento: enc[0].mesAnoEmbalamento });
                            // Mostrar as 3 últimas para ver se têm datas diferentes
                            const last = enc[enc.length-1];
                            console.log('🔍 Última enc:', { caixa: last.caixa, mesAnoEntrega: last.mesAnoEntrega, mesAnoProducao: last.mesAnoProducao, mesAnoEmbalamento: last.mesAnoEmbalamento });
                        }
                        
                        setEncomendas(enc);
                    }
                    
                    // Processar Encomendas em Produção (pendentes)
                    if(data.encomendasProducao && Array.isArray(data.encomendasProducao)) {
                        console.log('🔍 Primeira encomenda produção raw:', data.encomendasProducao[0]);
                        
                        const encProd = data.encomendasProducao.map(row => {
                            // Nomes com espaços (tabela Encomendas) ou sem (tabela EncomendasTerminadas)
                            const mesProducao = row['Mês Produção'] || row['MesProdução'] || row['MesProducao'] || row['Mes Producao'];
                            const anoProducao = row['Ano Produção'] || row['AnoProdução'] || row['AnoProducao'] || row['Ano Producao'];
                            const mesEntrega = row['Mês Entrega'] || row['MesEntrega'] || row['Mes Entrega'];
                            const anoEntrega = row['Ano Entrega'] || row['AnoEntrega'] || row['Ano Entrega'];
                            
                            // Construir mesAnoProducao
                            let mesAnoProducao = '';
                            if(mesProducao && anoProducao && mesProducao !== 'NaN' && anoProducao !== 'NaN') {
                                // Mês pode vir como "Janeiro", "Fevereiro" ou número
                                const mesesNome = {'janeiro':1,'fevereiro':2,'março':3,'abril':4,'maio':5,'junho':6,'julho':7,'agosto':8,'setembro':9,'outubro':10,'novembro':11,'dezembro':12};
                                let mesNum = parseInt(mesProducao);
                                if(isNaN(mesNum) && typeof mesProducao === 'string') {
                                    mesNum = mesesNome[mesProducao.toLowerCase()] || 0;
                                }
                                if(mesNum > 0) {
                                    mesAnoProducao = mesNum.toString().padStart(2,'0') + '/' + anoProducao;
                                }
                            }
                            
                            // Construir mesAnoEntrega
                            let mesAnoEntrega = '';
                            if(mesEntrega && anoEntrega) {
                                const mesesNome = {'janeiro':1,'fevereiro':2,'março':3,'abril':4,'maio':5,'junho':6,'julho':7,'agosto':8,'setembro':9,'outubro':10,'novembro':11,'dezembro':12};
                                let mesNum = parseInt(mesEntrega);
                                if(isNaN(mesNum) && typeof mesEntrega === 'string') {
                                    mesNum = mesesNome[mesEntrega.toLowerCase()] || 0;
                                }
                                if(mesNum > 0) {
                                    mesAnoEntrega = mesNum.toString().padStart(2,'0') + '/' + anoEntrega;
                                }
                            }
                            
                            return {
                                tipologia: row['Tipologia'] || row['tipologia'],
                                caixa: row['Caixa'] || row['caixa'],
                                ligacao: row['Ligação'] || row['Ligacao'] || row['ligacao'],
                                po: row['PO'] || row['po'],
                                pos: row['POS'] || row['pos'] || row['Pos'] || '',
                                ecode: row['Ecode'] || row['ecode'],
                                quantidade: parseInt(row['Quantidade Produzida'] || row['QuantidadeProduzida'] || row['Quantidade'] || row['quantidade']) || 1,
                                qtdProduzida: parseInt(row['Quantidade Produzida'] || row['QuantidadeProduzida']) || 0,
                                qtdEntregue: parseInt(row['Quantidade Entregue'] || row['QuantidadeEntregue']) || 0,
                                estado: row['Estado'] || row['estado'],
                                subEstado: row['SubEstado'] || row['subEstado'],
                                localizacao: row['Localização'] || row['Localizacao'] || row['localizacao'] || row['Local'] || '',
                                valor: parseFloat(row['Valor'] || row['valor']) || 0,
                                numFatura: row['NumFatura'] || row['NºFatura'] || row['Nº Fatura'] || row['numFatura'] || row['N_x00ba_Fatura'] || row['Fatura'],
                                faturada: isFaturaValida(row['NumFatura'] || row['NºFatura'] || row['Nº Fatura'] || row['numFatura'] || row['N_x00ba_Fatura'] || row['Fatura']),
                                mesAnoProducao,
                                mesAnoEntrega,
                                mesAnoEmbalamento: mesAnoProducao, // usar produção como fallback
                                anoProducao: anoProducao ? parseInt(anoProducao) : null,
                                mesProducao: mesProducao,
                                anoEntrega: anoEntrega ? parseInt(anoEntrega) : null,
                                emProducao: true // marcador para distinguir das terminadas
                            };
                        }).filter(r => r.tipologia || r.caixa);
                        // Marcar origem: faturadas vs stock
                        encProd.forEach(e => e._origem = e.faturada ? 'faturada' : 'stock');
                        
                        // Separar pendentes faturadas (não estão terminadas mas têm fatura)
                        const pendFaturadas = encProd.filter(e => e.faturada);
                        
                        // Separar pendentes em stock (não faturadas mas produzidas/entregues)
                        const pendStock = encProd.filter(e => {
                            if(e.faturada) return false;
                            const estado = (e.estado || '').toLowerCase().trim();
                            const subEstado = (e.subEstado || '').toLowerCase().trim();
                            return subEstado === 'terminada' || 
                                   estado === 'entregue' || 
                                   estado === 'em stock' ||
                                   estado === 'produzida';
                        });
                        
                        console.log('✅ Encomendas em produção carregadas:', encProd.length, '| Faturadas:', pendFaturadas.length, '| Em stock:', pendStock.length, '| Valor fat pendentes:', pendFaturadas.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                        if(encProd.length > 0) {
                            console.log('🔍 Primeira enc produção processada:', { 
                                caixa: encProd[0].caixa, 
                                mesAnoProducao: encProd[0].mesAnoProducao,
                                mesAnoEntrega: encProd[0].mesAnoEntrega,
                                anoProducao: encProd[0].anoProducao,
                                quantidade: encProd[0].quantidade,
                                faturada: encProd[0].faturada,
                                numFatura: encProd[0].numFatura
                            });
                        }
                        
                        // Adicionar pendentes faturadas E em stock ao array principal de encomendas
                        setEncomendas(prev => {
                            // Evitar duplicados: PO+POS é a chave única de uma encomenda
                            const idsTerminadas = new Set(prev.map(e => String(e.po||'').trim()+'|'+String(e.pos||'').trim()));
                            const novasFaturadas = pendFaturadas.filter(e => {
                                const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                return !idsTerminadas.has(id);
                            });
                            const novosStock = pendStock.filter(e => {
                                const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                return !idsTerminadas.has(id);
                            });
                            console.log('📋 Adicionando', novasFaturadas.length, 'pendentes faturadas +', novosStock.length, 'em stock ao array principal');
                            if(pendFaturadas.length > novasFaturadas.length) {
                                const dupl = pendFaturadas.filter(e => {
                                    const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                    return idsTerminadas.has(id);
                                });
                                console.log('⚠️ Duplicadas faturadas (mesmo PO+POS já nas terminadas):', dupl.map(e => ({caixa:e.caixa, po:e.po, pos:e.pos, numFatura:e.numFatura})));
                            }
                            return [...prev, ...novasFaturadas, ...novosStock];
                        });
                        
                        // Guardar separadamente - só para cálculo de OEE
                        setEncomendasProducao(encProd);
                    }
                    
                    // Processar Objetivos por Operação
                    if(data.objetivosOperacao && Array.isArray(data.objetivosOperacao)) {
                        console.log('🔍 Primeiro objetivo operação raw:', data.objetivosOperacao[0]);
                        const objs = {};
                        data.objetivosOperacao.forEach(row => {
                            const operacao = row['Operação'] || row['Operacao'] || row['operacao'];
                            const tempo = row['Tempo Objetivo'] || row['TempoObjetivo'] || row['tempoObjetivo'] || row['Tempo'];
                            if(operacao && tempo) {
                                // Tempo vem em fração de dia (Excel time format)
                                // Ex: 0.5 = 12 horas = 720 minutos
                                // Ex: 0.041666... = 1 hora = 60 minutos
                                let mins = 0;
                                const tempoNum = parseFloat(tempo);
                                if(!isNaN(tempoNum)) {
                                    mins = Math.round(tempoNum * 24 * 60); // dias para minutos
                                }
                                if(mins > 0) objs[operacao] = mins;
                            }
                        });
                        setObjetivos(prev => ({...prev, ...objs}));
                        console.log('✅ Objetivos operação carregados:', Object.keys(objs).length, 'Exemplo:', Object.entries(objs).slice(0,3));
                    }
                    
                    // Processar Objetivos por Tipologia
                    if(data.objetivosTipologia && Array.isArray(data.objetivosTipologia)) {
                        console.log('🔍 Primeiro objetivo tipologia raw:', data.objetivosTipologia[0]);
                        const objsTip = {};
                        data.objetivosTipologia.forEach(row => {
                            const tipologia = row['Tipologia'] || row['tipologia'];
                            const tempo = row['Tempo Objetivo'] || row['TempoObjetivo'] || row['tempoObjetivo'] || row['Tempo'];
                            if(tipologia && tempo) {
                                // Tempo vem em fração de dia (Excel time format)
                                // Ex: 1.215... = ~29 horas = ~1750 minutos
                                let mins = 0;
                                const tempoNum = parseFloat(tempo);
                                if(!isNaN(tempoNum)) {
                                    mins = Math.round(tempoNum * 24 * 60); // dias para minutos
                                }
                                if(mins > 0) objsTip[tipologia] = mins;
                            }
                        });
                        setObjetivosTipologia(prev => ({...prev, ...objsTip}));
                        console.log('✅ Objetivos tipologia carregados:', Object.keys(objsTip).length, 'Exemplo:', Object.entries(objsTip).slice(0,3));
                    }
                    
                    // Processar Mapa de Horas (Tempo Disponível)
                    if(data.mapaHoras && Array.isArray(data.mapaHoras)) {
                        console.log('🔍 Primeiro mapa horas raw:', data.mapaHoras[0]);
                        const mapa = {};
                        data.mapaHoras.forEach(row => {
                            const mesRaw = row['Mes'] || row['mes'] || row['Mês'] || '';
                            const total = parseFloat(row['Total'] || row['total'] || row['TotalHoras'] || 0);
                            if(mesRaw && total > 0) {
                                // Converter formato "2026-01" para "01/2026"
                                let mesAno = mesRaw;
                                if(mesRaw.includes('-')) {
                                    const parts = mesRaw.split('-');
                                    mesAno = parts[1] + '/' + parts[0]; // "01/2026"
                                }
                                if(!mapa[mesAno]) mapa[mesAno] = 0;
                                mapa[mesAno] += Math.round(total * 60); // horas para minutos
                            }
                        });
                        setMapaHoras(prev => ({...prev, ...mapa}));
                        console.log('✅ Mapa Horas carregado:', mapa);
                    }
                    
                    setLastUpdate(new Date());
                    showMsg('✅ Dados carregados com sucesso!', 'success');
                    
                } catch(err) {
                    console.error('❌ Erro ao carregar dados:', err);
                    showMsg('❌ Erro ao carregar: ' + err.message, 'error');
                } finally {
                    setIsLoading(false);
                }
            };
            
            // Estado para configuração
            const [showConfig, setShowConfig] = useState(false);
            
            // Guardar URL
            useEffect(() => {
                try {
                    if(urlPowerAutomate) localStorage.setItem('kpi_url_powerautomate', urlPowerAutomate);
                } catch(e) {}
            }, [urlPowerAutomate]);
            
            // Carregar dados automaticamente ao iniciar (se URL configurado)
            useEffect(() => {
                console.log('🚀 App iniciada, URL:', urlPowerAutomate ? 'configurado' : 'vazio');
                if(urlPowerAutomate) {
                    console.log('🔄 A iniciar carregamento automático...');
                    carregarDadosPowerAutomate();
                }
            }, []);
            
            // Importar Registos Produção Évora (ficheiro com 2 folhas: Produção + Perturbações)
            const importRegistosProducao = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar registos de produção...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Processar folha Produção (Operações)
                    const sheetProd = wb.Sheets['Produção'] || wb.Sheets['Producao'] || wb.Sheets[wb.SheetNames[0]];
                    const dataProd = XLSX.utils.sheet_to_json(sheetProd, {defval:''});
                    
                    const operacoes = dataProd.map(row => {
                        const operacao = findValue(row, ['Operação','operacao','OPERAÇÃO','Op']);
                        const tipologia = findValue(row, ['Tipo Caixa','TipoCaixa','Tipologia','tipologia']);
                        const artigo = findValue(row, ['Artigo','artigo']);
                        const colaborador = findValue(row, ['Colaborador','colaborador']);
                        const unidadeProducao = findValue(row, ['Unidade Produção','UnidadeProducao','unidadeProducao','Unidade']);
                        const dtRaw = findValue(row, ['Data','data']);
                        const dt = typeof dtRaw === 'string' && dtRaw.includes('-') 
                            ? dtRaw.split('-').reverse().join('/').substring(0,10).split('/').map((p,i)=>i<2?p.padStart(2,'0'):p).join('/')
                            : parseExcelDate(dtRaw);
                        const inicio = findValue(row, ['Hora Início','horaInicio','Início']);
                        const fim = findValue(row, ['Hora Fim','horaFim','Fim']);
                        const duracaoStr = findValue(row, ['Duração','duracao']);
                        let duracao = 0;
                        if(duracaoStr) {
                            const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                            if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                        }
                        if(duracao===0) duracao = calcDuracao(inicio, fim);
                        const quantidade = parseFloat(findValue(row, ['Quantidade','quantidade','Qtd']))||0;
                        return { operacao, tipologia, artigo, colaborador, unidadeProducao, data:dt, inicio, fim, duracao, quantidade, mesAno:getMesAno(dt) };
                    }).filter(r => r.operacao && r.data);
                    
                    // Processar folha Perturbações
                    const sheetPert = wb.Sheets['Perturbações'] || wb.Sheets['Perturbacoes'];
                    let perturbacoes = [];
                    if(sheetPert) {
                        const dataPert = XLSX.utils.sheet_to_json(sheetPert, {defval:''});
                        perturbacoes = dataPert.map(row => {
                            const tipo = findValue(row, ['Tipo Perturbação','TipoPerturbacao','Tipo','tipo','Perturbação']);
                            const colaborador = findValue(row, ['Colaborador','colaborador']);
                            const dtRaw = findValue(row, ['Data','data']);
                            const dt = typeof dtRaw === 'string' && dtRaw.includes('-') 
                                ? dtRaw.split('-').reverse().join('/').substring(0,10).split('/').map((p,i)=>i<2?p.padStart(2,'0'):p).join('/')
                                : parseExcelDate(dtRaw);
                            const inicio = findValue(row, ['Hora Início','horaInicio','Início']);
                            const fim = findValue(row, ['Hora Fim','horaFim','Fim']);
                            const duracaoStr = findValue(row, ['Duração','duracao']);
                            let duracao = 0;
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            if(duracao===0) duracao = calcDuracao(inicio, fim);
                            return { tipo, colaborador, data:dt, inicio, fim, duracao, mesAno:getMesAno(dt) };
                        }).filter(r => r.tipo && r.data);
                    }
                    
                    // Também extrair produção agregada por tipologia
                    const producaoAgg = {};
                    operacoes.forEach(r => {
                        const key = r.data + '|' + r.tipologia;
                        if(!producaoAgg[key]) producaoAgg[key] = { data:r.data, tipologia:r.tipologia, quantidade:0, tempoOperacoes:0, mesAno:r.mesAno };
                        producaoAgg[key].quantidade += r.quantidade || 0;
                        producaoAgg[key].tempoOperacoes += r.duracao;
                    });
                    const producao = Object.values(producaoAgg);
                    
                    setRegistosOperacoes(operacoes);
                    setRegistosPerturbacoes(perturbacoes);
                    setRegistosProducao(producao);
                    
                    showMsg(`✅ Importado: ${operacoes.length} operações + ${perturbacoes.length} perturbações!`,'success');
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            const importEncomendas = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar encomendas...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Função para processar uma folha de encomendas
                    const processarFolha = (sheetName) => {
                        if(!wb.SheetNames.includes(sheetName)) return [];
                        const data = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {defval:'', raw:false});
                        console.log('📥 A processar folha:', sheetName, '- Linhas:', data.length);
                        
                        return data.map(row => {
                            const tipologia = findValue(row, ['Tipologia','tipologia','TIPOLOGIA','Tipo']);
                            const caixa = findValue(row, ['Caixa','caixa','CAIXA','TipoCaixa']);
                            const ligacao = findValue(row, ['Ligacao','Ligação','ligacao','TipoCaixa']);
                            const po = findValue(row, ['PO','po','Encomenda']);
                            const pos = findValue(row, ['POS','pos','Pos','Position']);
                            const ecode = findValue(row, ['Ecode','ecode','ECODE','ECode','Código']);
                            
                            // Datas - converter formato ISO ou serial Excel
                            const parseData = (val) => {
                                if(!val) return '';
                                const v = val.toString().trim();
                                if(v.includes('T') || v.match(/^\d{4}-\d{2}-\d{2}/)) {
                                    const parts = v.split('T')[0].split('-');
                                    if(parts.length === 3) return parts[2] + '/' + parts[1] + '/' + parts[0];
                                }
                                if(v.includes('/')) return v;
                                return parseExcelDate(val);
                            };
                            
                            const dataEncomenda = parseData(findValue(row, ['DataEncomenda','Data Encomenda','dataEncomenda']));
                            const dataEntregaPrevista = parseData(findValue(row, ['DataEntregaPrevista','Data Entrega Prevista','dataEntregaPrevista']));
                            const dataProducao = parseData(findValue(row, ['DataProducao','Data Produção','dataProducao']));
                            const dataEntregaReal = parseData(findValue(row, ['DataEntregaReal','Data Entrega Real','dataEntregaReal']));
                            const dataEmbalamento = parseData(findValue(row, ['DataEmbalamento','Data Embalamento','dataEmbalamento']));
                            
                            // Quantidades
                            const quantidade = parseFloat(findValue(row, ['QuantidadeProduzida','Quantidade Produzida','Quantidade','quantidade']))||1;
                            const qtdEntregue = parseFloat(findValue(row, ['QuantidadeEntregue','Quantidade Entregue','qtdEntregue']))||0;
                            const qtdEmbalada = parseFloat(findValue(row, ['QuantidadeEmbalada','Quantidade Embalada','qtdEmbalada']))||0;
                            
                            // Valor e Fatura
                            const valorRaw = findValue(row, [' Valor ', 'Valor', ' Valor', 'Valor ', 'valor', 'VALOR', 'Preço']);
                            let valor = 0;
                            if(valorRaw !== undefined && valorRaw !== null && valorRaw !== '') {
                                const valorStr = String(valorRaw).replace(/€/g, '').replace(/\s/g, '').replace(/,/g, '');
                                valor = parseFloat(valorStr) || 0;
                            }
                            const numFatura = findValue(row, ['NumFatura','NºFatura','Nº Fatura','numFatura','N_x00ba_Fatura','Fatura']);
                            const estadoFinal = findValue(row, ['EstadoFinal','Estado Final','estadoFinal']);
                            const estado = findValue(row, ['Estado','estado']);
                            const subEstado = findValue(row, ['SubEstado','Sub Estado','subEstado']);
                            
                            const numFaturaStr = (numFatura || '').toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
                            const faturada = isFaturaValida(numFatura);
                            
                            // Mês/Ano para agrupamento
                            const mesProducao = findValue(row, ['MesProducao','Mês Produção','mesProducao']);
                            const anoProducao = findValue(row, ['AnoProducao','Ano Produção','anoProducao']);
                            const mesEntrega = findValue(row, ['MesEntrega','Mês Entrega','mesEntrega']);
                            const anoEntrega = findValue(row, ['AnoEntrega','Ano Entrega','anoEntrega']);
                            const mesEmbalamento = findValue(row, ['MesEmbalamento','Mês Embalamento','mesEmbalamento']);
                            const anoEmbalamento = findValue(row, ['AnoEmbalamento','Ano Embalamento','anoEmbalamento']);
                            
                            const getMesAnoFromParts = (mes, ano) => {
                                if(!mes || !ano || mes === 'sem data') return '';
                                const mesesMap = {'janeiro':'01','fevereiro':'02','março':'03','marco':'03','abril':'04','maio':'05','junho':'06','julho':'07','agosto':'08','setembro':'09','outubro':'10','novembro':'11','dezembro':'12'};
                                const mesNum = mesesMap[mes.toString().toLowerCase()] || mes.toString().padStart(2,'0');
                                return mesNum + '/' + ano;
                            };
                            
                            return { 
                                tipologia, caixa, ligacao, po, pos, ecode, estado, subEstado,
                                dataEncomenda, dataEntregaPrevista, dataProducao, dataEntregaReal, dataEmbalamento,
                                quantidade, qtdEntregue, qtdEmbalada,
                                valor, numFatura, estadoFinal, faturada,
                                mesAnoProducao: getMesAnoFromParts(mesProducao, anoProducao) || getMesAno(dataProducao),
                                mesAnoEntrega: getMesAnoFromParts(mesEntrega, anoEntrega) || getMesAno(dataEntregaReal),
                                mesAnoEmbalamento: getMesAnoFromParts(mesEmbalamento, anoEmbalamento) || getMesAno(dataEmbalamento)
                            };
                        }).filter(r => r.tipologia || r.caixa);
                    };
                    
                    // Processar folha EncomendasTerminadas
                    const terminadas = processarFolha('EncomendasTerminadas');
                    terminadas.forEach(e => e._origem = 'terminada');
                    // Debug: ver colunas raw da folha EncomendasTerminadas
                    if(data.EncomendasTerminadas && data.EncomendasTerminadas[0]) {
                        const rawKeys = Object.keys(data.EncomendasTerminadas[0]);
                        const fatKeys = rawKeys.filter(k => k.toLowerCase().includes('fat') || k.toLowerCase().includes('fatura') || k.toLowerCase().includes('invoice'));
                        console.log('🔍 EncomendasTerminadas - Colunas fatura:', fatKeys);
                        fatKeys.forEach(k => {
                            const vals = data.EncomendasTerminadas.slice(0,5).map(r => JSON.stringify(r[k]));
                            console.log('   →', k, ':', vals.join(', '));
                        });
                        // Mostrar TODOS os valores únicos da coluna NumFatura
                        const numFatKey = fatKeys.find(k => k.includes('NumFat') || k === 'NumFatura') || fatKeys[0];
                        if(numFatKey) {
                            const valsUnicos = [...new Set(data.EncomendasTerminadas.map(r => JSON.stringify(r[numFatKey])))];
                            console.log('📋 Valores únicos de', numFatKey, '(' + valsUnicos.length + '):', valsUnicos.slice(0,30));
                        }
                    }
                    const termComFatura = terminadas.filter(e => e.faturada);
                    const termSemFatura = terminadas.filter(e => !e.faturada);
                    console.log('📋 Terminadas:', terminadas.length, '| Com fatura:', termComFatura.length, '| Sem fatura:', termSemFatura.length, '| Valor faturado terminadas:', termComFatura.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                    if(termComFatura.length > 0) console.log('🔍 Exemplos faturadas:', termComFatura.slice(0,3).map(e => ({caixa:e.caixa, numFatura:e.numFatura, numFaturaType:typeof e.numFatura, numFaturaLen: (e.numFatura||'').toString().length, valor:e.valor})));
                    if(termSemFatura.length > 0) console.log('🔍 Exemplos NÃO faturadas:', termSemFatura.slice(0,3).map(e => ({caixa:e.caixa, numFatura:e.numFatura, numFaturaRaw:JSON.stringify(e.numFatura), valor:e.valor})));
                    const faturasUnicas = [...new Set(terminadas.map(e => (e.numFatura||'').toString().trim()))].filter(f => f);
                    console.log('📋 Faturas únicas EncomendasTerminadas (' + faturasUnicas.length + '):', faturasUnicas.slice(0,20));
                    
                    // Processar folha Encomendas (pendentes) - apenas as produzidas/em stock
                    let pendentes = processarFolha('Encomendas');
                    
                    // Separar faturadas de não-faturadas primeiro
                    const pendentesFaturadas = pendentes.filter(e => e.faturada);
                    pendentesFaturadas.forEach(e => e._origem = 'faturada');
                    
                    // Não-faturadas: filtrar apenas as que estão produzidas (SubEstado = terminada, ou Estado = entregue/em stock)
                    const pendentesProducidas = pendentes.filter(e => {
                        if(e.faturada) return false; // faturadas já foram tratadas acima
                        const subEstado = (e.subEstado || '').toString().toLowerCase().trim();
                        const estado = (e.estado || '').toString().toLowerCase().trim();
                        const estadoFinal = (e.estadoFinal || '').toString().toLowerCase().trim();
                        return subEstado === 'terminada' || 
                               estado === 'entregue' || 
                               estado === 'em stock' ||
                               estado === 'produzida' ||
                               estadoFinal.includes('embalada') ||
                               estadoFinal.includes('fornecido') ||
                               estadoFinal.includes('terminada');
                    });
                    pendentesProducidas.forEach(e => e._origem = 'stock');
                    
                    // Evitar duplicados: PO+POS é a chave única de uma encomenda
                    const idsTerminadas = new Set(terminadas.map(e => String(e.po||'').trim()+'|'+String(e.pos||'').trim()));
                    const novasFaturadas = pendentesFaturadas.filter(e => {
                        const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                        return !idsTerminadas.has(id);
                    });
                    
                    console.log('📦 Pendentes total:', pendentes.length, '| Produzidas/Stock (não fat):', pendentesProducidas.length, '| Faturadas pendentes:', pendentesFaturadas.length, '| Novas faturadas (sem duplicados por PO+POS):', novasFaturadas.length);
                    console.log('📋 Valor faturado pendentes:', pendentesFaturadas.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                    if(pendentesFaturadas.length > novasFaturadas.length) {
                        const duplicadas = pendentesFaturadas.filter(e => {
                            const id = (e.po||'')+'|'+(e.pos||'');
                            return idsTerminadas.has(id);
                        });
                        console.log('⚠️ Faturadas duplicadas (mesmo PO+POS já em terminadas):', duplicadas.map(e => ({caixa: e.caixa, po: e.po, pos: e.pos, numFatura: e.numFatura, valor: e.valor})));
                    }
                    
                    // Combinar terminadas + pendentes produzidas + faturadas não terminadas
                    const todasEncomendas = [...terminadas, ...pendentesProducidas, ...novasFaturadas];
                    
                    console.log('✅ Terminadas:', terminadas.length, '| Stock:', pendentesProducidas.length, '| Faturadas novas:', novasFaturadas.length, '| Total:', todasEncomendas.length);
                    console.log('💰 Total faturadas no sistema:', terminadas.filter(e=>e.faturada).length + novasFaturadas.length, '(', terminadas.filter(e=>e.faturada).length, 'terminadas +', novasFaturadas.length, 'pendentes)');
                    
                    setEncomendas(todasEncomendas);
                    
                    // Criar mapeamento Caixa → Ecode para usar na análise
                    const newMapCaixaEcode = {};
                    todasEncomendas.forEach(e => {
                        if(e.caixa && e.ecode) newMapCaixaEcode[e.caixa] = e.ecode;
                    });
                    setMapCaixaEcode(newMapCaixaEcode);
                    localStorage.setItem('kpi_mapCaixaEcode', JSON.stringify(newMapCaixaEcode));
                    
                    // Debug - mostrar exemplo com valores
                    const comValor = todasEncomendas.filter(e => e.valor > 0);
                    console.log('📊 Com valor > 0:', comValor.length);
                    console.log('💰 Valor total:', todasEncomendas.reduce((s,e) => s + e.valor, 0));
                    console.log('🗺️ Mapeamento Caixa→Ecode:', Object.keys(newMapCaixaEcode).length, 'entradas');
                    
                    showMsg(`✅ ${terminadas.length} terminadas + ${pendentesProducidas.length} em stock + ${novasFaturadas.length} faturadas = ${todasEncomendas.length} encomendas!`,'success');
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            // Importar Mapa de Horas (Tempo Disponível)
            const importMapaHoras = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar mapa de horas...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Procurar folha MapaHoras
                    const sheetName = wb.SheetNames.find(n => n.toLowerCase().includes('mapahoras') || n.toLowerCase().includes('mapa')) || wb.SheetNames[0];
                    const data = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {defval:'', raw:true});
                    
                    const mapa = {};
                    data.forEach(row => {
                        const mesRaw = row['Mes'] || row['mes'] || row['Mês'] || row['B'] || '';
                        const totalRaw = row['Total'] || row['total'] || row['TotalHoras'] || row['AH'] || 0;
                        const total = parseFloat(totalRaw) || 0;
                        
                        if(mesRaw && total > 0) {
                            // Converter formato "2026-01" para "01/2026"
                            let mesAno = mesRaw.toString();
                            if(mesAno.includes('-')) {
                                const parts = mesAno.split('-');
                                mesAno = parts[1] + '/' + parts[0];
                            }
                            if(!mapa[mesAno]) mapa[mesAno] = 0;
                            mapa[mesAno] += Math.round(total * 60); // horas para minutos
                        }
                    });
                    
                    if(Object.keys(mapa).length > 0) {
                        setMapaHoras(prev => ({...prev, ...mapa}));
                        localStorage.setItem('kpi_mapaHoras', JSON.stringify({...mapaHoras, ...mapa}));
                    }
                    
                    const resumo = Object.entries(mapa).map(([mes, mins]) => `${mes}: ${(mins/60).toFixed(0)}h`).join(', ');
                    showMsg(`✅ Mapa de Horas importado: ${resumo}`,'success');
                    console.log('✅ Mapa Horas importado:', mapa);
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            const importObjetivos = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar objetivos...','info');
                try {
                    const data = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { const wb=XLSX.read(new Uint8Array(e.target.result),{type:'array'}); res(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]],{defval:'',raw:false})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Função para converter tempo para minutos
                    const parseTempoParaMinutos = (tempo) => {
                        if(!tempo) return 0;
                        const t = tempo.toString().trim();
                        
                        // Formato "X days HH:MM:SS" (ex: "1 days 05:10:00")
                        const matchDays = t.match(/(\d+)\s*days?\s*(\d{1,2}):(\d{2})/i);
                        if(matchDays) {
                            const dias = parseInt(matchDays[1]) || 0;
                            const horas = parseInt(matchDays[2]) || 0;
                            const mins = parseInt(matchDays[3]) || 0;
                            return (dias * 24 * 60) + (horas * 60) + mins;
                        }
                        
                        // Formato "HH:MM:SS" ou "HH:MM"
                        const matchTime = t.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
                        if(matchTime) {
                            const horas = parseInt(matchTime[1]) || 0;
                            const mins = parseInt(matchTime[2]) || 0;
                            return (horas * 60) + mins;
                        }
                        
                        // Se for número (minutos diretos)
                        const num = parseFloat(t);
                        if(!isNaN(num)) return num;
                        
                        return 0;
                    };
                    
                    const objs = {};
                    const objsTipo = {};
                    
                    data.forEach(row => {
                        // Objetivos por operação - normalizar nome
                        const operacaoRaw = findValue(row, ['Operação','operacao','OPERAÇÃO','Op']);
                        const operacao = normalizarOperacao(operacaoRaw);
                        const tempoOp = findValue(row, ['Tempo Objetivo','TempoObjetivo','Tempo','tempo','Objetivo','objetivo','Minutos']);
                        if(operacao && tempoOp) {
                            const mins = parseTempoParaMinutos(tempoOp);
                            if(mins > 0) {
                                objs[operacao] = mins;
                                // Também guardar com nome original para compatibilidade
                                if(operacaoRaw !== operacao) objs[operacaoRaw] = mins;
                            }
                        }
                        
                        // Objetivos por tipologia
                        const tipologia = findValue(row, ['Tipologia','tipologia','TIPOLOGIA']);
                        const tempoTipo = findValue(row, ['Tempo Objetivo','TempoObjetivo','Tempo Tipologia','Tempo','tempo']);
                        if(tipologia && tempoTipo) {
                            const mins = parseTempoParaMinutos(tempoTipo);
                            if(mins > 0) objsTipo[tipologia] = mins;
                        }
                    });
                    
                    // Guardar os que foram encontrados
                    if(Object.keys(objs).length > 0) {
                        setObjetivos(prev => ({...prev, ...objs}));
                        localStorage.setItem('kpi_objetivos', JSON.stringify({...objetivos, ...objs}));
                    }
                    if(Object.keys(objsTipo).length > 0) {
                        setObjetivosTipologia(prev => ({...prev, ...objsTipo}));
                        localStorage.setItem('kpi_objetivosTipologia', JSON.stringify({...objetivosTipologia, ...objsTipo}));
                    }
                    
                    const totalOps = Object.keys(objs).length;
                    const totalTipo = Object.keys(objsTipo).length;
                    showMsg(`✅ Importado: ${totalOps > 0 ? totalOps + ' operações' : ''}${totalOps > 0 && totalTipo > 0 ? ' + ' : ''}${totalTipo > 0 ? totalTipo + ' tipologias' : ''}!`,'success');
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            useEffect(() => { 
                try { 
                    const s=localStorage.getItem('kpi_objetivos'); if(s) setObjetivos(JSON.parse(s)); 
                    const st=localStorage.getItem('kpi_objetivosTipologia'); if(st) setObjetivosTipologia(JSON.parse(st));
                    const sm=localStorage.getItem('kpi_mapCaixaEcode'); if(sm) setMapCaixaEcode(JSON.parse(sm));
                    const mh=localStorage.getItem('kpi_mapaHoras'); if(mh) setMapaHoras(JSON.parse(mh));
                } catch(e){} 
            }, []);
            
            const kpis = useMemo(() => {
                let encFiltradas = encomendas;
                let opsFiltradas = registosOperacoes;
                let pertFiltradas = registosPerturbacoes;
                
                // Função para extrair ano de mesAno (formato "MM/YYYY")
                const getAno = (mesAno) => {
                    if(!mesAno) return '';
                    const parts = mesAno.split('/');
                    return parts.length === 2 ? parts[1] : '';
                };
                
                // Filtro por ano (aplicado primeiro) - prioridade: entrega > embalamento > produção
                if(filtroAno) {
                    const antesAno = encFiltradas.length;
                    const fatAntesAno = encFiltradas.filter(e => e.faturada).length;
                    encFiltradas = encomendas.filter(e => {
                        const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                        // Se não tem data mas tem fatura, incluir (não excluir faturadas sem data)
                        if(!ano && e.faturada) return true;
                        return ano === filtroAno;
                    });
                    const fatDepoisAno = encFiltradas.filter(e => e.faturada).length;
                    console.log(`🔍 Filtro ano ${filtroAno}: ${antesAno} → ${encFiltradas.length} encomendas | Faturadas: ${fatAntesAno} → ${fatDepoisAno}`);
                    // Debug: mostrar encomendas faturadas que foram excluídas pelo filtro
                    if(fatAntesAno > fatDepoisAno) {
                        const excluidas = encomendas.filter(e => e.faturada && !encFiltradas.includes(e));
                        console.log('⚠️ Faturadas excluídas pelo filtro ano:', excluidas.map(e => ({caixa: e.caixa, mesAnoEntrega: e.mesAnoEntrega, mesAnoEmbalamento: e.mesAnoEmbalamento, mesAnoProducao: e.mesAnoProducao, origem: e._origem, valor: e.valor})));
                    }
                    opsFiltradas = registosOperacoes.filter(r => getAno(r.mesAno) === filtroAno);
                    pertFiltradas = registosPerturbacoes.filter(r => getAno(r.mesAno) === filtroAno);
                }
                
                // Filtro por mês
                if(filtroMes) {
                    const antesMes = encFiltradas.length;
                    const fatAntesMes = encFiltradas.filter(e => e.faturada).length;
                    encFiltradas = encFiltradas.filter(e => {
                        const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                        // Se não tem data de referência mas tem fatura, incluir (não excluir faturadas sem data)
                        if(!mesRef && e.faturada) return true;
                        return mesRef === filtroMes;
                    });
                    const fatDepoisMes = encFiltradas.filter(e => e.faturada).length;
                    console.log(`🔍 Filtro mês ${filtroMes}: ${antesMes} → ${encFiltradas.length} encomendas | Faturadas: ${fatAntesMes} → ${fatDepoisMes}`);
                    // Debug: mostrar encomendas faturadas que foram excluídas pelo filtro de mês
                    if(fatAntesMes > fatDepoisMes) {
                        const todasAno = encomendas.filter(e => {
                            const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                            return ano === (filtroAno || ano);
                        });
                        const excluidas = todasAno.filter(e => e.faturada).filter(e => {
                            const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                            return mesRef !== filtroMes;
                        });
                        console.log('⚠️ Faturadas excluídas pelo filtro mês:', excluidas.map(e => ({caixa: e.caixa, mesAnoEntrega: e.mesAnoEntrega, mesAnoEmbalamento: e.mesAnoEmbalamento, mesAnoProducao: e.mesAnoProducao, mesRef: e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao, origem: e._origem, valor: e.valor})));
                    }
                    if(antesMes > 0 && encFiltradas.length < antesMes) {
                        const filtradas = encomendas.filter(e => {
                            const ano = getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoEntrega) || getAno(e.mesAnoProducao);
                            return ano === (filtroAno || ano);
                        }).filter(e => {
                            const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                            return mesRef !== filtroMes;
                        });
                        if(filtradas.length > 0) console.log('🔍 Exemplo excluída pelo filtro mês:', { caixa: filtradas[0].caixa, mesAnoEntrega: filtradas[0].mesAnoEntrega, mesAnoProducao: filtradas[0].mesAnoProducao, mesAnoEmbalamento: filtradas[0].mesAnoEmbalamento, faturada: filtradas[0].faturada, origem: filtradas[0]._origem });
                    }
                    opsFiltradas = opsFiltradas.filter(r => r.mesAno===filtroMes);
                    pertFiltradas = pertFiltradas.filter(r => r.mesAno===filtroMes);
                }
                
                // Filtro por tipologia (com mapeamento entre encomendas e registos)
                if(filtroTipologia) {
                    // Mapeamento de tipologias equivalentes
                    const tipologiasEquivalentes = {
                        'Frac': ['Frac', 'E2-Frac', 'E1'],
                        'E2-Frac': ['Frac', 'E2-Frac'],
                        'E1': ['Frac', 'E1'],
                        'E2': ['E2'],
                        'Praetor': ['Praetor'],
                        'KC390': ['KC390'],
                        'Transporte': ['Transporte'],
                        'Maquinacao': ['Maquinacao', 'Frac']
                    };
                    const tiposValidos = tipologiasEquivalentes[filtroTipologia] || [filtroTipologia];
                    encFiltradas = encFiltradas.filter(e => tiposValidos.includes(e.tipologia));
                    opsFiltradas = opsFiltradas.filter(r => tiposValidos.includes(r.tipologia));
                }
                
                // === KPIs de Encomendas Terminadas ===
                const totalEncomendas = encFiltradas.length;
                const encFaturadas = encFiltradas.filter(e => e.faturada);
                const encNaoFaturadas = encFiltradas.filter(e => !e.faturada);
                const taxaFaturacao = totalEncomendas > 0 ? (encFaturadas.length / totalEncomendas) * 100 : 0;
                
                // Valores
                const valorTotal = encFiltradas.reduce((s,e) => s + (e.valor || 0), 0);
                const valorFaturado = encFaturadas.reduce((s,e) => s + (e.valor || 0), 0);
                const valorPorFaturar = encNaoFaturadas.reduce((s,e) => s + (e.valor || 0), 0);
                
                // Totais ANUAIS (sem filtro de mês) para referência
                const encAnuais = filtroAno ? encomendas.filter(e => {
                    const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                    return ano === filtroAno || (!ano && e.faturada);
                }) : encomendas;
                const totalFaturadasAnual = encAnuais.filter(e => e.faturada).length;
                const valorFaturadoAnual = encAnuais.filter(e => e.faturada).reduce((s,e) => s + (e.valor || 0), 0);
                const totalEncAnual = encAnuais.length;
                
                console.log('💰 KPIs Financeiros (filtrados):', { 
                    totalEnc: totalEncomendas, faturadas: encFaturadas.length, naoFaturadas: encNaoFaturadas.length,
                    valorTotal: valorTotal.toFixed(2), valorFaturado: valorFaturado.toFixed(2), valorPorFaturar: valorPorFaturar.toFixed(2)
                });
                console.log('💰 KPIs Financeiros (anuais):', { 
                    totalEncAnual, totalFaturadasAnual, valorFaturadoAnual: valorFaturadoAnual.toFixed(2)
                });
                
                // Valores por Localização (ANN Compósitos vs ANN Metálicos)
                const valorPorLocalizacao = {};
                encFiltradas.forEach(e => {
                    const loc = e.localizacao || 'Sem Localização';
                    if(!valorPorLocalizacao[loc]) valorPorLocalizacao[loc] = { total: 0, faturado: 0, porFaturar: 0, quantidade: 0 };
                    valorPorLocalizacao[loc].total += e.valor || 0;
                    valorPorLocalizacao[loc].quantidade += e.quantidade || 1;
                    if(e.faturada) {
                        valorPorLocalizacao[loc].faturado += e.valor || 0;
                    } else {
                        valorPorLocalizacao[loc].porFaturar += e.valor || 0;
                    }
                });
                console.log('📊 Valores por Localização:', valorPorLocalizacao);
                
                // Quantidades - produzidas = terminadas + stock (sem faturadas que falta embalamento)
                const encTerminadasEStock = encFiltradas.filter(e => e._origem === 'terminada' || e._origem === 'stock');
                const totalProduzido = encTerminadasEStock.reduce((s,e) => s + (e.quantidade || 0), 0);
                const totalEntregue = encFiltradas.reduce((s,e) => s + (e.qtdEntregue || 0), 0);
                const totalEmbalado = encFiltradas.reduce((s,e) => s + (e.qtdEmbalada || 0), 0);
                
                // Separar por origem: terminadas, stock, faturadas não terminadas
                const encEntregues = encFiltradas.filter(e => e._origem === 'terminada');
                const encEmStock = encFiltradas.filter(e => e._origem === 'stock');
                const encFaturadasNaoTerminadas = encFiltradas.filter(e => e._origem === 'faturada');
                const totalEncEntregues = encEntregues.length;
                const totalEncEmStock = encEmStock.length;
                const totalEncFatNaoTerm = encFaturadasNaoTerminadas.length;
                const unidadesEmStock = encEmStock.reduce((s,e) => s + (e.quantidade || 0), 0);
                
                console.log('📊 Encomendas:', { total: encFiltradas.length, entregues: totalEncEntregues, emStock: totalEncEmStock, fatNaoTerm: totalEncFatNaoTerm, unidadesStock: unidadesEmStock });
                
                // Por Tipologia
                const porTipologia = {};
                encFiltradas.forEach(e => {
                    const tip = e.tipologia || 'Sem Tipologia';
                    if(!porTipologia[tip]) porTipologia[tip] = { quantidade:0, qtdEntregue:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porTipologia[tip].quantidade += e.quantidade || 1;
                    porTipologia[tip].qtdEntregue += e.qtdEntregue || 0;
                    porTipologia[tip].valor += e.valor || 0;
                    if(e.faturada) {
                        porTipologia[tip].valorFaturado += e.valor || 0;
                        porTipologia[tip].faturadas++;
                    }
                    porTipologia[tip].total++;
                });
                
                // Debug
                console.log('📊 encFiltradas:', encFiltradas.length);
                console.log('📊 porTipologia:', porTipologia);
                console.log('📊 Filtro Ano:', filtroAno, 'Mês:', filtroMes);
                
                // Por Caixa/Ligação
                const porCaixa = {};
                encFiltradas.forEach(e => {
                    const cx = e.ligacao || e.caixa || 'Sem Caixa';
                    if(!porCaixa[cx]) porCaixa[cx] = { quantidade:0, qtdEntregue:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porCaixa[cx].quantidade += e.quantidade || 1;
                    porCaixa[cx].qtdEntregue += e.qtdEntregue || 0;
                    porCaixa[cx].valor += e.valor || 0;
                    if(e.faturada) {
                        porCaixa[cx].valorFaturado += e.valor || 0;
                        porCaixa[cx].faturadas++;
                    }
                    porCaixa[cx].total++;
                });
                
                // Por Mês (prioridade: entrega > embalamento > produção)
                const porMes = {};
                encFiltradas.forEach(e => {
                    const mes = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao || 'Sem Data';
                    if(mes === 'Sem Data' || !mes) return;
                    if(!porMes[mes]) porMes[mes] = { quantidade:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porMes[mes].quantidade += e.quantidade || 1;
                    porMes[mes].valor += e.valor || 0;
                    if(e.faturada) {
                        porMes[mes].valorFaturado += e.valor || 0;
                        porMes[mes].faturadas++;
                    }
                    porMes[mes].total++;
                });
                
                // === KPIs de Operações (OEE) ===
                const tempoTotalOps = opsFiltradas.reduce((s,r) => s + r.duracao, 0);
                const numOperacoes = opsFiltradas.length;
                
                // Tempo Disponível REAL do Mapa de Horas (soma de todos os meses filtrados)
                let tempoDisponivelReal = 0;
                if(Object.keys(mapaHoras).length > 0) {
                    if(filtroMes) {
                        // Mês específico selecionado
                        tempoDisponivelReal = mapaHoras[filtroMes] || 0;
                    } else {
                        // Todos os meses do ano filtrado - somar apenas os meses que têm operações
                        const mesesComOps = [...new Set(opsFiltradas.map(r => r.mesAno))].filter(m => m);
                        mesesComOps.forEach(mes => {
                            tempoDisponivelReal += mapaHoras[mes] || 0;
                        });
                        // Se não encontrou por meses com operações, somar todos os do ano
                        if(tempoDisponivelReal === 0 && filtroAno) {
                            Object.entries(mapaHoras).forEach(([mes, mins]) => {
                                if(mes.endsWith('/' + filtroAno)) {
                                    tempoDisponivelReal += mins;
                                }
                            });
                        }
                    }
                }
                
                const usaMapaHoras = tempoDisponivelReal > 0;
                console.log('⏰ Tempo Disponível:', usaMapaHoras ? 
                    `REAL (Mapa Horas): ${(tempoDisponivelReal/60).toFixed(1)}h` : 
                    `APROXIMADO (Ops): ${(tempoTotalOps/60).toFixed(1)}h`);
                
                // Performance: usar os rácios calculados nas análises (se disponíveis)
                // Por agora, usar um valor conservador baseado no rácio médio
                // Performance real será calculada depois da análise de operações
                
                // Eficiência por tipologia
                const eficienciaPorTipologia = {};
                const tempoPorTipologia = {};
                opsFiltradas.forEach(r => {
                    if(!tempoPorTipologia[r.tipologia]) tempoPorTipologia[r.tipologia] = {real:0, objetivo:0, count:0};
                    tempoPorTipologia[r.tipologia].real += r.duracao;
                    if(objetivos[r.operacao]) tempoPorTipologia[r.tipologia].objetivo += objetivos[r.operacao];
                    tempoPorTipologia[r.tipologia].count++;
                });
                Object.keys(tempoPorTipologia).forEach(t => {
                    const d = tempoPorTipologia[t];
                    eficienciaPorTipologia[t] = { tempoReal:d.real, tempoObjetivo:d.objetivo, eficiencia: d.real > 0 && d.objetivo > 0 ? (d.objetivo / d.real) * 100 : 0, numOps:d.count };
                });
                
                const tempoPerturbacoes = pertFiltradas.reduce((s,r) => s+r.duracao,0);
                const numPerturbacoes = pertFiltradas.length;
                
                const perturbacoesPorTipo = {};
                pertFiltradas.forEach(r => {
                    if(!perturbacoesPorTipo[r.tipo]) perturbacoesPorTipo[r.tipo] = {tempo:0,count:0};
                    perturbacoesPorTipo[r.tipo].tempo += r.duracao;
                    perturbacoesPorTipo[r.tipo].count++;
                });
                
                // DISPONIBILIDADE:
                // Com Mapa Horas: (Tempo Disponível Real - Perturbações) / Tempo Disponível Real
                // Sem Mapa Horas: (Tempo Operações - Perturbações) / Tempo Operações (aproximação)
                const tempoBase = usaMapaHoras ? tempoDisponivelReal : tempoTotalOps;
                const tempoDisponivel = tempoBase > 0 ? tempoBase - tempoPerturbacoes : 0;
                const disponibilidade = tempoBase > 0 ? (tempoDisponivel / tempoBase) * 100 : 0;
                
                // Performance será calculada mais tarde baseada nos rácios reais
                let performance = 0;
                const qualidade = 100;
                let oee = 0;
                
                // Meses únicos das encomendas e operações
                const mesesEnc = Object.keys(porMes).filter(m => m && m !== 'Sem Data');
                const mesesOps = [...new Set(opsFiltradas.map(r => r.mesAno))].filter(m => m);
                const mesesUnicos = [...new Set([...mesesEnc, ...mesesOps])].sort((a,b) => {
                    const [ma,ya] = a.split('/').map(Number);
                    const [mb,yb] = b.split('/').map(Number);
                    return ya !== yb ? ya - yb : ma - mb;
                });
                
                // OEE por mês
                const oeePorMes = {};
                mesesUnicos.forEach(mes => {
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    const pertMes = pertFiltradas.filter(r => r.mesAno === mes);
                    const tempoOpsMes = opsMes.reduce((s,r) => s + r.duracao, 0);
                    const tempoPertMes = pertMes.reduce((s,r) => s + r.duracao, 0);
                    
                    // Usar tempo do Mapa de Horas se disponível, senão usar tempo de operações
                    const tempoBaseMes = mapaHoras[mes] || tempoOpsMes;
                    const tempoDispMes = tempoBaseMes - tempoPertMes;
                    const dispMes = tempoBaseMes > 0 ? (tempoDispMes / tempoBaseMes) * 100 : 0;
                    const perfMes = 0; // Será actualizado depois
                    const oeeMes = 0; // Será actualizado depois
                    oeePorMes[mes] = { 
                        tempoOperacoes: tempoOpsMes, 
                        tempoPerturbacoes: tempoPertMes, 
                        tempoDisponivel: tempoBaseMes,
                        usaMapaHoras: !!(mapaHoras[mes]),
                        disponibilidade: dispMes, 
                        performance: perfMes, 
                        oee: oeeMes 
                    };
                });
                
                // Evolução mensal (encomendas + operações)
                const evolucaoMensal = mesesUnicos.map(mes => {
                    const encMes = porMes[mes] || { quantidade: 0, valor: 0, valorFaturado: 0, total: 0 };
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    const pertMes = pertFiltradas.filter(r => r.mesAno === mes);
                    const tempoOpsMes = opsMes.reduce((s,r) => s + r.duracao, 0);
                    const tempoMapaHorasMes = mapaHoras[mes] || 0;
                    const horasDisponiveisMes = tempoMapaHorasMes > 0 ? tempoMapaHorasMes / 60 : tempoOpsMes / 60;
                    return { 
                        mes, 
                        encomendas: encMes.total,
                        quantidade: encMes.quantidade,
                        valor: encMes.valor,
                        valorFaturado: encMes.valorFaturado,
                        tempoOperacoes: tempoOpsMes,
                        horasOperacoes: tempoOpsMes / 60,
                        horasDisponiveis: horasDisponiveisMes,
                        usaMapaHoras: tempoMapaHorasMes > 0,
                        entregues: encMes.total,
                        perturbacoes: pertMes.reduce((s,r) => s + r.duracao, 0)
                    };
                });
                
                // Tipologias únicas (apenas tipologias reais, não ligações/caixas)
                const tipologias = [...new Set([
                    ...encomendas.map(e => e.tipologia),
                    ...registosOperacoes.map(r => r.tipologia)
                ])].filter(t => t).sort();
                
                // Calcular quantidade produzida por tipologia das encomendas FILTRADAS
                const qtdPorTipologia = {};
                encFiltradas.forEach(e => {
                    const tip = e.tipologia || 'Sem Tipologia';
                    if(!qtdPorTipologia[tip]) qtdPorTipologia[tip] = 0;
                    qtdPorTipologia[tip] += e.qtdEntregue || e.quantidade || 0;
                });
                
                // Calcular quantidade por Caixa/Artigo de TODAS as encomendas (filtradas por ano/mês, mas NÃO por tipologia)
                // Isto permite que E1-Embalagem (tipologia Frac) seja encontrada quando filtramos por tipologia E1
                const encFiltradasSemTipologia = encomendas.filter(e => {
                    const mesAno = e.mesAnoEmbalamento || e.mesAnoEntrega || e.mesAnoProducao;
                    const ano = mesAno ? mesAno.split('/')[1] : '';
                    if(filtroAno && ano !== filtroAno) return false;
                    if(filtroMes && mesAno !== filtroMes) return false;
                    return true;
                });
                
                // Também filtrar encomendas em produção (pendentes) pelo mesmo critério
                // Só incluir as que têm data de produção preenchida (já produzidas, em stock)
                const encProducaoFiltradas = encomendasProducao.filter(e => {
                    // Só contar se tem data de produção (já foi produzida)
                    if(!e.mesAnoProducao || e.mesAnoProducao === '') return false;
                    
                    const mesAno = e.mesAnoProducao;
                    const ano = mesAno ? mesAno.split('/')[1] : '';
                    if(filtroAno && ano !== filtroAno) return false;
                    if(filtroMes && mesAno !== filtroMes) return false;
                    return true;
                });
                
                // Juntar terminadas + produção para cálculo de quantidades do OEE
                const todasEncParaOEE = [...encFiltradasSemTipologia, ...encProducaoFiltradas];
                console.log('📦 Encomendas para OEE:', { terminadas: encFiltradasSemTipologia.length, producao: encProducaoFiltradas.length, total: todasEncParaOEE.length });
                
                const qtdPorCaixaArtigo = {};
                const qtdPorCaixaNormalizada = {}; // Com espaços normalizados
                todasEncParaOEE.forEach(e => {
                    const caixa = e.caixa || '';
                    if(caixa) {
                        if(!qtdPorCaixaArtigo[caixa]) qtdPorCaixaArtigo[caixa] = 0;
                        // Usar quantidade PRODUZIDA (não entregue) para OEE
                        qtdPorCaixaArtigo[caixa] += e.quantidade || e.qtdProduzida || e.qtdEntregue || 0;
                        
                        // Também guardar versão normalizada (sem espaços extras)
                        const caixaNorm = caixa.replace(/\s+/g, ' ').trim();
                        if(!qtdPorCaixaNormalizada[caixaNorm]) qtdPorCaixaNormalizada[caixaNorm] = 0;
                        qtdPorCaixaNormalizada[caixaNorm] += e.quantidade || e.qtdProduzida || e.qtdEntregue || 0;
                    }
                });
                
                // Performance por Caixa/Artigo (baseado nas operações e objetivos por tipologia/caixa)
                const performancePorCaixa = {};
                // Agrupar operações por caixa/artigo
                const opsPorCaixa = {};
                opsFiltradas.forEach(r => {
                    const caixa = r.caixa || r.artigo || 'Sem Caixa';
                    if(!opsPorCaixa[caixa]) opsPorCaixa[caixa] = { tempoReal: 0, count: 0 };
                    opsPorCaixa[caixa].tempoReal += r.duracao;
                    opsPorCaixa[caixa].count++;
                });
                
                // Função para normalizar nomes (remover espaços extras, converter * para x)
                const normalizarNome = (nome) => {
                    return nome.replace(/\s+/g, ' ').replace(/\*/g, 'x').trim().toLowerCase();
                };
                
                // Criar mapa de objetivos normalizados
                const objetivosNorm = {};
                Object.entries(objetivosTipologia).forEach(([nome, tempo]) => {
                    objetivosNorm[normalizarNome(nome)] = tempo;
                    objetivosNorm[nome] = tempo;
                    objetivosNorm[nome.toLowerCase()] = tempo;
                    // Também sem espaços
                    objetivosNorm[nome.replace(/\s+/g, '').toLowerCase()] = tempo;
                });
                
                // Mapeamentos manuais para nomes que não correspondem
                const mapeamentoNomes = {
                    'transporte': 'transportes',
                    'cxs sobras tipo jaula 1600': 'cxs sobras tipo jaula 1600x1200x800',
                };
                
                // Calcular performance para cada caixa
                Object.entries(opsPorCaixa).forEach(([caixa, dados]) => {
                    // Tentar encontrar objetivo para esta caixa
                    const caixaNorm = normalizarNome(caixa);
                    const caixaSemEspacos = caixa.replace(/\s+/g, '').toLowerCase();
                    
                    // Primeiro tentar nome direto, depois normalizado, depois sem espaços, depois mapeamento
                    let tempoObj = objetivosTipologia[caixa] || 
                                   objetivosNorm[caixaNorm] || 
                                   objetivosNorm[caixaSemEspacos] ||
                                   objetivosNorm[caixa.replace(/\s+/g, ' ').trim()] ||
                                   (mapeamentoNomes[caixaNorm] ? objetivosNorm[mapeamentoNomes[caixaNorm]] : 0) ||
                                   0;
                    
                    // Obter quantidade produzida desta caixa (com normalização melhorada)
                    const caixaTrim = caixa.replace(/\s+/g, ' ').trim();
                    let qtdProduzida = qtdPorCaixaArtigo[caixa] || 
                                       qtdPorCaixaArtigo[caixaTrim] || 
                                       qtdPorCaixaNormalizada[caixaTrim] || 0;
                    
                    // Se não encontrou, tentar procurar com normalização mais agressiva
                    if(qtdProduzida === 0) {
                        const caixaLower = caixaNorm;
                        Object.entries(qtdPorCaixaArtigo).forEach(([enc, qtd]) => {
                            // Normalizar: remover espaços extras, lowercase
                            const encNorm = enc.replace(/\s+/g, ' ').trim().toLowerCase();
                            // Também comparar sem NENHUM espaço (mais agressivo)
                            const encSemEspacos = enc.replace(/\s+/g, '').toLowerCase();
                            const caixaSemEspacos = caixa.replace(/\s+/g, '').toLowerCase();
                            
                            if((encNorm === caixaLower || encSemEspacos === caixaSemEspacos) && qtd > 0) {
                                qtdProduzida = qtd;
                            }
                        });
                    }
                    
                    // Debug: mostrar caixas sem quantidade
                    if(qtdProduzida === 0 && dados.tempoReal > 60) {
                        console.log('⚠️ Sem quantidade:', caixa, '| Normalizado:', caixaNorm, '| SemEspaços:', caixa.replace(/\s+/g, '').toLowerCase());
                    }
                    
                    // Caso especial: Transporte usa o NÚMERO DE ENCOMENDAS TERMINADAS (entregas feitas)
                    if(caixaNorm === 'transporte' || caixaNorm === 'transportes') {
                        // Usar apenas encomendas terminadas (não pendentes)
                        qtdProduzida = encFiltradasSemTipologia.length;
                        console.log('🚛 Transporte:', qtdProduzida, 'entregas');
                    }
                    
                    const tempoObjetivoTotal = tempoObj > 0 && qtdProduzida > 0 ? tempoObj * qtdProduzida : 0;
                    
                    performancePorCaixa[caixa] = {
                        tempoReal: dados.tempoReal,
                        tempoObjetivo: tempoObjetivoTotal,
                        tempoObjUnitario: tempoObj,
                        quantidade: qtdProduzida,
                        performance: dados.tempoReal > 0 && tempoObjetivoTotal > 0 ? (tempoObjetivoTotal / dados.tempoReal) * 100 : 0,
                        numOps: dados.count
                    };
                });
                
                // Mapeamento de tipologias (Registos Produção → Encomendas)
                const mapTipologia = {
                    'E2-Frac': 'Frac',
                    'E1': 'Frac',
                    'Maquinacao': 'Frac',
                    'Transporte': 'Transporte'
                };
                
                // Função para obter quantidade - primeiro por artigos da operação, depois por tipologia
                const getQtdPorOperacao = (tipologia, artigos, operacao) => {
                    // Caso especial: Transporte usa TODAS as caixas entregues
                    if(operacao && operacao.toLowerCase().includes('transporte')) {
                        let totalEntregue = 0;
                        Object.values(qtdPorTipologia).forEach(q => totalEntregue += q);
                        return totalEntregue;
                    }
                    
                    // Se temos artigos específicos, somar quantidade desses artigos
                    if(artigos && artigos.length > 0) {
                        let qtd = 0;
                        artigos.forEach(art => {
                            // Tentar nome exato
                            if(qtdPorCaixaArtigo[art]) {
                                qtd += qtdPorCaixaArtigo[art];
                            } else {
                                // Tentar versão normalizada (sem espaços extras)
                                const artNorm = art.replace(/\s+/g, ' ').trim();
                                if(qtdPorCaixaNormalizada[artNorm]) {
                                    qtd += qtdPorCaixaNormalizada[artNorm];
                                }
                            }
                        });
                        // Se temos artigos específicos, retornar a quantidade encontrada (mesmo que seja 0)
                        // NÃO usar fallback de tipologia para operações com artigos específicos
                        return qtd;
                    }
                    
                    // Só usar tipologia como fallback se NÃO temos artigos específicos
                    // (ex: operações genéricas sem artigo definido)
                    if(qtdPorTipologia[tipologia]) return qtdPorTipologia[tipologia];
                    // Tentar mapeamento
                    const tipMapped = mapTipologia[tipologia];
                    if(tipMapped && qtdPorTipologia[tipMapped]) return qtdPorTipologia[tipMapped];
                    return 0;
                };
                
                // Debug
                console.log('📊 Qtd por Tipologia (filtrado):', qtdPorTipologia);
                console.log('📊 Qtd por Caixa/Artigo:', qtdPorCaixaArtigo);
                console.log('📊 Encomendas filtradas:', encFiltradas.length);
                
                // Análise por Unidade/Tipologia/Operação
                const analiseOperacoes = {};
                opsFiltradas.forEach(r => {
                    const key = `${r.unidadeProducao}|${r.tipologia}|${r.operacao}`;
                    // Buscar objetivo - tentar nome original e normalizado
                    const opNorm = normalizarOperacao(r.operacao);
                    const tempoObj = objetivos[r.operacao] || objetivos[opNorm] || objetivosTipologia[r.tipologia] || 0;
                    if(!analiseOperacoes[key]) {
                        analiseOperacoes[key] = {
                            unidadeProducao: r.unidadeProducao || 'Sem Unidade',
                            caixa: r.artigo || 'Sem Caixa',
                            tipologia: r.tipologia || 'Sem Tipologia',
                            operacao: r.operacao || 'Sem Operação',
                            tempoTotal: 0,
                            tempoObjetivo: tempoObj,
                            numRegistos: 0,
                            artigos: new Set() // Recolher artigos únicos
                        };
                    }
                    analiseOperacoes[key].tempoTotal += r.duracao || 0;
                    analiseOperacoes[key].numRegistos++;
                    if(r.artigo) {
                        analiseOperacoes[key].artigos.add(r.artigo);
                        // Atualizar caixa com o último artigo (ou juntar vários)
                        analiseOperacoes[key].caixa = r.artigo;
                    }
                });
                
                // Calcular métricas derivadas
                const analiseArray = Object.values(analiseOperacoes).map(a => {
                    // Buscar quantidade produzida - primeiro por artigos, depois por tipologia
                    const artigos = Array.from(a.artigos || []);
                    // Se há vários artigos, juntar os nomes
                    const caixaDisplay = artigos.length > 1 ? artigos.join(', ') : (artigos[0] || a.caixa);
                    const qtdProduzida = getQtdPorOperacao(a.tipologia, artigos, a.operacao);
                    const tempoMedioPorCaixa = qtdProduzida > 0 ? a.tempoTotal / qtdProduzida : 0;
                    const tempoObjetivoH = a.tempoObjetivo / 60; // converter para horas
                    const tempoMedioH = tempoMedioPorCaixa / 60;
                    const racio = tempoMedioPorCaixa > 0 && a.tempoObjetivo > 0 ? (a.tempoObjetivo / tempoMedioPorCaixa) * 100 : 0;
                    return {
                        ...a,
                        caixaDisplay,
                        qtdProduzida,
                        tempoTotalH: a.tempoTotal / 60,
                        tempoObjetivoH,
                        tempoMedioPorCaixa,
                        tempoMedioH,
                        racio
                    };
                }).sort((a,b) => {
                    // Ordenar por rácio do mais alto para o mais baixo
                    // Sem rácio (0) vai para o fim
                    if(a.racio > 0 && b.racio === 0) return -1;
                    if(a.racio === 0 && b.racio > 0) return 1;
                    return b.racio - a.racio;
                });
                
                // Calcular OEE com fórmula correcta:
                // Disponibilidade = (Tempo Disponível - Perturbações) / Tempo Disponível
                // Performance = Tempo Objetivo Total Peças / (Tempo Disponível - Perturbações)
                // Qualidade = 100% (fixo)
                // OEE = Disponibilidade × Performance × Qualidade
                
                // Somar total de peças produzidas e tempo objetivo
                let totalPecasProduzidas = 0;
                let tempoObjetivoTotalPecas = 0;
                
                Object.entries(performancePorCaixa).forEach(([caixa, dados]) => {
                    if(dados.quantidade > 0) {
                        totalPecasProduzidas += dados.quantidade;
                        tempoObjetivoTotalPecas += dados.tempoObjetivo; // já é quantidade × tempo unitário
                    }
                });
                
                // Tempo disponível para Performance:
                // = Tempo Disponível Real (Mapa Horas) - Perturbações
                // OU = Tempo Operações - Perturbações (se sem Mapa Horas)
                const tempoParagens = tempoPerturbacoes;
                const tempoUtilParaPerformance = tempoDisponivel; // já é tempoBase - perturbações
                
                // PERFORMANCE = Tempo Objetivo Total / Tempo Útil (Disponível - Perturbações)
                if(tempoUtilParaPerformance > 0 && tempoObjetivoTotalPecas > 0) {
                    performance = (tempoObjetivoTotalPecas / tempoUtilParaPerformance) * 100;
                } else {
                    performance = 0;
                }
                
                // Eficiência geral (para compatibilidade)
                const eficienciaGeral = performance;
                
                // EFICIÊNCIA PRODUTIVA (nova fórmula):
                // = Nº Peças Produzidas / (Cadência Teórica × (Tempo Disponível - Paragens Não Planeadas))
                // Como temos múltiplas caixas com cadências diferentes:
                // = Σ Peças Produzidas / Σ Peças Esperadas
                // Onde Peças Esperadas por caixa = Cadência da caixa × Tempo Útil proporcional
                // Cadência = 1 / Tempo Objetivo Unitário (peças/min)
                // Tempo Útil proporcional = proporção do tempo real da caixa aplicada ao tempo útil total
                
                let eficienciaProdutiva = 0;
                const tempoUtilTotal = tempoDisponivel; // tempoBase - perturbações
                const tempoRealTotal = Object.values(performancePorCaixa).reduce((s,d) => s + d.tempoReal, 0);
                
                if(tempoUtilTotal > 0 && tempoRealTotal > 0 && totalPecasProduzidas > 0) {
                    let pecasEsperadas = 0;
                    Object.entries(performancePorCaixa).forEach(([caixa, dados]) => {
                        if(dados.tempoObjUnitario > 0 && dados.tempoReal > 0) {
                            // Proporção do tempo desta caixa no total
                            const proporcaoTempo = dados.tempoReal / tempoRealTotal;
                            // Tempo útil atribuído a esta caixa
                            const tempoUtilCaixa = tempoUtilTotal * proporcaoTempo;
                            // Cadência teórica = 1 peça / tempoObjUnitario minutos
                            const cadenciaTeor = 1 / dados.tempoObjUnitario;
                            // Peças esperadas neste tempo útil
                            pecasEsperadas += cadenciaTeor * tempoUtilCaixa;
                        }
                    });
                    
                    if(pecasEsperadas > 0) {
                        eficienciaProdutiva = (totalPecasProduzidas / pecasEsperadas) * 100;
                    }
                    
                    console.log('📊 Eficiência Produtiva:', {
                        totalPecasProduzidas,
                        pecasEsperadas: pecasEsperadas.toFixed(0),
                        tempoUtilTotal: (tempoUtilTotal/60).toFixed(1) + 'h',
                        eficienciaProdutiva: eficienciaProdutiva.toFixed(1) + '%'
                    });
                }
                
                // OEE = Disponibilidade × Performance × Qualidade
                oee = disponibilidade > 0 && performance > 0 ? (disponibilidade/100)*(performance/100)*(qualidade/100)*100 : 0;
                
                // Debug
                console.log('📊 OEE calc:', { 
                    totalPecasProduzidas, 
                    tempoObjetivoTotalPecas: (tempoObjetivoTotalPecas/60).toFixed(1) + 'h',
                    tempoBase: (tempoBase/60).toFixed(1) + 'h (' + (usaMapaHoras ? 'Mapa Horas' : 'Aproximação Ops') + ')',
                    tempoParagens: (tempoParagens/60).toFixed(1) + 'h',
                    tempoUtilParaPerformance: (tempoUtilParaPerformance/60).toFixed(1) + 'h',
                    disponibilidade: disponibilidade.toFixed(1) + '%',
                    performance: performance.toFixed(1) + '%',
                    qualidade: qualidade + '%',
                    oee: oee.toFixed(1) + '%'
                });
                console.log('📊 performancePorCaixa:', performancePorCaixa);
                
                // Atualizar OEE por mês com performance calculada individualmente por mês
                Object.keys(oeePorMes).forEach(mes => {
                    const tempoBaseMes = oeePorMes[mes].tempoDisponivel;
                    const tempoPertMes = oeePorMes[mes].tempoPerturbacoes;
                    const tempoUtilMes = tempoBaseMes - tempoPertMes;
                    
                    // Calcular tempo objetivo para as operações DESTE mês
                    let tempoObjMes = 0;
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    // Agrupar operações do mês por caixa
                    const opsPorCaixaMes = {};
                    opsMes.forEach(r => {
                        const caixa = r.caixa || r.artigo || 'Sem Caixa';
                        if(!opsPorCaixaMes[caixa]) opsPorCaixaMes[caixa] = 0;
                        opsPorCaixaMes[caixa] += r.duracao;
                    });
                    // Usar a performance global por caixa como proxy
                    Object.entries(opsPorCaixaMes).forEach(([caixa, tempoReal]) => {
                        const dados = performancePorCaixa[caixa];
                        if(dados && dados.tempoReal > 0 && dados.tempoObjetivo > 0) {
                            // Proporção do tempo objetivo para este mês
                            const proporcao = tempoReal / dados.tempoReal;
                            tempoObjMes += dados.tempoObjetivo * proporcao;
                        }
                    });
                    
                    const perfMes = tempoUtilMes > 0 && tempoObjMes > 0 ? (tempoObjMes / tempoUtilMes) * 100 : performance;
                    oeePorMes[mes].performance = perfMes;
                    oeePorMes[mes].oee = oeePorMes[mes].disponibilidade > 0 && perfMes > 0 ? 
                        (oeePorMes[mes].disponibilidade/100) * (perfMes/100) * 100 : 0;
                });
                
                // Anos únicos disponíveis (de todas as encomendas e operações, não filtradas)
                const getAnoFromMesAno = (mesAno) => {
                    if(!mesAno) return '';
                    const parts = mesAno.split('/');
                    return parts.length === 2 ? parts[1] : '';
                };
                const anosEnc = encomendas.map(e => getAnoFromMesAno(e.mesAnoEmbalamento) || getAnoFromMesAno(e.mesAnoEntrega) || getAnoFromMesAno(e.mesAnoProducao));
                const anosOps = registosOperacoes.map(r => getAnoFromMesAno(r.mesAno));
                const anosUnicos = [...new Set([...anosEnc, ...anosOps])].filter(a => a && a >= '2026').sort().reverse();
                
                return { 
                    totalEncomendas, encFaturadas: encFaturadas.length, encNaoFaturadas: encNaoFaturadas.length,
                    taxaFaturacao, valorTotal, valorFaturado, valorPorFaturar, valorPorLocalizacao,
                    totalFaturadasAnual, valorFaturadoAnual, totalEncAnual,
                    totalProduzido, totalEntregue, totalEmbalado, totalEncEntregues, totalEncEmStock, totalEncFatNaoTerm, unidadesEmStock,
                    porTipologia, porCaixa, porMes,
                    tempoTotalOps, numOperacoes, eficienciaGeral, eficienciaPorTipologia, performancePorCaixa,
                    tempoPerturbacoes, numPerturbacoes, perturbacoesPorTipo,
                    disponibilidade, performance, qualidade, oee, oeePorMes, eficienciaProdutiva,
                    evolucaoMensal, mesesUnicos, tipologias, analiseArray, anosUnicos
                };
            }, [encomendas, encomendasProducao, registosProducao, registosOperacoes, registosPerturbacoes, objetivos, objetivosTipologia, mapCaixaEcode, mapaHoras, filtroAno, filtroMes, filtroTipologia]);
            
            useEffect(() => {
                if(kpis.evolucaoMensal.length===0) return;
                const ctx = document.getElementById('chartEvolucao');
                if(!ctx) return;
                if(chartRefs.current.evolucao) chartRefs.current.evolucao.destroy();
                chartRefs.current.evolucao = new Chart(ctx, {
                    type:'bar',
                    data:{ labels:kpis.evolucaoMensal.map(d=>d.mes), datasets:[
                        { label:'Valor Faturado (€)', data:kpis.evolucaoMensal.map(d=>d.valorFaturado), backgroundColor:'rgba(16,185,129,0.7)', borderColor:'#10b981', borderWidth:1, yAxisID:'y' },
                        { type:'line', label:'Encomendas', data:kpis.evolucaoMensal.map(d=>d.encomendas), borderColor:'#f59e0b', backgroundColor:'transparent', borderWidth:2, tension:0.4, yAxisID:'y1' }
                    ]},
                    options:{ responsive:true, maintainAspectRatio:false, interaction:{mode:'index',intersect:false}, plugins:{legend:{labels:{color:'#94a3b8'}}}, scales:{ x:{ticks:{color:'#64748b'},grid:{color:'rgba(148,163,184,0.1)'}}, y:{type:'linear',position:'left',ticks:{color:'#3b82f6',callback:v=>formatCurrency(v)},grid:{color:'rgba(148,163,184,0.1)'}}, y1:{type:'linear',position:'right',ticks:{color:'#f59e0b'},grid:{drawOnChartArea:false}} } }
                });
            }, [kpis.evolucaoMensal]);
            
            // Gráfico de Produtividade (€ faturados / hora trabalhada)
            useEffect(() => {
                if(kpis.evolucaoMensal.length === 0 || activeTab !== 'produtividade') return;
                const ctx = document.getElementById('chartProdutividade');
                if(!ctx) return;
                if(chartRefs.current.produtividade) chartRefs.current.produtividade.destroy();
                
                // Calcular produtividade por mês: valor faturado / horas disponíveis (Mapa de Horas quando disponível)
                const prodFaturadoData = kpis.evolucaoMensal.map(d => {
                    const horas = d.horasDisponiveis || 0;
                    return horas > 0 ? (d.valorFaturado || 0) / horas : 0;
                });
                
                chartRefs.current.produtividade = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: kpis.evolucaoMensal.map(d => d.mes),
                        datasets: [{
                            label: '€ Faturado/hora',
                            data: prodFaturadoData,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16,185,129,0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 6,
                            pointBackgroundColor: '#10b981'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#94a3b8' } },
                            tooltip: { callbacks: { label: (ctx) => ctx.parsed.y.toFixed(2) + ' €/h' } }
                        },
                        scales: {
                            x: { ticks: { color: '#64748b' }, grid: { color: 'rgba(148,163,184,0.1)' } },
                            y: { ticks: { color: '#3b82f6', callback: v => v.toFixed(0) + ' €' }, grid: { color: 'rgba(148,163,184,0.1)' } }
                        }
                    }
                });
            }, [kpis.evolucaoMensal, activeTab]);
            
            // Gráfico de Perturbações Top 5
            useEffect(() => {
                if(Object.keys(kpis.perturbacoesPorTipo || {}).length === 0 || activeTab !== 'perturbacoes') return;
                const ctx = document.getElementById('chartPerturbacoes');
                if(!ctx) return;
                if(chartRefs.current.perturbacoes) chartRefs.current.perturbacoes.destroy();
                
                // Top 5 perturbações por tempo
                const top5 = Object.entries(kpis.perturbacoesPorTipo)
                    .sort((a, b) => b[1].tempo - a[1].tempo)
                    .slice(0, 5);
                
                const cores = ['#f59e0b', '#ef4444', '#8b5cf6', '#10b981', '#3b82f6'];
                
                chartRefs.current.perturbacoes = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: top5.map(([tipo]) => tipo.length > 30 ? tipo.substring(0, 30) + '...' : tipo),
                        datasets: [{
                            label: 'Tempo (horas)',
                            data: top5.map(([, d]) => d.tempo / 60),
                            backgroundColor: cores,
                            borderColor: cores,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            legend: { display: false },
                            tooltip: { callbacks: { label: (ctx) => ctx.parsed.x.toFixed(1) + 'h' } }
                        },
                        scales: {
                            x: { ticks: { color: '#64748b', callback: v => v + 'h' }, grid: { color: 'rgba(148,163,184,0.1)' } },
                            y: { ticks: { color: '#94a3b8' }, grid: { display: false } }
                        }
                    }
                });
            }, [kpis.perturbacoesPorTipo, activeTab]);
            
            const exportarPDF = async () => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('l','mm','a4');
                doc.setFontSize(20); doc.setFont('helvetica','bold'); doc.text('Relatório de KPIs',14,20);
                doc.setFontSize(10); doc.setFont('helvetica','normal'); doc.text('Gerado em: '+new Date().toLocaleDateString('pt-PT'),14,28);
                if(filtroMes) doc.text('Período: '+filtroMes,14,34);
                if(filtroTipologia) doc.text('Tipologia: '+filtroTipologia,100,34);
                
                doc.autoTable({ startY:45, head:[['Indicador','Valor','Meta']], body:[
                    ['Taxa de Conclusão',kpis.taxaConclusao.toFixed(1)+'%','90%'],
                    ['Taxa de Faturação',kpis.taxaFaturacao.toFixed(1)+'%','100%'],
                    ['OEE',kpis.oee.toFixed(1)+'%','85%'],
                    ['Eficiência Geral',kpis.eficienciaGeral.toFixed(1)+'%','100%'],
                    ['Eficiência Produtiva',kpis.eficienciaProdutiva.toFixed(1)+'%','100%'],
                    ['Lead Time Médio',kpis.leadTimeMedia.toFixed(1)+' dias','< 7 dias'],
                    ['Taxa de Atraso',kpis.taxaAtraso.toFixed(1)+'%','< 5%']
                ], styles:{fontSize:9}, headStyles:{fillColor:[59,130,246]} });
                
                const y = doc.lastAutoTable.finalY + 15;
                doc.autoTable({ startY:y, head:[['Descrição','Valor']], body:[
                    ['Valor Faturado',formatCurrency(kpis.valorFaturado)],
                    ['Valor Pendente',formatCurrency(kpis.valorPendente)]
                ], styles:{fontSize:9}, headStyles:{fillColor:[16,185,129]} });
                
                doc.save('Relatorio_KPIs_'+new Date().toLocaleDateString('pt-PT').replace(/\//g,'-')+'.pdf');
                showMsg('✅ PDF exportado!','success');
            };
            
            const temDados = encomendas.length>0 || registosProducao.length>0 || registosOperacoes.length>0;
            
            return e('div',{className:'app'},
                e('header',{className:'header'},
                    e('div',{className:'header-left'},
                        e('div',{className:'logo'},'📊'),
                        e('div',null, 
                            e('h1',null,'Sistema de KPIs'), 
                            e('p',null, lastUpdate ? 'Última atualização: ' + lastUpdate.toLocaleString('pt-PT') : 'Indicadores de Produção e Encomendas')
                        )
                    ),
                    e('div',{style:{display:'flex',gap:'12px',alignItems:'center'}},
                        e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading||!urlPowerAutomate,style:{background:isLoading?'#64748b':!urlPowerAutomate?'#475569':''}},
                            isLoading ? '⏳ A carregar...' : '🔄 Atualizar'
                        ),
                        e('button',{className:'btn btn-secondary',onClick:()=>setActiveTab('importar')},'📥 Importar'),
                        e('button',{className:'btn btn-secondary',onClick:()=>setShowConfig(!showConfig)},'⚙️'),
                        temDados && e('button',{className:'btn btn-secondary',onClick:exportarPDF},'📄 PDF')
                    )
                ),
                
                // Modal de Configuração
                showConfig && e('div',{className:'section',style:{marginBottom:'24px',background:'linear-gradient(135deg, var(--bg-secondary), var(--bg-card))'}},
                    e('div',{className:'section-header'},
                        e('h3',{className:'section-title'},'⚙️ Configuração Power Automate'),
                        e('button',{className:'btn btn-secondary',onClick:()=>setShowConfig(false),style:{padding:'6px 12px'}},'✕')
                    ),
                    e('div',{style:{display:'grid',gap:'16px'}},
                        e('div',null,
                            e('label',{style:{display:'block',marginBottom:'6px',fontSize:'13px',color:'var(--text-secondary)'}},'🔗 URL do Fluxo Power Automate:'),
                            e('input',{type:'text',value:urlPowerAutomate,onChange:ev=>setUrlPowerAutomate(ev.target.value),placeholder:'https://prod-XX.westeurope.logic.azure.com/...',style:{width:'100%',padding:'10px 14px',borderRadius:'var(--radius-sm)',background:'var(--bg-primary)',border:'1px solid var(--border-color)',color:'var(--text-primary)',fontSize:'13px'}})
                        ),
                        urlPowerAutomate && e('div',{style:{display:'flex',gap:'12px'}},
                            e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading},
                                isLoading ? '⏳ A testar...' : '🧪 Testar Ligação'
                            )
                        ),
                        e('div',{style:{padding:'12px',background:'var(--accent-blue-soft)',borderRadius:'var(--radius-sm)',fontSize:'12px',color:'var(--text-secondary)'}},
                            e('strong',{style:{color:'var(--accent-blue)'}},'ℹ️ Como configurar: '),
                            e('ol',{style:{margin:'8px 0 0 16px'}},
                                e('li',null,'Cria um fluxo no Power Automate com trigger HTTP'),
                                e('li',null,'Adiciona ações para ler os ficheiros Excel'),
                                e('li',null,'Retorna JSON com: producao, perturbacoes, encomendas, objetivosOperacao, objetivosTipologia, mapaHoras'),
                                e('li',null,'Cola o URL HTTP POST aqui')
                            )
                        ),
                        e('div',{style:{padding:'12px',background:'var(--accent-green-soft)',borderRadius:'var(--radius-sm)',fontSize:'12px'}},
                            e('strong',{style:{color:'var(--accent-green)'}},'📱 Instalar como App: '),
                            'No browser, clica no menu (⋮) e seleciona "Instalar aplicação" ou "Adicionar ao ecrã inicial"'
                        )
                    )
                ),
                
                e('div',{className:'tabs'},
                    e('button',{className:`tab ${activeTab==='dashboard'?'active':''}`,onClick:()=>setActiveTab('dashboard')},'📊 Dashboard'),
                    e('button',{className:`tab ${activeTab==='operacoes'?'active':''}`,onClick:()=>setActiveTab('operacoes')},'🔧 Operações'),
                    e('button',{className:`tab ${activeTab==='perturbacoes'?'active':''}`,onClick:()=>setActiveTab('perturbacoes')},'⚠️ Perturbações'),
                    e('button',{className:`tab ${activeTab==='produtividade'?'active':''}`,onClick:()=>setActiveTab('produtividade')},'📈 Produtividade'),
                    e('button',{className:`tab ${activeTab==='oee'?'active':''}`,onClick:()=>setActiveTab('oee')},'⚙️ OEE'),
                    e('button',{className:`tab ${activeTab==='detalhes'?'active':''}`,onClick:()=>setActiveTab('detalhes')},'📋 Detalhes')
                ),
                
                temDados && activeTab!=='importar' && e('div',{className:'filter-bar'},
                    e('select',{className:'filter-select',value:filtroAno,onChange:ev=>setFiltroAno(ev.target.value)},
                        e('option',{value:''},'📆 Todos os anos'),
                        (kpis.anosUnicos || ['2026']).map(a=>e('option',{key:a,value:a},a))
                    ),
                    e('select',{className:'filter-select',value:filtroMes,onChange:ev=>setFiltroMes(ev.target.value)},
                        e('option',{value:''},'📅 Todos os meses'),
                        kpis.mesesUnicos.map(m=>e('option',{key:m,value:m},m))
                    ),
                    e('select',{className:'filter-select',value:filtroTipologia,onChange:ev=>setFiltroTipologia(ev.target.value)},
                        e('option',{value:''},'🏷️ Todas tipologias'),
                        kpis.tipologias.map(t=>e('option',{key:t,value:t},t))
                    ),
                    (filtroAno||filtroMes||filtroTipologia) && e('button',{className:'btn btn-secondary',onClick:()=>{setFiltroAno('2026');setFiltroMes('');setFiltroTipologia('');}},'✕ Limpar')
                ),
                
                activeTab==='importar' && e('div',null,
                    // Power Automate
                    e('div',{className:'section',style:{marginBottom:'24px'}},
                        e('div',{className:'section-header'},
                            e('h3',{className:'section-title'},'🔄 Carregar via Power Automate'),
                            e('div',{style:{display:'flex',gap:'8px'}},
                                e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading||!urlPowerAutomate},
                                    isLoading ? '⏳ A carregar...' : '🔄 Carregar Todos os Dados'
                                )
                            )
                        ),
                        e('div',{style:{display:'grid',gridTemplateColumns:'repeat(4, 1fr)',gap:'16px',marginTop:'16px'}},
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-blue)'}},registosOperacoes.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Operações')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-amber)'}},registosPerturbacoes.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Perturbações')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-green)'}},encomendas.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Encomendas')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-cyan)'}},Object.keys(mapaHoras).length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Meses Mapa Horas')
                            )
                        ),
                        !urlPowerAutomate && e('div',{style:{marginTop:'16px',padding:'12px',background:'var(--accent-amber-soft)',borderRadius:'var(--radius-sm)',fontSize:'13px',color:'var(--accent-amber)'}},
                            '⚠️ Configure o URL do Power Automate clicando em ⚙️ no canto superior direito'
                        )
                    ),
                    
                    // Importação manual
                    e('div',{className:'section'},
                        e('h3',{className:'section-title',style:{marginBottom:'20px'}},'📁 Importar Ficheiros Excel (manual)'),
                        e('div',{className:'kpi-grid'},
                            e('label',{className:'upload-zone',style:{gridColumn:'span 2',background:'linear-gradient(135deg, var(--accent-blue-soft), var(--accent-purple-soft))'}},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importRegistosProducao}),
                                e('div',{className:'upload-icon'},'📊'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Registos Produção (Évora)'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},
                                    registosOperacoes.length>0 || registosPerturbacoes.length>0 
                                        ? `✅ ${registosOperacoes.length} operações + ${registosPerturbacoes.length} perturbações`
                                        : 'Ficheiro com folhas Produção + Perturbações'
                                )
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importEncomendas}),
                                e('div',{className:'upload-icon'},'🧾'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Encomendas'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},encomendas.length>0?`✅ ${encomendas.length} registos`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importObjetivos}),
                                e('div',{className:'upload-icon'},'🎯'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Objetivos Operações'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(objetivos).length>0?`✅ ${Object.keys(objetivos).length} operações`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importObjetivos}),
                                e('div',{className:'upload-icon'},'📋'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Objetivos Tipologias'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(objetivosTipologia).length>0?`✅ ${Object.keys(objetivosTipologia).length} tipologias`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone',style:{background:'linear-gradient(135deg, var(--accent-green-soft), var(--accent-cyan-soft))'}},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importMapaHoras}),
                                e('div',{className:'upload-icon'},'⏰'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Mapa de Horas (Tempo Disponível)'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(mapaHoras).length>0?`✅ ${Object.keys(mapaHoras).length} meses carregados`:'Ficheiro Configurações App Produção')
                            )
                        )
                    )
                ),
                
                activeTab==='dashboard' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'📊'), e('div',{className:'empty-state-title'},'Nenhum dado importado'), e('div',{className:'empty-state-text'},'Vá ao separador "Importar" para carregar os ficheiros Excel.'))) :
                    e('div',null,
                        // KPI cards
                        e('div',{className:'kpi-grid'},
                            e(KPICard,{icon:'📦',iconColor:'blue',label:'Encomendas',value:formatNumber(kpis.totalEncomendas),valueColor:'blue',meta:`${formatNumber(kpis.totalEncEntregues)} entregues · ${formatNumber(kpis.totalEncEmStock)} stock` + (kpis.totalEncFatNaoTerm > 0 ? ` · ${formatNumber(kpis.totalEncFatNaoTerm)} fat.` : '')}),
                            e(KPICard,{icon:'💵',iconColor:'green',label:'Valor Faturado',value:formatCurrency(kpis.valorFaturado),valueColor:'green',meta:`${kpis.encFaturadas} de ${kpis.totalEncomendas} faturadas`}),
                            e(KPICard,{icon:'📊',iconColor:'red',label:'Perturbações',value:minutosParaHoras(kpis.tempoPerturbacoes),valueColor:kpis.tempoPerturbacoes>0?'red':'green',meta:`${kpis.numPerturbacoes} ocorrências`})
                        ),
                        // Gauges OEE e Eficiência Produtiva
                        e('div',{className:'section',style:{textAlign:'center'}},
                            e('div',{style:{display:'flex',justifyContent:'center',alignItems:'flex-start',gap:'40px',flexWrap:'wrap'}},
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.oee,label:'OEE Geral'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'D × P × Q')
                                ),
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.eficienciaProdutiva,label:'Eficiência Produtiva'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'Peças / (Cadência × T.Útil)')
                                )
                            )
                        ),
                        e('div',{className:'grid-2'},
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'💰 Valores Financeiros'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Valor Faturado'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},formatCurrency(kpis.valorFaturado))),
                                // Totais anuais quando mês filtrado
                                filtroMes && e('div',{style:{marginTop:'12px',paddingTop:'12px',borderTop:'1px dashed var(--border-color)'}},
                                    e('div',{style:{fontSize:'11px',color:'var(--text-muted)',marginBottom:'8px',fontStyle:'italic'}},'📅 Total Anual ('+filtroAno+'):'),
                                    e('div',{className:'summary-row'}, e('span',{className:'summary-label',style:{fontSize:'12px'}},'Faturado no Ano'), e('span',{className:'summary-value',style:{color:'var(--accent-green)',fontSize:'13px'}},formatCurrency(kpis.valorFaturadoAnual))),
                                    e('div',{className:'summary-row'}, e('span',{className:'summary-label',style:{fontSize:'12px'}},'Enc. Faturadas / Total'), e('span',{className:'summary-value',style:{fontSize:'13px'}},kpis.totalFaturadasAnual + ' / ' + kpis.totalEncAnual))
                                ),
                                // Valores por Localização
                                Object.keys(kpis.valorPorLocalizacao || {}).length > 0 && e('div',{style:{marginTop:'16px',paddingTop:'16px',borderTop:'1px solid var(--border-color)'}},
                                    e('div',{style:{fontSize:'13px',fontWeight:'600',marginBottom:'12px',color:'var(--text-secondary)'}},'Por Localização:'),
                                    Object.entries(kpis.valorPorLocalizacao).filter(([loc]) => loc && loc !== 'Sem Localização').sort((a,b) => b[1].total - a[1].total).map(([loc, dados]) => 
                                        e('div',{key:loc,className:'summary-row',style:{marginBottom:'4px'}}, 
                                            e('span',{className:'summary-label'},loc), 
                                            e('span',{className:'summary-value',style:{color:'var(--accent-cyan)'}},formatCurrency(dados.total))
                                        )
                                    )
                                )
                            ),
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Resumo Encomendas'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Terminadas Entregues e Faturadas'), e('span',{className:'summary-value'},formatNumber(kpis.totalEncEntregues))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Em Stock'), e('span',{className:'summary-value',style:{color:'var(--accent-amber)'}},formatNumber(kpis.totalEncEmStock))),
                                kpis.totalEncFatNaoTerm > 0 && e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Faturadas (Entregues mas falta Embalamento)'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},formatNumber(kpis.totalEncFatNaoTerm))),
                                e('div',{className:'summary-row',style:{borderTop:'1px solid var(--border-color)',paddingTop:'8px',marginTop:'4px'}}, e('span',{className:'summary-label',style:{fontWeight:'600'}},'Total'), e('span',{className:'summary-value',style:{fontWeight:'700'}},formatNumber(kpis.totalEncomendas))),
                                e('div',{className:'summary-row',style:{borderTop:'2px solid var(--border-color)',paddingTop:'12px',marginTop:'8px'}}, e('span',{className:'summary-label'},'Unidades Produzidas'), e('span',{className:'summary-value',style:{color:'var(--accent-blue)'}},formatNumber(kpis.totalProduzido))),
                                kpis.unidadesEmStock > 0 && e('div',{style:{fontSize:'11px',color:'var(--text-muted)',textAlign:'right',marginTop:'2px'}},'(inclui '+formatNumber(kpis.unidadesEmStock)+' em stock)')
                            )
                        ),
                        // Tabela por Tipologia
                        Object.keys(kpis.porTipologia).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📦 Quantidade por Tipologia'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipologia'), e('th',null,'Quantidade'), e('th',null,'Valor Total'), e('th',null,'Encomendas'))),
                                e('tbody',null, Object.entries(kpis.porTipologia).sort((a,b)=>b[1].quantidade-a[1].quantidade).slice(0,10).map(([t,d])=>{
                                    return e('tr',{key:t}, 
                                        e('td',null,e('strong',null,t)), 
                                        e('td',null,formatNumber(d.quantidade)), 
                                        e('td',null,formatCurrency(d.valor)), 
                                        e('td',null,formatNumber(d.total))
                                    );
                                }))
                            )
                        ),
                        // Gráfico evolução mensal
                        kpis.evolucaoMensal.length>0 && e('div',{className:'section'}, e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📈 Evolução Mensal'), e('div',{className:'chart-container'}, e('canvas',{id:'chartEvolucao'})))
                    )
                ),
                
                // SEPARADOR OPERAÇÕES
                activeTab==='operacoes' && (!registosOperacoes.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'🔧'), e('div',{className:'empty-state-title'},'Sem dados de operações'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Registos de Produção para ver a análise.'))) :
                    e('div',null,
                        // Tabela de Análise de Operações
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'🔧 Análise de Operações por Unidade / Tipologia'),
                            e('div',{style:{overflowX:'auto'}},
                                e('table',{className:'data-table'},
                                    e('thead',null, 
                                        e('tr',null, 
                                            e('th',null,'Unidade Produção'),
                                            e('th',null,'Caixa'),
                                            e('th',null,'Tipologia'),
                                            e('th',null,'Operação'),
                                            e('th',null,'Tempo Total (h)'),
                                            e('th',null,'Qtd Prod.'),
                                            e('th',null,'T. Obj/cx (h)'),
                                            e('th',null,'T. Médio/cx (h)'),
                                            e('th',null,'Rácio T.Obj/T.Real')
                                        )
                                    ),
                                    e('tbody',null, 
                                        (kpis.analiseArray || []).map((a, idx) => {
                                            const racioColor = a.racio >= 100 ? 'excellent' : a.racio >= 80 ? 'good' : a.racio > 0 ? 'warning' : '';
                                            return e('tr',{key:idx}, 
                                                e('td',null, a.unidadeProducao),
                                                e('td',null, e('strong',null, a.caixaDisplay || a.caixa)),
                                                e('td',null, a.tipologia),
                                                e('td',null, a.operacao),
                                                e('td',null, a.tempoTotalH.toFixed(1)),
                                                e('td',null, formatNumber(a.qtdProduzida)),
                                                e('td',null, a.tempoObjetivoH > 0 ? a.tempoObjetivoH.toFixed(2) : 'N/A'),
                                                e('td',null, a.tempoMedioH.toFixed(2)),
                                                e('td',null, e('span',{className:`status-badge ${racioColor}`}, a.racio > 0 ? a.racio.toFixed(0) + '%' : 'N/A'))
                                            );
                                        })
                                    )
                                )
                            )
                        ),
                        // Resumo por Unidade de Produção
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'🏭 Resumo por Unidade de Produção'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Unidade'), e('th',null,'Tempo Total (h)'), e('th',null,'Nº Operações'), e('th',null,'Média/Op (h)'))),
                                e('tbody',null, 
                                    Object.entries(
                                        (kpis.analiseArray || []).reduce((acc, a) => {
                                            if(!acc[a.unidadeProducao]) acc[a.unidadeProducao] = {tempo:0, ops:0};
                                            acc[a.unidadeProducao].tempo += a.tempoTotalH;
                                            acc[a.unidadeProducao].ops += a.numRegistos;
                                            return acc;
                                        }, {})
                                    ).sort((a,b) => b[1].tempo - a[1].tempo).map(([unidade, d]) =>
                                        e('tr',{key:unidade},
                                            e('td',null, e('strong',null, unidade)),
                                            e('td',null, d.tempo.toFixed(1)),
                                            e('td',null, formatNumber(d.ops)),
                                            e('td',null, d.ops > 0 ? (d.tempo / d.ops).toFixed(2) : 'N/A')
                                        )
                                    )
                                )
                            )
                        )
                    )
                ),
                
                // SEPARADOR PERTURBAÇÕES
                activeTab==='perturbacoes' && (!registosPerturbacoes.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'⚠️'), e('div',{className:'empty-state-title'},'Sem dados de perturbações'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Registos de Produção para ver as perturbações.'))) :
                    e('div',null,
                        // Gráfico de Perturbações Top 5
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'⚠️ Perturbações - Top 5'),
                            e('div',{className:'chart-container',style:{height:'300px'}}, e('canvas',{id:'chartPerturbacoes'}))
                        ),
                        // Tabela detalhada de perturbações
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📋 Detalhe de Perturbações'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo'), e('th',null,'Tempo (h)'), e('th',null,'Ocorrências'), e('th',null,'% do Total'))),
                                e('tbody',null, 
                                    Object.entries(kpis.perturbacoesPorTipo || {})
                                        .sort((a,b) => (b[1].tempo||0) - (a[1].tempo||0))
                                        .map(([tipo, dados]) => {
                                            const tempo = dados.tempo || 0;
                                            const count = dados.count || 0;
                                            const percentagem = kpis.tempoPerturbacoes > 0 ? (tempo / kpis.tempoPerturbacoes * 100) : 0;
                                            return e('tr',{key:tipo},
                                                e('td',null, e('strong',null, tipo)),
                                                e('td',null, (tempo/60).toFixed(1)),
                                                e('td',null, count),
                                                e('td',null, e('span',{className:'status-badge warning'}, percentagem.toFixed(1) + '%'))
                                            );
                                        })
                                )
                            )
                        ),
                        // Resumo
                        e('div',{className:'kpi-grid'},
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, (kpis.tempoPerturbacoes/60).toFixed(1) + 'h'),
                                e('div',{className:'kpi-label'},'Tempo Total Perturbações')
                            ),
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, formatNumber(kpis.numPerturbacoes)),
                                e('div',{className:'kpi-label'},'Total Ocorrências')
                            ),
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, Object.keys(kpis.perturbacoesPorTipo || {}).length),
                                e('div',{className:'kpi-label'},'Tipos Diferentes')
                            )
                        )
                    )
                ),
                
                // SEPARADOR PRODUTIVIDADE
                activeTab==='produtividade' && (!encomendas.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'📈'), e('div',{className:'empty-state-title'},'Sem dados de encomendas'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Encomendas para ver a produtividade.'))) :
                    e('div',null,
                        // Gráfico de Produtividade (€/hora)
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'💰 Produtividade (€ Faturado / Hora Disponível)'),
                            Object.keys(mapaHoras).length > 0 
                                ? e('div',{style:{marginBottom:'12px',fontSize:'11px',color:'var(--accent-green)'}},'✅ Calculado com Mapa de Horas')
                                : e('div',{style:{marginBottom:'12px',fontSize:'11px',color:'var(--accent-amber)'}},'⚠️ Aproximação pelo tempo de operações — importe o Mapa de Horas para dados reais'),
                            e('div',{className:'chart-container',style:{height:'300px'}}, e('canvas',{id:'chartProdutividade'}))
                        ),
                        // KPIs de Produtividade
                        (() => {
                            const totalHorasDisp = kpis.evolucaoMensal.reduce((s,d) => s + (d.horasDisponiveis || 0), 0);
                            const euroHoraTotal = totalHorasDisp > 0 ? kpis.valorTotal / totalHorasDisp : 0;
                            const euroHoraFaturado = totalHorasDisp > 0 ? kpis.valorFaturado / totalHorasDisp : 0;
                            return e('div',null,
                                e('div',{className:'kpi-grid'},
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value',style:{color:'var(--accent-green)'}}, formatCurrency(kpis.valorFaturado)),
                                        e('div',{className:'kpi-label'},'Valor Faturado')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, totalHorasDisp.toFixed(1) + 'h'),
                                        e('div',{className:'kpi-label'}, Object.keys(mapaHoras).length > 0 ? 'Horas Disponíveis (MH)' : 'Horas Trabalhadas')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value',style:{color:'var(--accent-green)'}}, totalHorasDisp > 0 ? formatCurrency(euroHoraFaturado) + '/h' : 'N/A'),
                                        e('div',{className:'kpi-label'},'€ Faturado / Hora')
                                    )
                                ),
                                e('div',{className:'kpi-grid',style:{marginTop:'12px'}},
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, formatNumber(kpis.totalEncomendas)),
                                        e('div',{className:'kpi-label'},'Total Encomendas')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, formatNumber(kpis.encFaturadas)),
                                        e('div',{className:'kpi-label'},'Faturadas')
                                    )
                                )
                            );
                        })(),
                        // Tabela de produtividade por mês
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Produtividade Mensal'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Mês'), e('th',null,'Faturado'), e('th',null,'Horas'), e('th',null,'€/Hora'), e('th',null,'Enc.'), e('th',null,'Fonte'))),
                                e('tbody',null, 
                                    kpis.evolucaoMensal.map(m => {
                                        const horas = m.horasDisponiveis || 0;
                                        const euroHoraFat = horas > 0 ? (m.valorFaturado || 0) / horas : 0;
                                        return e('tr',{key:m.mes},
                                            e('td',null, e('strong',null, m.mes)),
                                            e('td',null, e('span',{style:{color:'var(--accent-green)'}}, formatCurrency(m.valorFaturado || 0))),
                                            e('td',null, horas.toFixed(1)),
                                            e('td',null, e('span',{className:`status-badge ${euroHoraFat >= 50 ? 'excellent' : euroHoraFat >= 30 ? 'good' : 'warning'}`}, formatCurrency(euroHoraFat))),
                                            e('td',null, formatNumber(m.entregues || 0)),
                                            e('td',null, e('span',{style:{fontSize:'10px',color: m.usaMapaHoras ? 'var(--accent-green)' : 'var(--accent-amber)'}}, m.usaMapaHoras ? '✅ MH' : '~ Ops'))
                                        );
                                    })
                                )
                            )
                        )
                    )
                ),
                
                activeTab==='oee' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'⚙️'), e('div',{className:'empty-state-title'},'Sem dados para OEE'))) :
                    e('div',null,
                        e('div',{className:'section',style:{textAlign:'center'}},
                            e('h3',{className:'section-title',style:{marginBottom:'20px'}},'⚙️ OEE - Overall Equipment Effectiveness'),
                            // Dois gauges lado a lado
                            e('div',{style:{display:'flex',justifyContent:'center',alignItems:'flex-start',gap:'40px',flexWrap:'wrap'}},
                                // Gauge OEE Geral
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.oee,label:'OEE Geral'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'D × P × Q')
                                ),
                                // Gauge Eficiência Produtiva
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.eficienciaProdutiva,label:'Eficiência Produtiva'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'Peças Produzidas / (Cadência × T.Útil)'),
                                    e('div',{style:{marginTop:'4px',fontSize:'10px',color: Object.keys(mapaHoras).length > 0 ? 'var(--accent-green)' : 'var(--accent-amber)'}},
                                        Object.keys(mapaHoras).length > 0 ? '✅ Mapa de Horas' : '⚠️ Aproximação'
                                    )
                                )
                            ),
                            // Componentes OEE
                            e('div',{style:{marginTop:'40px',display:'flex',justifyContent:'space-around',gap:'30px',flexWrap:'wrap',maxWidth:'700px',margin:'40px auto 0'}},
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-blue)'}},kpis.disponibilidade.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Disponibilidade'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-blue)',marginTop:'4px',opacity:0.8}},'(T.Disponível - Perturbações) / T.Disponível')
                                ),
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-green)'}},kpis.performance.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Performance'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-green)',marginTop:'4px',opacity:0.8}},'T.Objetivo Total / T.Útil')
                                ),
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-purple)'}},kpis.qualidade.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Qualidade'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-purple)',marginTop:'4px',opacity:0.8}},'Peças Boas / Peças Totais')
                                )
                            ),
                            e('div',{style:{marginTop:'20px',fontSize:'12px',color:'var(--text-muted)'}},'OEE = Disponibilidade × Performance × Qualidade'),
                            // Indicador da fonte de dados
                            e('div',{style:{marginTop:'16px',padding:'10px 16px',background: Object.keys(mapaHoras).length > 0 ? 'var(--accent-green-soft)' : 'var(--accent-amber-soft)',borderRadius:'var(--radius-sm)',display:'inline-block',fontSize:'12px'}},
                                Object.keys(mapaHoras).length > 0 
                                    ? e('span',{style:{color:'var(--accent-green)'}}, '✅ Tempo Disponível: Mapa de Horas (real)')
                                    : e('span',{style:{color:'var(--accent-amber)'}}, '⚠️ Tempo Disponível: Aproximação pelo tempo de operações — importe o Mapa de Horas para dados reais')
                            )
                        ),
                        // Diferença entre OEE e Eficiência Produtiva
                        e('div',{className:'section',style:{padding:'20px'}},
                            e('div',{style:{display:'flex',gap:'20px',flexWrap:'wrap'}},
                                // OEE
                                e('div',{style:{flex:'1',minWidth:'250px',background:'rgba(139,92,246,0.08)',borderLeft:'3px solid var(--accent-purple)',borderRadius:'var(--radius-sm)',padding:'16px'}},
                                    e('div',{style:{fontWeight:'700',fontSize:'14px',color:'var(--accent-purple)',marginBottom:'8px'}},'⚙️ OEE — Eficiência Global do Equipamento'),
                                    e('div',{style:{fontSize:'12px',color:'var(--text-muted)',lineHeight:'1.6'}},
                                        'Mede a eficiência global considerando ',
                                        e('strong',null,'todos os factores de perda'),
                                        ': tempo parado (perturbações), velocidade abaixo do objectivo e defeitos. Penaliza por tudo o que reduz a produção face ao potencial máximo.'
                                    ),
                                    e('div',{style:{marginTop:'10px',fontSize:'11px',color:'var(--accent-purple)',fontFamily:'JetBrains Mono, monospace'}},'OEE = Disponibilidade × Performance × Qualidade')
                                ),
                                // Eficiência Produtiva
                                e('div',{style:{flex:'1',minWidth:'250px',background:'rgba(34,197,94,0.08)',borderLeft:'3px solid var(--accent-green)',borderRadius:'var(--radius-sm)',padding:'16px'}},
                                    e('div',{style:{fontWeight:'700',fontSize:'14px',color:'var(--accent-green)',marginBottom:'8px'}},'📊 Eficiência Produtiva'),
                                    e('div',{style:{fontSize:'12px',color:'var(--text-muted)',lineHeight:'1.6'}},
                                        'Mede se a quantidade produzida atingiu o ',
                                        e('strong',null,'objectivo teórico'),
                                        ' para o tempo útil disponível. Compara as peças reais com as peças que deveriam ter sido produzidas à cadência teórica, descontando apenas as paragens não planeadas.'
                                    ),
                                    e('div',{style:{marginTop:'10px',fontSize:'11px',color:'var(--accent-green)',fontFamily:'JetBrains Mono, monospace'}},'EP = Peças Produzidas / (Cadência Teórica × T.Útil)')
                                )
                            ),
                            e('div',{style:{marginTop:'14px',fontSize:'11px',color:'var(--text-muted)',textAlign:'center',fontStyle:'italic'}},
                                'O OEE é sempre ≤ Eficiência Produtiva porque multiplica pela Disponibilidade e Qualidade. A Eficiência Produtiva isola apenas o ritmo de produção face ao objectivo.'
                            )
                        ),
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📐 Detalhe do Cálculo OEE'),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Disponível Total'), e('span',{className:'summary-value',style:{color:'var(--accent-cyan)'}},minutosParaHoras(Object.keys(mapaHoras).length > 0 ? (filtroMes ? (mapaHoras[filtroMes]||0) : Object.entries(mapaHoras).filter(([m])=> !filtroAno || m.endsWith('/'+filtroAno)).reduce((s,e)=>s+e[1],0)) : kpis.tempoTotalOps))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Perturbações'), e('span',{className:'summary-value',style:{color:'var(--accent-red)'}},minutosParaHoras(kpis.tempoPerturbacoes))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Útil (Disponível - Perturbações)'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},minutosParaHoras(Math.max(0, (Object.keys(mapaHoras).length > 0 ? (filtroMes ? (mapaHoras[filtroMes]||0) : Object.entries(mapaHoras).filter(([m])=> !filtroAno || m.endsWith('/'+filtroAno)).reduce((s,e)=>s+e[1],0)) : kpis.tempoTotalOps) - kpis.tempoPerturbacoes)))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Operações Registado'), e('span',{className:'summary-value'},minutosParaHoras(kpis.tempoTotalOps))),
                            e('div',{className:'summary-row',style:{borderTop:'2px solid var(--border-color)',paddingTop:'12px',marginTop:'4px'}}, 
                                e('span',{className:'summary-label',style:{fontWeight:'600'}},'Fórmulas Utilizadas:'), 
                                e('span',{style:{fontSize:'11px',color:'var(--text-muted)'}},
                                    'Disp = (T.Disponível - Perturbações) / T.Disponível | Perf = T.Objetivo Total / T.Útil | OEE = D × P × Q'
                                )
                            )
                        ),
                        Object.keys(kpis.performancePorCaixa||{}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Performance por Caixa/Artigo'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Caixa/Artigo'), e('th',null,'Tempo Real'), e('th',null,'T.Obj/Cx'), e('th',null,'Qtd'), e('th',null,'T.Obj Total'), e('th',null,'Performance'))),
                                e('tbody',null, Object.entries(kpis.performancePorCaixa).filter(([c,d])=>c!=='Sem Caixa'&&d.tempoReal>0).sort((a,b)=>b[1].tempoReal-a[1].tempoReal).slice(0,25).map(([caixa,d])=>
                                    e('tr',{key:caixa}, 
                                        e('td',null,e('strong',null,caixa)), 
                                        e('td',null,minutosParaHoras(d.tempoReal)), 
                                        e('td',null,d.tempoObjUnitario>0?minutosParaHoras(d.tempoObjUnitario):'N/A'),
                                        e('td',null,d.quantidade||'-'),
                                        e('td',null,d.tempoObjetivo>0?minutosParaHoras(d.tempoObjetivo):'N/A'), 
                                        e('td',null,e('span',{className:`status-badge ${d.performance>=100?'excellent':d.performance>=80?'good':d.performance>0?'warning':''}`},d.performance>0?d.performance.toFixed(1)+'%':'N/A'))
                                    )
                                ))
                            )
                        ),
                        Object.keys(kpis.perturbacoesPorTipo).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'⚠️ Perturbações por Tipo'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo'), e('th',null,'Tempo Total'), e('th',null,'Ocorrências'), e('th',null,'% do Total'))),
                                e('tbody',null, Object.entries(kpis.perturbacoesPorTipo).sort((a,b)=>b[1].tempo-a[1].tempo).map(([t,d])=>
                                    e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,minutosParaHoras(d.tempo)), e('td',null,d.count), e('td',null,e('span',{className:'status-badge warning'},(d.tempo/kpis.tempoPerturbacoes*100).toFixed(1)+'%')))
                                ))
                            )
                        ),
                        Object.keys(kpis.oeePorMes||{}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📅 OEE por Mês'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Mês'), e('th',null,'T. Disponível'), e('th',null,'T. Operações'), e('th',null,'Perturbações'), e('th',null,'Disponibilidade'), e('th',null,'Performance'), e('th',null,'OEE'))),
                                e('tbody',null, Object.entries(kpis.oeePorMes).sort((a,b)=>{const[ma,ya]=a[0].split('/').map(Number),[mb,yb]=b[0].split('/').map(Number);return yb!==ya?yb-ya:mb-ma;}).map(([mes,d])=>
                                    e('tr',{key:mes}, 
                                        e('td',null,e('strong',null,mes)), 
                                        e('td',null,
                                            e('span',{style:{color: d.usaMapaHoras ? 'var(--accent-cyan)' : 'var(--text-muted)'}},
                                                minutosParaHoras(d.tempoDisponivel),
                                                d.usaMapaHoras ? ' ✅' : ' ~'
                                            )
                                        ),
                                        e('td',null,minutosParaHoras(d.tempoOperacoes)), 
                                        e('td',null,e('span',{style:{color:'var(--accent-red)'}},minutosParaHoras(d.tempoPerturbacoes))), 
                                        e('td',null,e('span',{className:`status-badge ${d.disponibilidade>=90?'excellent':d.disponibilidade>=80?'good':'warning'}`},d.disponibilidade.toFixed(1)+'%')),
                                        e('td',null,e('span',{className:`status-badge ${d.performance>=100?'excellent':d.performance>=80?'good':d.performance>0?'warning':''}`},d.performance>0?d.performance.toFixed(1)+'%':'N/A')),
                                        e('td',null,e('span',{className:`status-badge ${d.oee>=85?'excellent':d.oee>=60?'good':d.oee>0?'warning':'critical'}`,style:{fontWeight:'700'}},d.oee>0?d.oee.toFixed(1)+'%':'N/A'))
                                    )
                                ))
                            )
                        )
                    )
                ),
                
                activeTab==='detalhes' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'📋'), e('div',{className:'empty-state-title'},'Sem dados'))) :
                    e('div',null,
                        Object.keys(kpis.porTipologia || {}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📦 Quantidade Entregue por Tipologia'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipologia'), e('th',null,'Qtd Entregue'), e('th',null,'Valor Faturado'), e('th',null,'Eficiência'))),
                                e('tbody',null, Object.entries(kpis.porTipologia).sort((a,b)=>b[1].qtdEntregue-a[1].qtdEntregue).map(([t,d])=>{
                                    const ef = kpis.eficienciaPorTipologia && kpis.eficienciaPorTipologia[t] ? kpis.eficienciaPorTipologia[t].eficiencia : 0;
                                    return e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,formatNumber(d.qtdEntregue)), e('td',null,formatCurrency(d.valorFaturado)), e('td',null,e('span',{className:`status-badge ${ef>=100?'excellent':ef>=80?'good':ef>0?'warning':''}`},ef>0?ef.toFixed(0)+'%':'N/A')));
                                }))
                            )
                        ),
                        Object.keys(kpis.porCaixa || {}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📋 Quantidade Entregue por Tipo de Caixa'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo Caixa'), e('th',null,'Qtd Entregue'), e('th',null,'Valor Faturado'))),
                                e('tbody',null, Object.entries(kpis.porCaixa).sort((a,b)=>b[1].qtdEntregue-a[1].qtdEntregue).map(([t,d])=>{
                                    return e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,formatNumber(d.qtdEntregue)), e('td',null,formatCurrency(d.valorFaturado)));
                                }))
                            )
                        ),
                        e('div',{className:'grid-2'},
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Estatísticas Operações'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Total'), e('span',{className:'summary-value'},formatNumber(kpis.numOperacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Total'), e('span',{className:'summary-value'},minutosParaHoras(kpis.tempoTotalOps))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Média/Operação'), e('span',{className:'summary-value'},kpis.numOperacoes>0?minutosParaHoras(Math.round(kpis.tempoTotalOps/kpis.numOperacoes)):'N/A'))
                            ),
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'⚠️ Estatísticas Perturbações'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Total'), e('span',{className:'summary-value'},formatNumber(kpis.numPerturbacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Perdido'), e('span',{className:'summary-value',style:{color:'var(--accent-red)'}},minutosParaHoras(kpis.tempoPerturbacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'% do Tempo Ops'), e('span',{className:'summary-value'},kpis.tempoTotalOps>0?(kpis.tempoPerturbacoes/kpis.tempoTotalOps*100).toFixed(1)+'%':'N/A'))
                            )
                        )
                    )
                ),
                
                msg && e('div',{className:`msg-toast ${msgType}`},msg)
            );
        }
        
        ReactDOM.render(e(App), document.getElementById('root'));
    </script>
</body>
</html>
