<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="KPI Embaresa">
    <meta name="theme-color" content="#0f172a">
    <meta name="description" content="Sistema de KPIs - Produ√ß√£o e Encomendas Embaresa PT">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlNpc3RlbWEgS1BJcyBFbWJhcmVzYSIsCiAgInNob3J0X25hbWUiOiAiS1BJIEVtYmFyZXNhIiwKICAiZGVzY3JpcHRpb24iOiAiU2lzdGVtYSBkZSBLUElzIC0gUHJvZHXDp8OjbyBlIEVuY29tZW5kYXMiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzBmMTcyYSIsCiAgInRoZW1lX2NvbG9yIjogIiMwZjE3MmEiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIyYVdWM1FtOTRQU0l3SURBZ01UQXdJREV3TUNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNtVmpkQ0IzYVdSMGFEMGlNVEF3SWlCb1pXbG5hSFE5SWpFd01DSWdabWxzYkQwaUl6Qm1NVGN5WVNJdlBqeDBaWGgwSUhnOUlqVXdJaUI1UFNJMU5TSWdabTl1ZEMxemFYcGxQU0l6TUNJZ1ptbHNiRDBpZDJocGRHVWlJSFJsZUhRdFlXNWphRzl5UFNKdGFXUmtiR1VpSUdadmJuUXRkMlZwWjJoMFBTSTNNREFpUGt0UVNUd3ZkR1Y0ZEQ0OEwzTjJaejQ9IiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIsCiAgICAgICJzaXplcyI6ICJhbnkiCiAgICB9CiAgXQp9">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzBmMTcyYSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSIzMCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtd2VpZ2h0PSI3MDAiPktQSTwvdGV4dD48L3N2Zz4=">
    <title>Sistema de KPIs v88 - Produ√ß√£o e Encomendas</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root { --bg-primary:#0f172a;--bg-secondary:#1e293b;--bg-card:#1e293b;--bg-card-hover:#334155;--text-primary:#f1f5f9;--text-secondary:#94a3b8;--text-muted:#64748b;--accent-green:#10b981;--accent-green-soft:rgba(16,185,129,0.15);--accent-blue:#3b82f6;--accent-blue-soft:rgba(59,130,246,0.15);--accent-amber:#f59e0b;--accent-amber-soft:rgba(245,158,11,0.15);--accent-red:#ef4444;--accent-red-soft:rgba(239,68,68,0.15);--accent-purple:#8b5cf6;--accent-purple-soft:rgba(139,92,246,0.15);--accent-cyan:#06b6d4;--accent-cyan-soft:rgba(6,182,212,0.15);--border-color:#334155;--shadow:0 4px 6px -1px rgba(0,0,0,0.3);--radius:12px;--radius-sm:8px; }
        * { box-sizing:border-box;margin:0;padding:0; }
        body { font-family:'DM Sans',-apple-system,sans-serif;background:var(--bg-primary);color:var(--text-primary);min-height:100vh;-webkit-tap-highlight-color:transparent; }
        
        /* PWA - Safe area para iPhones com notch */
        @supports (padding: max(0px)) {
            .app { padding: 20px; padding-top: max(20px, env(safe-area-inset-top)); padding-bottom: max(20px, env(safe-area-inset-bottom)); }
        }
        
        /* PWA - Standalone mode */
        @media all and (display-mode: standalone) {
            .header { padding-top: 10px; }
        }
        
        .app { max-width:1600px;margin:0 auto;padding:20px; }
        .header { display:flex;align-items:center;justify-content:space-between;padding:20px 0;margin-bottom:24px;border-bottom:1px solid var(--border-color);flex-wrap:wrap;gap:12px; }
        .header-left { display:flex;align-items:center;gap:16px; }
        .logo { width:48px;height:48px;background:linear-gradient(135deg,var(--accent-blue),var(--accent-purple));border-radius:var(--radius);display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0; }
        .header h1 { font-size:24px;font-weight:700; }
        .header p { font-size:13px;color:var(--text-muted); }
        
        /* Loading spinner */
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-spinner { display:inline-block;width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin 0.8s linear infinite;margin-right:8px; }
        .btn { display:inline-flex;align-items:center;gap:8px;padding:10px 16px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;cursor:pointer;transition:all 0.2s;border:none;font-family:inherit; }
        .btn-primary { background:var(--accent-blue);color:white; }
        .btn-primary:hover { background:#2563eb;transform:translateY(-1px); }
        .btn-secondary { background:var(--bg-card);color:var(--text-primary);border:1px solid var(--border-color); }
        .tabs { display:flex;gap:4px;background:var(--bg-secondary);padding:4px;border-radius:var(--radius);margin-bottom:24px; }
        .tab { padding:10px 20px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;cursor:pointer;transition:all 0.2s;border:none;background:transparent;color:var(--text-secondary);font-family:inherit; }
        .tab:hover { color:var(--text-primary);background:var(--bg-card-hover); }
        .tab.active { background:var(--accent-blue);color:white; }
        .kpi-grid { display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-bottom:24px; }
        .kpi-card { background:var(--bg-card);border-radius:var(--radius);padding:20px;border:1px solid var(--border-color);transition:all 0.2s; }
        .kpi-card:hover { border-color:var(--accent-blue);transform:translateY(-2px);box-shadow:var(--shadow); }
        .kpi-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:12px; }
        .kpi-icon { width:40px;height:40px;border-radius:var(--radius-sm);display:flex;align-items:center;justify-content:center;font-size:20px; }
        .kpi-icon.green { background:var(--accent-green-soft); }
        .kpi-icon.blue { background:var(--accent-blue-soft); }
        .kpi-icon.amber { background:var(--accent-amber-soft); }
        .kpi-icon.red { background:var(--accent-red-soft); }
        .kpi-icon.purple { background:var(--accent-purple-soft); }
        .kpi-icon.cyan { background:var(--accent-cyan-soft); }
        .kpi-trend { display:flex;align-items:center;gap:4px;font-size:12px;font-weight:500;padding:4px 8px;border-radius:20px; }
        .kpi-trend.up { background:var(--accent-green-soft);color:var(--accent-green); }
        .kpi-trend.down { background:var(--accent-red-soft);color:var(--accent-red); }
        .kpi-value { font-size:32px;font-weight:700;font-family:'JetBrains Mono',monospace;margin-bottom:4px; }
        .kpi-value.green { color:var(--accent-green); }
        .kpi-value.blue { color:var(--accent-blue); }
        .kpi-value.amber { color:var(--accent-amber); }
        .kpi-value.red { color:var(--accent-red); }
        .kpi-value.purple { color:var(--accent-purple); }
        .kpi-value.cyan { color:var(--accent-cyan); }
        .kpi-label { font-size:13px;color:var(--text-secondary);margin-bottom:8px; }
        .kpi-progress { height:6px;background:var(--bg-primary);border-radius:3px;overflow:hidden;margin-top:12px; }
        .kpi-progress-bar { height:100%;border-radius:3px;transition:width 0.5s ease; }
        .kpi-progress-bar.green { background:var(--accent-green); }
        .kpi-progress-bar.blue { background:var(--accent-blue); }
        .kpi-progress-bar.amber { background:var(--accent-amber); }
        .kpi-progress-bar.red { background:var(--accent-red); }
        .kpi-meta { display:flex;justify-content:space-between;margin-top:8px;font-size:11px;color:var(--text-muted); }
        .section { background:var(--bg-card);border-radius:var(--radius);padding:20px;border:1px solid var(--border-color);margin-bottom:24px; }
        .section-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:16px; }
        .section-title { font-size:16px;font-weight:600; }
        .chart-container { height:300px;position:relative; }
        .data-table { width:100%;border-collapse:collapse; }
        .data-table th,.data-table td { padding:12px 16px;text-align:left;border-bottom:1px solid var(--border-color); }
        .data-table th { font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);background:var(--bg-primary); }
        .data-table td { font-size:13px; }
        .data-table tr:hover td { background:var(--bg-card-hover); }
        .status-badge { display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:20px;font-size:11px;font-weight:500; }
        .status-badge.excellent { background:var(--accent-green-soft);color:var(--accent-green); }
        .status-badge.good { background:var(--accent-blue-soft);color:var(--accent-blue); }
        .status-badge.warning { background:var(--accent-amber-soft);color:var(--accent-amber); }
        .status-badge.critical { background:var(--accent-red-soft);color:var(--accent-red); }
        .upload-zone { border:2px dashed var(--border-color);border-radius:var(--radius);padding:40px;text-align:center;cursor:pointer;transition:all 0.2s; }
        .upload-zone:hover { border-color:var(--accent-blue);background:var(--accent-blue-soft); }
        .upload-zone input { display:none; }
        .upload-icon { font-size:48px;margin-bottom:16px; }
        .filter-bar { display:flex;gap:12px;margin-bottom:16px;flex-wrap:wrap; }
        .filter-select { padding:8px 12px;border-radius:var(--radius-sm);background:var(--bg-primary);border:1px solid var(--border-color);color:var(--text-primary);font-size:13px;font-family:inherit; }
        .filter-select:focus { outline:none;border-color:var(--accent-blue); }
        .gauge-container { display:flex;justify-content:center;align-items:center;padding:10px; }
        .gauge-needle { transition:transform 0.8s cubic-bezier(0.4,2,0.2,1); transform-origin:50% 50%; }
        .msg-toast { position:fixed;bottom:24px;right:24px;padding:12px 20px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;z-index:1000;animation:slideIn 0.3s ease; }
        .msg-toast.success { background:var(--accent-green);color:white; }
        .msg-toast.error { background:var(--accent-red);color:white; }
        .msg-toast.info { background:var(--accent-blue);color:white; }
        @keyframes slideIn { from{transform:translateX(100%);opacity:0;} to{transform:translateX(0);opacity:1;} }
        .empty-state { text-align:center;padding:60px 20px; }
        .empty-state-icon { font-size:64px;margin-bottom:16px;opacity:0.5; }
        .empty-state-title { font-size:18px;font-weight:600;margin-bottom:8px; }
        .empty-state-text { font-size:14px;color:var(--text-muted);max-width:400px;margin:0 auto; }
        .grid-2 { display:grid;grid-template-columns:repeat(2,1fr);gap:24px; }
        @media(max-width:1024px) { .grid-2{grid-template-columns:1fr;} }
        .summary-row { display:flex;justify-content:space-between;padding:10px 0;border-bottom:1px solid var(--border-color); }
        .summary-row:last-child { border-bottom:none; }
        .summary-label { color:var(--text-secondary);font-size:13px; }
        .summary-value { font-weight:600;font-family:'JetBrains Mono',monospace; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        const { useState, useEffect, useMemo, useRef } = React;
        const e = React.createElement;
        
        function findValue(row, keys) { for(let k of keys) if(row[k]!==undefined && row[k]!==null && row[k]!=='') return row[k]; return ''; }
        
        // Verificar se um valor √© realmente um n√∫mero de fatura v√°lido
        function isFaturaValida(numFatura) {
            if(!numFatura) return false;
            const str = numFatura.toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
            if(str === '' || str === 'nan' || str === 'null' || str === 'undefined' || str === '0') return false;
            if(str.length < 2) return false;
            // Deve conter d√≠gitos E pelo menos um separador (/, -)  OU come√ßar com FAC/FT/ND/NC/REC (padr√µes de fatura portuguesa)
            const temDigitos = /\d/.test(str);
            const temSeparador = /[\/\-]/.test(str);
            const comecaComPrefixo = /^(fac|ft|nd|nc|rec|fat|inv)/i.test(str);
            // Se cont√©m "fornecido" ou "ann" ou outros valores do EstadoFinal, N√ÉO √© fatura
            const pareceEstado = /(fornecido|entregue|terminad|embalad|produzid|stock|pendente|ann\s)/i.test(numFatura.toString());
            if(pareceEstado) return false;
            return (temDigitos && temSeparador) || comecaComPrefixo || (temDigitos && str.length >= 4);
        }
        
        // Fun√ß√£o para normalizar nomes de opera√ß√µes (remover espa√ßos extras)
        function normalizarOperacao(op) {
            if(!op) return '';
            return op.toString().replace(/\s+/g, ' ').trim();
        }
        
        function parseExcelDate(serial) {
            if(!serial && serial!==0) return '';
            if(typeof serial==='string') { if(serial.includes('/')) return serial; const num=parseFloat(serial); if(!isNaN(num) && num>0) { const d=new Date((num-25569)*86400*1000); return String(d.getDate()).padStart(2,'0')+'/'+String(d.getMonth()+1).padStart(2,'0')+'/'+d.getFullYear(); } return serial; }
            if(typeof serial==='number' && serial>0) { const d=new Date((serial-25569)*86400*1000); return String(d.getDate()).padStart(2,'0')+'/'+String(d.getMonth()+1).padStart(2,'0')+'/'+d.getFullYear(); }
            return '';
        }
        
        function getMesAno(ds) { if(!ds) return ''; const p=ds.split('/'); return p.length===3 ? p[1]+'/'+p[2] : ''; }
        
        function parseExcelTime(tv) {
            if(!tv) return '';
            try {
                if(typeof tv==='string') { tv=tv.trim(); const m=tv.match(/^(\d{1,2}):(\d{2})/); if(m) return String(m[1]).padStart(2,'0')+':'+String(m[2]).padStart(2,'0'); const n=parseFloat(tv); if(!isNaN(n) && n>=0 && n<=1) { const tm=Math.round(n*24*60); return String(Math.floor(tm/60)).padStart(2,'0')+':'+String(tm%60).padStart(2,'0'); } }
                if(typeof tv==='number' && tv>=0 && tv<=1) { const tm=Math.round(tv*24*60); return String(Math.floor(tm/60)).padStart(2,'0')+':'+String(tm%60).padStart(2,'0'); }
            } catch(e){}
            return '';
        }
        
        function calcDuracao(ini, fim) { try { const i=parseExcelTime(ini), f=parseExcelTime(fim); if(!i||!f) return 0; const [hi,mi]=i.split(':').map(Number), [hf,mf]=f.split(':').map(Number); let d=((hf*60)+mf)-((hi*60)+mi); if(d<0) d=(24*60)+d; return d; } catch(e){return 0;} }
        
        function minutosParaHoras(m) { if(!m||m===0) return '0h'; const h=Math.floor(m/60), min=Math.round(m%60); return min===0 ? h+'h' : h+'h '+min+'m'; }
        function formatNumber(n, d=0) { if(n===undefined||n===null||isNaN(n)) return '0'; return n.toLocaleString('pt-PT',{minimumFractionDigits:d,maximumFractionDigits:d}); }
        function formatCurrency(n) { if(n===undefined||n===null||isNaN(n)) return '0 ‚Ç¨'; return n.toLocaleString('pt-PT',{minimumFractionDigits:2,maximumFractionDigits:2})+' ‚Ç¨'; }
        
        function KPICard({icon, iconColor, label, value, valueColor, progress, progressColor, meta, target}) {
            return e('div',{className:'kpi-card'},
                e('div',{className:'kpi-header'}, e('div',{className:`kpi-icon ${iconColor}`},icon)),
                e('div',{className:`kpi-value ${valueColor||''}`},value),
                e('div',{className:'kpi-label'},label),
                progress!==undefined && e('div',{className:'kpi-progress'}, e('div',{className:`kpi-progress-bar ${progressColor||'blue'}`,style:{width:Math.min(progress,100)+'%'}})),
                (meta||target) && e('div',{className:'kpi-meta'}, meta && e('span',null,meta), target && e('span',null,'Meta: '+target))
            );
        }
        
        function Gauge({value, label}) {
            const percentage = Math.min(Math.max(value, 0), 120);
            const clampedForColor = Math.min(value, 100);
            
            // Arco de 180¬∞ (de -90¬∞ a +90¬∞, ou seja, de 9h a 3h)
            const cx = 120, cy = 110, r = 80, r2 = 65;
            const startAngle = -210; // graus (7h)
            const endAngle = 30;    // graus (5h)  
            const sweep = endAngle - startAngle; // 240¬∞
            
            // Fun√ß√£o para converter √¢ngulo em coordenadas
            const polarToXY = (angle, radius) => {
                const rad = (angle * Math.PI) / 180;
                return { x: cx + radius * Math.cos(rad), y: cy + radius * Math.sin(rad) };
            };
            
            // Arco de fundo (track)
            const trackStart = polarToXY(startAngle, r);
            const trackEnd = polarToXY(endAngle, r);
            const trackPath = `M ${trackStart.x} ${trackStart.y} A ${r} ${r} 0 1 1 ${trackEnd.x} ${trackEnd.y}`;
            
            // Arco de preenchimento (fill)
            const fillAngle = startAngle + (percentage / 120) * sweep;
            const fillEnd = polarToXY(fillAngle, r);
            const largeArc = (fillAngle - startAngle) > 180 ? 1 : 0;
            const fillPath = `M ${trackStart.x} ${trackStart.y} A ${r} ${r} 0 ${largeArc} 1 ${fillEnd.x} ${fillEnd.y}`;
            
            // Cor baseada no valor
            const getColor = (v) => v >= 85 ? '#22c55e' : v >= 60 ? '#f59e0b' : '#ef4444';
            const fillColor = getColor(clampedForColor);
            
            // Agulha
            const needleAngle = startAngle + (percentage / 120) * sweep;
            const needleTip = polarToXY(needleAngle, r - 8);
            const needleBase1 = polarToXY(needleAngle + 90, 4);
            const needleBase2 = polarToXY(needleAngle - 90, 4);
            
            // Marca√ß√µes
            const ticks = [0, 20, 40, 60, 80, 100, 120];
            
            return e('div',{className:'gauge-container',style:{flexDirection:'column'}},
                e('svg',{width:240,height:155,viewBox:'0 0 240 155',style:{overflow:'visible'}},
                    // Defini√ß√µes
                    e('defs',null,
                        e('linearGradient',{id:`grad_${label.replace(/\s/g,'')}`,x1:'0%',y1:'0%',x2:'100%',y2:'0%'},
                            e('stop',{offset:'0%',stopColor:'#ef4444'}),
                            e('stop',{offset:'40%',stopColor:'#f59e0b'}),
                            e('stop',{offset:'70%',stopColor:'#22c55e'}),
                            e('stop',{offset:'100%',stopColor:'#22c55e'})
                        ),
                        e('filter',{id:'needleShadow'},
                            e('feDropShadow',{dx:0,dy:1,stdDeviation:2,floodColor:'rgba(0,0,0,0.3)'})
                        )
                    ),
                    // Arco de fundo
                    e('path',{d:trackPath,fill:'none',stroke:'#1e293b',strokeWidth:14,strokeLinecap:'round'}),
                    // Arco de progresso com gradiente
                    percentage > 0.5 && e('path',{d:fillPath,fill:'none',stroke:`url(#grad_${label.replace(/\s/g,'')})`,strokeWidth:14,strokeLinecap:'round'}),
                    // Marca√ß√µes e n√∫meros
                    ...ticks.map(t => {
                        const tickAngle = startAngle + (t / 120) * sweep;
                        const outerP = polarToXY(tickAngle, r + 10);
                        const innerP = polarToXY(tickAngle, r + 3);
                        const labelP = polarToXY(tickAngle, r + 22);
                        return e('g',{key:t},
                            e('line',{x1:innerP.x,y1:innerP.y,x2:outerP.x,y2:outerP.y,stroke:'#64748b',strokeWidth:t%20===0?2:1}),
                            e('text',{x:labelP.x,y:labelP.y,textAnchor:'middle',dominantBaseline:'middle',fill:'#94a3b8',fontSize:9,fontFamily:'JetBrains Mono, monospace'},t.toString())
                        );
                    }),
                    // Sub-marca√ß√µes pequenas
                    ...[10,30,50,70,90,110].map(t => {
                        const tickAngle = startAngle + (t / 120) * sweep;
                        const outerP = polarToXY(tickAngle, r + 7);
                        const innerP = polarToXY(tickAngle, r + 3);
                        return e('line',{key:'sub'+t,x1:innerP.x,y1:innerP.y,x2:outerP.x,y2:outerP.y,stroke:'#475569',strokeWidth:1});
                    }),
                    // Agulha
                    e('polygon',{
                        points:`${needleTip.x},${needleTip.y} ${needleBase1.x},${needleBase1.y} ${needleBase2.x},${needleBase2.y}`,
                        fill:fillColor,
                        filter:'url(#needleShadow)',
                        className:'gauge-needle'
                    }),
                    // Centro da agulha
                    e('circle',{cx:cx,cy:cy,r:8,fill:'#1e293b',stroke:'#334155',strokeWidth:2}),
                    e('circle',{cx:cx,cy:cy,r:3,fill:fillColor}),
                    // Valor digital
                    e('text',{x:cx,y:cy+32,textAnchor:'middle',fill:fillColor,fontSize:22,fontWeight:700,fontFamily:'JetBrains Mono, monospace'},value.toFixed(1)+'%'),
                    // Label
                    e('text',{x:cx,y:cy+48,textAnchor:'middle',fill:'#94a3b8',fontSize:11},label)
                )
            );
        }
        
        function App() {
            const [activeTab, setActiveTab] = useState('dashboard');
            const [msg, setMsg] = useState('');
            const [msgType, setMsgType] = useState('info');
            const [encomendas, setEncomendas] = useState([]);
            const [encomendasProducao, setEncomendasProducao] = useState([]); // Pendentes - s√≥ para OEE
            const [registosProducao, setRegistosProducao] = useState([]);
            const [registosOperacoes, setRegistosOperacoes] = useState([]);
            const [registosPerturbacoes, setRegistosPerturbacoes] = useState([]);
            const [objetivos, setObjetivos] = useState({});
            const [objetivosTipologia, setObjetivosTipologia] = useState({});
            const [mapCaixaEcode, setMapCaixaEcode] = useState({});
            const [mapaHoras, setMapaHoras] = useState({}); // {mesAno: totalMinutos} ex: {'01/2026': 109938}
            const [filtroMes, setFiltroMes] = useState('');
            const [filtroAno, setFiltroAno] = useState('2026');
            const [filtroTipologia, setFiltroTipologia] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [lastUpdate, setLastUpdate] = useState(null);
            const chartRefs = useRef({});
            
            const showMsg = (text, type='info') => { setMsg(text); setMsgType(type); setTimeout(()=>setMsg(''),4000); };
            
            // URL √∫nico do Power Automate que retorna todos os dados
            const [urlPowerAutomate, setUrlPowerAutomate] = useState(() => {
                try { 
                    return localStorage.getItem('kpi_url_powerautomate') || 'https://defaultcade90c14fe343a3860494c20418f8.fb.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d4580994e5004a7f9934f95e968ae3f5/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=fup1O88I7aEoSyDzrILnUSRbaCYbucNvpKktzTubedQ'; 
                } catch(e) { 
                    return 'https://defaultcade90c14fe343a3860494c20418f8.fb.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d4580994e5004a7f9934f95e968ae3f5/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=fup1O88I7aEoSyDzrILnUSRbaCYbucNvpKktzTubedQ'; 
                }
            });
            
            // Guardar URL quando muda
            useEffect(() => {
                if(urlPowerAutomate) {
                    try { localStorage.setItem('kpi_url_powerautomate', urlPowerAutomate); } catch(e) {}
                }
            }, [urlPowerAutomate]);
            
            // Fun√ß√£o para carregar dados do Power Automate
            const carregarDadosPowerAutomate = async () => {
                if(!urlPowerAutomate) {
                    showMsg('‚ö†Ô∏è Configure o URL do Power Automate nas defini√ß√µes', 'error');
                    return;
                }
                
                setIsLoading(true);
                showMsg('üîÑ A carregar dados...', 'info');
                console.log('üì° A fazer fetch para:', urlPowerAutomate.substring(0, 50) + '...');
                
                try {
                    const response = await fetch(urlPowerAutomate, {
                        method: 'POST',
                        mode: 'cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ acao: 'ler' })
                    });
                    
                    console.log('üì° Resposta recebida, status:', response.status);
                    
                    if(!response.ok) throw new Error('Erro na resposta: ' + response.status);
                    
                    const textRaw = await response.text();
                    console.log('üìÑ Resposta raw (primeiros 500 chars):', textRaw.substring(0, 500));
                    
                    let data;
                    try {
                        data = JSON.parse(textRaw);
                    } catch(parseErr) {
                        console.error('‚ùå Erro a fazer parse do JSON:', parseErr);
                        console.log('üìÑ Resposta completa:', textRaw);
                        throw new Error('JSON inv√°lido recebido do Power Automate');
                    }
                    
                    console.log('üì• Dados recebidos do Power Automate:', data);
                    
                    // Processar Produ√ß√£o
                    if(data.producao && Array.isArray(data.producao)) {
                        const ops = data.producao.map(row => {
                            // Converter data Excel para formato dd/mm/yyyy
                            let dataFormatada = '';
                            const dataRaw = row['Data'] || row['data'];
                            if(dataRaw) {
                                if(typeof dataRaw === 'number' || /^\d+$/.test(dataRaw)) {
                                    const excelDate = parseInt(dataRaw);
                                    const jsDate = new Date((excelDate - 25569) * 86400 * 1000);
                                    dataFormatada = jsDate.toLocaleDateString('pt-PT');
                                } else {
                                    dataFormatada = dataRaw;
                                }
                            }
                            
                            // Extrair m√™s/ano
                            let mesAno = '';
                            if(dataFormatada) {
                                const parts = dataFormatada.split('/');
                                if(parts.length >= 3) {
                                    mesAno = parts[1] + '/' + parts[2];
                                }
                            }
                            
                            // Calcular dura√ß√£o a partir do campo Dura√ß√£o (formato "Xh Ymin")
                            let duracao = 0;
                            const duracaoStr = row['Dura√ß√£o'] || row['Duracao'] || row['duracao'] || '';
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            
                            return {
                                data: dataFormatada,
                                unidadeProducao: row['Unidade Produ√ß√£o'] || row['UnidadeProducao'] || row['unidadeProducao'],
                                tipologia: row['Tipo Caixa'] || row['TipoCaixa'] || row['tipologia'],
                                artigo: row['Artigo'] || row['artigo'],
                                caixa: row['Artigo'] || row['Programa ANN'] || row['ProgramaANN'] || row['caixa'],
                                operacao: row['Opera√ß√£o'] || row['Operacao'] || row['operacao'],
                                colaborador: row['Colaborador'] || row['colaborador'],
                                horaInicio: row['Hora In√≠cio'] || row['HoraInicio'] || row['horaInicio'],
                                horaFim: row['Hora Fim'] || row['HoraFim'] || row['horaFim'],
                                duracao: duracao,
                                mesAno: mesAno
                            };
                        }).filter(r => r.operacao);
                        setRegistosOperacoes(ops);
                        console.log('‚úÖ Opera√ß√µes carregadas:', ops.length, 'Exemplo:', ops[0]);
                    }
                    
                    // Processar Perturba√ß√µes
                    if(data.perturbacoes && Array.isArray(data.perturbacoes)) {
                        console.log('üîç Primeira perturba√ß√£o raw:', data.perturbacoes[0]);
                        const pert = data.perturbacoes.map(row => {
                            // Calcular dura√ß√£o a partir do campo Dura√ß√£o (formato "Xh Ymin")
                            let duracao = 0;
                            const duracaoStr = row['Dura√ß√£o'] || row['Duracao'] || row['duracao'] || '';
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            
                            // Converter data Excel para formato dd/mm/yyyy
                            let dataFormatada = '';
                            const dataRaw = row['Data'] || row['data'];
                            if(dataRaw) {
                                if(typeof dataRaw === 'number' || /^\d+$/.test(dataRaw)) {
                                    const excelDate = parseInt(dataRaw);
                                    const jsDate = new Date((excelDate - 25569) * 86400 * 1000);
                                    dataFormatada = jsDate.toLocaleDateString('pt-PT');
                                } else {
                                    dataFormatada = dataRaw;
                                }
                            }
                            
                            // Extrair m√™s/ano
                            let mesAno = '';
                            if(dataFormatada) {
                                const parts = dataFormatada.split('/');
                                if(parts.length >= 3) {
                                    mesAno = parts[1] + '/' + parts[2];
                                }
                            }
                            
                            return {
                                data: dataFormatada,
                                unidadeProducao: row['Unidade Produ√ß√£o'] || row['UnidadeProducao'] || row['Unidade'],
                                tipo: row['Tipo Perturba√ß√£o'] || row['TipoPerturba√ß√£o'] || row['Tipo'] || row['tipo'],
                                descricao: row['Descri√ß√£o'] || row['Descricao'] || row['descricao'] || row['Coment√°rios'],
                                colaborador: row['Colaborador'] || row['colaborador'],
                                duracao: duracao,
                                mesAno: mesAno
                            };
                        }).filter(r => r.tipo);
                        setRegistosPerturbacoes(pert);
                        console.log('‚úÖ Perturba√ß√µes carregadas:', pert.length, 'Exemplo:', pert[0]);
                    }
                    
                    // Processar Encomendas
                    if(data.encomendas && Array.isArray(data.encomendas)) {
                        console.log('üîç Primeira encomenda raw:', data.encomendas[0]);
                        console.log('üîç TODAS as colunas da 1¬™ encomenda:', JSON.stringify(Object.keys(data.encomendas[0])));
                        
                        const enc = data.encomendas.map(row => {
                            const mesEntrega = row['MesEntrega'] || row['M√™s Entrega'] || row['Mes Entrega'];
                            const anoEntrega = row['AnoEntrega'] || row['Ano Entrega'];
                            const mesProducao = row['MesProducao'] || row['M√™s Produ√ß√£o'] || row['Mes Producao'] || row['Mes Produ√ß√£o'];
                            const anoProducao = row['AnoProducao'] || row['Ano Produ√ß√£o'] || row['Ano Producao'];
                            const mesEmbalamento = row['MesEmbalamento'] || row['M√™s Embalamento'] || row['Mes Embalamento'];
                            const anoEmbalamento = row['AnoEmbalamento'] || row['Ano Embalamento'];
                            
                            const buildMesAno = (mes, ano) => {
                                if(!mes || !ano) return '';
                                const mesesNome = {'janeiro':'01','fevereiro':'02','mar√ßo':'03','marco':'03','abril':'04','maio':'05','junho':'06','julho':'07','agosto':'08','setembro':'09','outubro':'10','novembro':'11','dezembro':'12'};
                                let mesStr = mes.toString().toLowerCase().trim();
                                let mesNum = mesesNome[mesStr] || (parseInt(mesStr) > 0 ? parseInt(mesStr).toString().padStart(2,'0') : '');
                                return mesNum ? mesNum + '/' + ano : '';
                            };
                            
                            // Extrair m√™s/ano de uma data raw (n√∫mero Excel ou string dd/mm/yyyy)
                            const mesAnoFromData = (dataRaw) => {
                                if(!dataRaw) return '';
                                const str = dataRaw.toString().trim();
                                if(!str || str === 'NaN' || str === 'nan') return '';
                                // N√∫mero Excel (ex: 46027)
                                if(/^\d{4,5}$/.test(str)) {
                                    const jsDate = new Date((parseInt(str) - 25569) * 86400 * 1000);
                                    if(!isNaN(jsDate.getTime())) {
                                        return (jsDate.getMonth()+1).toString().padStart(2,'0') + '/' + jsDate.getFullYear();
                                    }
                                }
                                // String dd/mm/yyyy ou mm/dd/yyyy
                                const parts = str.split(/[\/\-\.]/);
                                if(parts.length >= 3) {
                                    const d = parseInt(parts[0]), m = parseInt(parts[1]), y = parseInt(parts[2]);
                                    if(y > 2000) return m.toString().padStart(2,'0') + '/' + y;
                                }
                                return '';
                            };
                            
                            let mesAnoEntrega = buildMesAno(mesEntrega, anoEntrega);
                            // Fallback: usar DataEntregaReal se MesEntrega/AnoEntrega est√£o vazios
                            if(!mesAnoEntrega) {
                                mesAnoEntrega = mesAnoFromData(row['DataEntregaReal'] || row['Data Entrega Real'] || row['dataEntregaReal']);
                            }
                            
                            let mesAnoProducao = buildMesAno(mesProducao, anoProducao);
                            if(!mesAnoProducao) {
                                mesAnoProducao = mesAnoFromData(row['DataProducao'] || row['Data Produ√ß√£o'] || row['dataProducao']);
                            }
                            
                            let mesAnoEmbalamento = buildMesAno(mesEmbalamento, anoEmbalamento);
                            if(!mesAnoEmbalamento) {
                                mesAnoEmbalamento = mesAnoFromData(row['DataEmbalamento'] || row['Data Embalamento'] || row['dataEmbalamento']);
                            }
                            
                            // Fatura - procurar em todas as variantes poss√≠veis de nome de coluna
                            const numFaturaRaw = row['N¬∫Fatura'] || row['N¬∫ Fatura'] || row['numFatura'] || row['NumFatura'] || row['N_x00ba_Fatura'] || row['Fatura'] || row['N.¬∫ Fatura'] || row['N¬∫_Fatura'];
                            const numFaturaStr = (numFaturaRaw || '').toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
                            const faturada = isFaturaValida(numFaturaRaw);
                            
                            return {
                                tipologia: row['Tipologia'] || row['tipologia'],
                                caixa: row['Caixa'] || row['caixa'],
                                ligacao: row['Liga√ß√£o'] || row['Ligacao'] || row['ligacao'],
                                po: row['PO'] || row['po'],
                                pos: row['POS'] || row['pos'] || row['Pos'] || '',
                                ecode: row['Ecode'] || row['ecode'],
                                valor: parseFloat(row['Valor'] || row['valor']) || 0,
                                quantidade: parseInt(row['Quantidade'] || row['quantidade']) || 1,
                                qtdEntregue: parseInt(row['QuantidadeEntregue'] || row['Quantidade Entregue'] || row['qtdEntregue']) || 0,
                                faturada,
                                numFatura: numFaturaRaw,
                                localizacao: row['Localiza√ß√£o'] || row['Localizacao'] || row['localizacao'] || row['Local'] || '',
                                mesAnoEntrega,
                                mesAnoProducao,
                                mesAnoEmbalamento,
                                anoEntrega: anoEntrega ? parseInt(anoEntrega) : (mesAnoEntrega ? parseInt(mesAnoEntrega.split('/')[1]) : null),
                                mesEntrega: mesEntrega ? parseInt(mesEntrega) : (mesAnoEntrega ? parseInt(mesAnoEntrega.split('/')[0]) : null),
                                anoProducao: anoProducao ? parseInt(anoProducao) : (mesAnoProducao ? parseInt(mesAnoProducao.split('/')[1]) : null)
                            };
                        }).filter(r => r.tipologia || r.caixa);
                        enc.forEach(e => e._origem = 'terminada');
                        
                        // Debug completo
                        const com2026 = enc.filter(e => e.anoEntrega === 2026);
                        const localizacoes = [...new Set(enc.map(e => e.localizacao).filter(l => l))];
                        const comFatura = enc.filter(e => e.faturada);
                        const comMesEntrega = enc.filter(e => e.mesAnoEntrega);
                        const comMesProd = enc.filter(e => e.mesAnoProducao);
                        const comMesEmb = enc.filter(e => e.mesAnoEmbalamento);
                        console.log('‚úÖ Encomendas carregadas:', enc.length, '| Com 2026:', com2026.length, '| Com fatura:', comFatura.length, '| Sem fatura:', enc.filter(e=>!e.faturada).length, '| Valor faturado:', comFatura.reduce((s,e)=>s+(e.valor||0),0).toFixed(2));
                        // Debug: valores de fatura
                        const valoresNumFatura = [...new Set(enc.map(e => (e.numFatura||'').toString().trim()))];
                        console.log('üìã Valores √öNICOS de NumFatura (' + valoresNumFatura.length + '):', valoresNumFatura.slice(0,30));
                        // Debug: mostrar quais foram aceites e quais rejeitados
                        const rejeitados = enc.filter(e => !e.faturada && e.numFatura);
                        if(rejeitados.length > 0) console.log('‚ö†Ô∏è NumFatura REJEITADOS (n√£o parecem faturas reais):', [...new Set(rejeitados.map(e => (e.numFatura||'').toString().trim()))].slice(0,20));
                        if(comFatura.length > 0) console.log('‚úÖ NumFatura ACEITES:', [...new Set(comFatura.map(e => (e.numFatura||'').toString().trim()))].slice(0,20));
                        console.log('üìÖ Datas: mesEntrega:', comMesEntrega.length, '| mesProducao:', comMesProd.length, '| mesEmbalamento:', comMesEmb.length);
                        console.log('üîç Localiza√ß√µes encontradas:', localizacoes);
                        // Debug: mostrar distribui√ß√£o por m√™s de entrega
                        const distMesEntrega = {};
                        enc.forEach(e => { const m = e.mesAnoEntrega || 'SEM'; distMesEntrega[m] = (distMesEntrega[m]||0)+1; });
                        console.log('üìÖ Distribui√ß√£o por m√™s ENTREGA:', distMesEntrega);
                        // Debug: ver colunas raw relacionadas com data de entrega
                        if(data.encomendas[0]) {
                            const rawKeys = Object.keys(data.encomendas[0]);
                            const dataKeys = rawKeys.filter(k => k.toLowerCase().includes('entrega') || k.toLowerCase().includes('data') || k.toLowerCase().includes('mes') || k.toLowerCase().includes('ano') || k.toLowerCase().includes('semana'));
                            console.log('üîç Colunas RAW com data/entrega/mes/ano:', dataKeys);
                            dataKeys.forEach(k => console.log('   ‚Üí', k, '=', JSON.stringify(data.encomendas[0][k])));
                        }
                        if(enc.length > 0) {
                            console.log('üîç 1¬™ enc:', { numFatura: enc[0].numFatura, faturada: enc[0].faturada, valor: enc[0].valor, mesAnoEntrega: enc[0].mesAnoEntrega, mesAnoProducao: enc[0].mesAnoProducao, mesAnoEmbalamento: enc[0].mesAnoEmbalamento });
                            // Mostrar as 3 √∫ltimas para ver se t√™m datas diferentes
                            const last = enc[enc.length-1];
                            console.log('üîç √öltima enc:', { caixa: last.caixa, mesAnoEntrega: last.mesAnoEntrega, mesAnoProducao: last.mesAnoProducao, mesAnoEmbalamento: last.mesAnoEmbalamento });
                        }
                        
                        setEncomendas(enc);
                    }
                    
                    // Processar Encomendas em Produ√ß√£o (pendentes)
                    if(data.encomendasProducao && Array.isArray(data.encomendasProducao)) {
                        console.log('üîç Primeira encomenda produ√ß√£o raw:', data.encomendasProducao[0]);
                        
                        const encProd = data.encomendasProducao.map(row => {
                            // Nomes com espa√ßos (tabela Encomendas) ou sem (tabela EncomendasTerminadas)
                            const mesProducao = row['M√™s Produ√ß√£o'] || row['MesProdu√ß√£o'] || row['MesProducao'] || row['Mes Producao'];
                            const anoProducao = row['Ano Produ√ß√£o'] || row['AnoProdu√ß√£o'] || row['AnoProducao'] || row['Ano Producao'];
                            const mesEntrega = row['M√™s Entrega'] || row['MesEntrega'] || row['Mes Entrega'];
                            const anoEntrega = row['Ano Entrega'] || row['AnoEntrega'] || row['Ano Entrega'];
                            
                            // Construir mesAnoProducao
                            let mesAnoProducao = '';
                            if(mesProducao && anoProducao && mesProducao !== 'NaN' && anoProducao !== 'NaN') {
                                // M√™s pode vir como "Janeiro", "Fevereiro" ou n√∫mero
                                const mesesNome = {'janeiro':1,'fevereiro':2,'mar√ßo':3,'abril':4,'maio':5,'junho':6,'julho':7,'agosto':8,'setembro':9,'outubro':10,'novembro':11,'dezembro':12};
                                let mesNum = parseInt(mesProducao);
                                if(isNaN(mesNum) && typeof mesProducao === 'string') {
                                    mesNum = mesesNome[mesProducao.toLowerCase()] || 0;
                                }
                                if(mesNum > 0) {
                                    mesAnoProducao = mesNum.toString().padStart(2,'0') + '/' + anoProducao;
                                }
                            }
                            
                            // Construir mesAnoEntrega
                            let mesAnoEntrega = '';
                            if(mesEntrega && anoEntrega) {
                                const mesesNome = {'janeiro':1,'fevereiro':2,'mar√ßo':3,'abril':4,'maio':5,'junho':6,'julho':7,'agosto':8,'setembro':9,'outubro':10,'novembro':11,'dezembro':12};
                                let mesNum = parseInt(mesEntrega);
                                if(isNaN(mesNum) && typeof mesEntrega === 'string') {
                                    mesNum = mesesNome[mesEntrega.toLowerCase()] || 0;
                                }
                                if(mesNum > 0) {
                                    mesAnoEntrega = mesNum.toString().padStart(2,'0') + '/' + anoEntrega;
                                }
                            }
                            
                            return {
                                tipologia: row['Tipologia'] || row['tipologia'],
                                caixa: row['Caixa'] || row['caixa'],
                                ligacao: row['Liga√ß√£o'] || row['Ligacao'] || row['ligacao'],
                                po: row['PO'] || row['po'],
                                pos: row['POS'] || row['pos'] || row['Pos'] || '',
                                ecode: row['Ecode'] || row['ecode'],
                                quantidade: parseInt(row['Quantidade Produzida'] || row['QuantidadeProduzida'] || row['Quantidade'] || row['quantidade']) || 1,
                                qtdProduzida: parseInt(row['Quantidade Produzida'] || row['QuantidadeProduzida']) || 0,
                                qtdEntregue: parseInt(row['Quantidade Entregue'] || row['QuantidadeEntregue']) || 0,
                                estado: row['Estado'] || row['estado'],
                                subEstado: row['SubEstado'] || row['subEstado'],
                                localizacao: row['Localiza√ß√£o'] || row['Localizacao'] || row['localizacao'] || row['Local'] || '',
                                valor: parseFloat(row['Valor'] || row['valor']) || 0,
                                numFatura: row['NumFatura'] || row['N¬∫Fatura'] || row['N¬∫ Fatura'] || row['numFatura'] || row['N_x00ba_Fatura'] || row['Fatura'],
                                faturada: isFaturaValida(row['NumFatura'] || row['N¬∫Fatura'] || row['N¬∫ Fatura'] || row['numFatura'] || row['N_x00ba_Fatura'] || row['Fatura']),
                                mesAnoProducao,
                                mesAnoEntrega,
                                mesAnoEmbalamento: mesAnoProducao, // usar produ√ß√£o como fallback
                                anoProducao: anoProducao ? parseInt(anoProducao) : null,
                                mesProducao: mesProducao,
                                anoEntrega: anoEntrega ? parseInt(anoEntrega) : null,
                                emProducao: true // marcador para distinguir das terminadas
                            };
                        }).filter(r => r.tipologia || r.caixa);
                        // Marcar origem: faturadas vs stock
                        encProd.forEach(e => e._origem = e.faturada ? 'faturada' : 'stock');
                        
                        // Separar pendentes faturadas (n√£o est√£o terminadas mas t√™m fatura)
                        const pendFaturadas = encProd.filter(e => e.faturada);
                        
                        // Separar pendentes em stock (n√£o faturadas mas produzidas/entregues)
                        const pendStock = encProd.filter(e => {
                            if(e.faturada) return false;
                            const estado = (e.estado || '').toLowerCase().trim();
                            const subEstado = (e.subEstado || '').toLowerCase().trim();
                            return subEstado === 'terminada' || 
                                   estado === 'entregue' || 
                                   estado === 'em stock' ||
                                   estado === 'produzida';
                        });
                        
                        console.log('‚úÖ Encomendas em produ√ß√£o carregadas:', encProd.length, '| Faturadas:', pendFaturadas.length, '| Em stock:', pendStock.length, '| Valor fat pendentes:', pendFaturadas.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                        if(encProd.length > 0) {
                            console.log('üîç Primeira enc produ√ß√£o processada:', { 
                                caixa: encProd[0].caixa, 
                                mesAnoProducao: encProd[0].mesAnoProducao,
                                mesAnoEntrega: encProd[0].mesAnoEntrega,
                                anoProducao: encProd[0].anoProducao,
                                quantidade: encProd[0].quantidade,
                                faturada: encProd[0].faturada,
                                numFatura: encProd[0].numFatura
                            });
                        }
                        
                        // Adicionar pendentes faturadas E em stock ao array principal de encomendas
                        setEncomendas(prev => {
                            // Evitar duplicados: PO+POS √© a chave √∫nica de uma encomenda
                            const idsTerminadas = new Set(prev.map(e => String(e.po||'').trim()+'|'+String(e.pos||'').trim()));
                            const novasFaturadas = pendFaturadas.filter(e => {
                                const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                return !idsTerminadas.has(id);
                            });
                            const novosStock = pendStock.filter(e => {
                                const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                return !idsTerminadas.has(id);
                            });
                            console.log('üìã Adicionando', novasFaturadas.length, 'pendentes faturadas +', novosStock.length, 'em stock ao array principal');
                            if(pendFaturadas.length > novasFaturadas.length) {
                                const dupl = pendFaturadas.filter(e => {
                                    const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                    return idsTerminadas.has(id);
                                });
                                console.log('‚ö†Ô∏è Duplicadas faturadas (mesmo PO+POS j√° nas terminadas):', dupl.map(e => ({caixa:e.caixa, po:e.po, pos:e.pos, numFatura:e.numFatura})));
                            }
                            return [...prev, ...novasFaturadas, ...novosStock];
                        });
                        
                        // Guardar separadamente - s√≥ para c√°lculo de OEE
                        setEncomendasProducao(encProd);
                    }
                    
                    // Processar Objetivos por Opera√ß√£o
                    if(data.objetivosOperacao && Array.isArray(data.objetivosOperacao)) {
                        console.log('üîç Primeiro objetivo opera√ß√£o raw:', data.objetivosOperacao[0]);
                        const objs = {};
                        data.objetivosOperacao.forEach(row => {
                            const operacao = row['Opera√ß√£o'] || row['Operacao'] || row['operacao'];
                            const tempo = row['Tempo Objetivo'] || row['TempoObjetivo'] || row['tempoObjetivo'] || row['Tempo'];
                            if(operacao && tempo) {
                                // Tempo vem em fra√ß√£o de dia (Excel time format)
                                // Ex: 0.5 = 12 horas = 720 minutos
                                // Ex: 0.041666... = 1 hora = 60 minutos
                                let mins = 0;
                                const tempoNum = parseFloat(tempo);
                                if(!isNaN(tempoNum)) {
                                    mins = Math.round(tempoNum * 24 * 60); // dias para minutos
                                }
                                if(mins > 0) objs[operacao] = mins;
                            }
                        });
                        setObjetivos(prev => ({...prev, ...objs}));
                        console.log('‚úÖ Objetivos opera√ß√£o carregados:', Object.keys(objs).length, 'Exemplo:', Object.entries(objs).slice(0,3));
                    }
                    
                    // Processar Objetivos por Tipologia
                    if(data.objetivosTipologia && Array.isArray(data.objetivosTipologia)) {
                        console.log('üîç Primeiro objetivo tipologia raw:', data.objetivosTipologia[0]);
                        const objsTip = {};
                        data.objetivosTipologia.forEach(row => {
                            const tipologia = row['Tipologia'] || row['tipologia'];
                            const tempo = row['Tempo Objetivo'] || row['TempoObjetivo'] || row['tempoObjetivo'] || row['Tempo'];
                            if(tipologia && tempo) {
                                // Tempo vem em fra√ß√£o de dia (Excel time format)
                                // Ex: 1.215... = ~29 horas = ~1750 minutos
                                let mins = 0;
                                const tempoNum = parseFloat(tempo);
                                if(!isNaN(tempoNum)) {
                                    mins = Math.round(tempoNum * 24 * 60); // dias para minutos
                                }
                                if(mins > 0) objsTip[tipologia] = mins;
                            }
                        });
                        setObjetivosTipologia(prev => ({...prev, ...objsTip}));
                        console.log('‚úÖ Objetivos tipologia carregados:', Object.keys(objsTip).length, 'Exemplo:', Object.entries(objsTip).slice(0,3));
                    }
                    
                    // Processar Mapa de Horas (Tempo Dispon√≠vel)
                    if(data.mapaHoras && Array.isArray(data.mapaHoras)) {
                        console.log('üîç Primeiro mapa horas raw:', data.mapaHoras[0]);
                        const mapa = {};
                        data.mapaHoras.forEach(row => {
                            const mesRaw = row['Mes'] || row['mes'] || row['M√™s'] || '';
                            const total = parseFloat(row['Total'] || row['total'] || row['TotalHoras'] || 0);
                            if(mesRaw && total > 0) {
                                // Converter formato "2026-01" para "01/2026"
                                let mesAno = mesRaw;
                                if(mesRaw.includes('-')) {
                                    const parts = mesRaw.split('-');
                                    mesAno = parts[1] + '/' + parts[0]; // "01/2026"
                                }
                                if(!mapa[mesAno]) mapa[mesAno] = 0;
                                mapa[mesAno] += Math.round(total * 60); // horas para minutos
                            }
                        });
                        setMapaHoras(prev => ({...prev, ...mapa}));
                        console.log('‚úÖ Mapa Horas carregado:', mapa);
                    }
                    
                    setLastUpdate(new Date());
                    showMsg('‚úÖ Dados carregados com sucesso!', 'success');
                    
                } catch(err) {
                    console.error('‚ùå Erro ao carregar dados:', err);
                    showMsg('‚ùå Erro ao carregar: ' + err.message, 'error');
                } finally {
                    setIsLoading(false);
                }
            };
            
            // Estado para configura√ß√£o
            const [showConfig, setShowConfig] = useState(false);
            
            // Guardar URL
            useEffect(() => {
                try {
                    if(urlPowerAutomate) localStorage.setItem('kpi_url_powerautomate', urlPowerAutomate);
                } catch(e) {}
            }, [urlPowerAutomate]);
            
            // Carregar dados automaticamente ao iniciar (se URL configurado)
            useEffect(() => {
                console.log('üöÄ App iniciada, URL:', urlPowerAutomate ? 'configurado' : 'vazio');
                if(urlPowerAutomate) {
                    console.log('üîÑ A iniciar carregamento autom√°tico...');
                    carregarDadosPowerAutomate();
                }
            }, []);
            
            // Importar Registos Produ√ß√£o √âvora (ficheiro com 2 folhas: Produ√ß√£o + Perturba√ß√µes)
            const importRegistosProducao = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('‚è≥ A processar registos de produ√ß√£o...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Processar folha Produ√ß√£o (Opera√ß√µes)
                    const sheetProd = wb.Sheets['Produ√ß√£o'] || wb.Sheets['Producao'] || wb.Sheets[wb.SheetNames[0]];
                    const dataProd = XLSX.utils.sheet_to_json(sheetProd, {defval:''});
                    
                    const operacoes = dataProd.map(row => {
                        const operacao = findValue(row, ['Opera√ß√£o','operacao','OPERA√á√ÉO','Op']);
                        const tipologia = findValue(row, ['Tipo Caixa','TipoCaixa','Tipologia','tipologia']);
                        const artigo = findValue(row, ['Artigo','artigo']);
                        const colaborador = findValue(row, ['Colaborador','colaborador']);
                        const unidadeProducao = findValue(row, ['Unidade Produ√ß√£o','UnidadeProducao','unidadeProducao','Unidade']);
                        const dtRaw = findValue(row, ['Data','data']);
                        const dt = typeof dtRaw === 'string' && dtRaw.includes('-') 
                            ? dtRaw.split('-').reverse().join('/').substring(0,10).split('/').map((p,i)=>i<2?p.padStart(2,'0'):p).join('/')
                            : parseExcelDate(dtRaw);
                        const inicio = findValue(row, ['Hora In√≠cio','horaInicio','In√≠cio']);
                        const fim = findValue(row, ['Hora Fim','horaFim','Fim']);
                        const duracaoStr = findValue(row, ['Dura√ß√£o','duracao']);
                        let duracao = 0;
                        if(duracaoStr) {
                            const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                            if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                        }
                        if(duracao===0) duracao = calcDuracao(inicio, fim);
                        const quantidade = parseFloat(findValue(row, ['Quantidade','quantidade','Qtd']))||0;
                        return { operacao, tipologia, artigo, colaborador, unidadeProducao, data:dt, inicio, fim, duracao, quantidade, mesAno:getMesAno(dt) };
                    }).filter(r => r.operacao && r.data);
                    
                    // Processar folha Perturba√ß√µes
                    const sheetPert = wb.Sheets['Perturba√ß√µes'] || wb.Sheets['Perturbacoes'];
                    let perturbacoes = [];
                    if(sheetPert) {
                        const dataPert = XLSX.utils.sheet_to_json(sheetPert, {defval:''});
                        perturbacoes = dataPert.map(row => {
                            const tipo = findValue(row, ['Tipo Perturba√ß√£o','TipoPerturbacao','Tipo','tipo','Perturba√ß√£o']);
                            const colaborador = findValue(row, ['Colaborador','colaborador']);
                            const dtRaw = findValue(row, ['Data','data']);
                            const dt = typeof dtRaw === 'string' && dtRaw.includes('-') 
                                ? dtRaw.split('-').reverse().join('/').substring(0,10).split('/').map((p,i)=>i<2?p.padStart(2,'0'):p).join('/')
                                : parseExcelDate(dtRaw);
                            const inicio = findValue(row, ['Hora In√≠cio','horaInicio','In√≠cio']);
                            const fim = findValue(row, ['Hora Fim','horaFim','Fim']);
                            const duracaoStr = findValue(row, ['Dura√ß√£o','duracao']);
                            let duracao = 0;
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            if(duracao===0) duracao = calcDuracao(inicio, fim);
                            return { tipo, colaborador, data:dt, inicio, fim, duracao, mesAno:getMesAno(dt) };
                        }).filter(r => r.tipo && r.data);
                    }
                    
                    // Tamb√©m extrair produ√ß√£o agregada por tipologia
                    const producaoAgg = {};
                    operacoes.forEach(r => {
                        const key = r.data + '|' + r.tipologia;
                        if(!producaoAgg[key]) producaoAgg[key] = { data:r.data, tipologia:r.tipologia, quantidade:0, tempoOperacoes:0, mesAno:r.mesAno };
                        producaoAgg[key].quantidade += r.quantidade || 0;
                        producaoAgg[key].tempoOperacoes += r.duracao;
                    });
                    const producao = Object.values(producaoAgg);
                    
                    setRegistosOperacoes(operacoes);
                    setRegistosPerturbacoes(perturbacoes);
                    setRegistosProducao(producao);
                    
                    showMsg(`‚úÖ Importado: ${operacoes.length} opera√ß√µes + ${perturbacoes.length} perturba√ß√µes!`,'success');
                } catch(err) { showMsg('‚ùå Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            const importEncomendas = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('‚è≥ A processar encomendas...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Fun√ß√£o para processar uma folha de encomendas
                    const processarFolha = (sheetName) => {
                        if(!wb.SheetNames.includes(sheetName)) return [];
                        const data = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {defval:'', raw:false});
                        console.log('üì• A processar folha:', sheetName, '- Linhas:', data.length);
                        
                        return data.map(row => {
                            const tipologia = findValue(row, ['Tipologia','tipologia','TIPOLOGIA','Tipo']);
                            const caixa = findValue(row, ['Caixa','caixa','CAIXA','TipoCaixa']);
                            const ligacao = findValue(row, ['Ligacao','Liga√ß√£o','ligacao','TipoCaixa']);
                            const po = findValue(row, ['PO','po','Encomenda']);
                            const pos = findValue(row, ['POS','pos','Pos','Position']);
                            const ecode = findValue(row, ['Ecode','ecode','ECODE','ECode','C√≥digo']);
                            
                            // Datas - converter formato ISO ou serial Excel
                            const parseData = (val) => {
                                if(!val) return '';
                                const v = val.toString().trim();
                                if(v.includes('T') || v.match(/^\d{4}-\d{2}-\d{2}/)) {
                                    const parts = v.split('T')[0].split('-');
                                    if(parts.length === 3) return parts[2] + '/' + parts[1] + '/' + parts[0];
                                }
                                if(v.includes('/')) return v;
                                return parseExcelDate(val);
                            };
                            
                            const dataEncomenda = parseData(findValue(row, ['DataEncomenda','Data Encomenda','dataEncomenda']));
                            const dataEntregaPrevista = parseData(findValue(row, ['DataEntregaPrevista','Data Entrega Prevista','dataEntregaPrevista']));
                            const dataProducao = parseData(findValue(row, ['DataProducao','Data Produ√ß√£o','dataProducao']));
                            const dataEntregaReal = parseData(findValue(row, ['DataEntregaReal','Data Entrega Real','dataEntregaReal']));
                            const dataEmbalamento = parseData(findValue(row, ['DataEmbalamento','Data Embalamento','dataEmbalamento']));
                            
                            // Quantidades
                            const quantidade = parseFloat(findValue(row, ['QuantidadeProduzida','Quantidade Produzida','Quantidade','quantidade']))||1;
                            const qtdEntregue = parseFloat(findValue(row, ['QuantidadeEntregue','Quantidade Entregue','qtdEntregue']))||0;
                            const qtdEmbalada = parseFloat(findValue(row, ['QuantidadeEmbalada','Quantidade Embalada','qtdEmbalada']))||0;
                            
                            // Valor e Fatura
                            const valorRaw = findValue(row, [' Valor ', 'Valor', ' Valor', 'Valor ', 'valor', 'VALOR', 'Pre√ßo']);
                            let valor = 0;
                            if(valorRaw !== undefined && valorRaw !== null && valorRaw !== '') {
                                const valorStr = String(valorRaw).replace(/‚Ç¨/g, '').replace(/\s/g, '').replace(/,/g, '');
                                valor = parseFloat(valorStr) || 0;
                            }
                            const numFatura = findValue(row, ['NumFatura','N¬∫Fatura','N¬∫ Fatura','numFatura','N_x00ba_Fatura','Fatura']);
                            const estadoFinal = findValue(row, ['EstadoFinal','Estado Final','estadoFinal']);
                            const estado = findValue(row, ['Estado','estado']);
                            const subEstado = findValue(row, ['SubEstado','Sub Estado','subEstado']);
                            
                            const numFaturaStr = (numFatura || '').toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
                            const faturada = isFaturaValida(numFatura);
                            
                            // M√™s/Ano para agrupamento
                            const mesProducao = findValue(row, ['MesProducao','M√™s Produ√ß√£o','mesProducao']);
                            const anoProducao = findValue(row, ['AnoProducao','Ano Produ√ß√£o','anoProducao']);
                            const mesEntrega = findValue(row, ['MesEntrega','M√™s Entrega','mesEntrega']);
                            const anoEntrega = findValue(row, ['AnoEntrega','Ano Entrega','anoEntrega']);
                            const mesEmbalamento = findValue(row, ['MesEmbalamento','M√™s Embalamento','mesEmbalamento']);
                            const anoEmbalamento = findValue(row, ['AnoEmbalamento','Ano Embalamento','anoEmbalamento']);
                            
                            const getMesAnoFromParts = (mes, ano) => {
                                if(!mes || !ano || mes === 'sem data') return '';
                                const mesesMap = {'janeiro':'01','fevereiro':'02','mar√ßo':'03','marco':'03','abril':'04','maio':'05','junho':'06','julho':'07','agosto':'08','setembro':'09','outubro':'10','novembro':'11','dezembro':'12'};
                                const mesNum = mesesMap[mes.toString().toLowerCase()] || mes.toString().padStart(2,'0');
                                return mesNum + '/' + ano;
                            };
                            
                            return { 
                                tipologia, caixa, ligacao, po, pos, ecode, estado, subEstado,
                                dataEncomenda, dataEntregaPrevista, dataProducao, dataEntregaReal, dataEmbalamento,
                                quantidade, qtdEntregue, qtdEmbalada,
                                valor, numFatura, estadoFinal, faturada,
                                mesAnoProducao: getMesAnoFromParts(mesProducao, anoProducao) || getMesAno(dataProducao),
                                mesAnoEntrega: getMesAnoFromParts(mesEntrega, anoEntrega) || getMesAno(dataEntregaReal),
                                mesAnoEmbalamento: getMesAnoFromParts(mesEmbalamento, anoEmbalamento) || getMesAno(dataEmbalamento)
                            };
                        }).filter(r => r.tipologia || r.caixa);
                    };
                    
                    // Processar folha EncomendasTerminadas
                    const terminadas = processarFolha('EncomendasTerminadas');
                    terminadas.forEach(e => e._origem = 'terminada');
                    // Debug: ver colunas raw da folha EncomendasTerminadas
                    if(data.EncomendasTerminadas && data.EncomendasTerminadas[0]) {
                        const rawKeys = Object.keys(data.EncomendasTerminadas[0]);
                        const fatKeys = rawKeys.filter(k => k.toLowerCase().includes('fat') || k.toLowerCase().includes('fatura') || k.toLowerCase().includes('invoice'));
                        console.log('üîç EncomendasTerminadas - Colunas fatura:', fatKeys);
                        fatKeys.forEach(k => {
                            const vals = data.EncomendasTerminadas.slice(0,5).map(r => JSON.stringify(r[k]));
                            console.log('   ‚Üí', k, ':', vals.join(', '));
                        });
                        // Mostrar TODOS os valores √∫nicos da coluna NumFatura
                        const numFatKey = fatKeys.find(k => k.includes('NumFat') || k === 'NumFatura') || fatKeys[0];
                        if(numFatKey) {
                            const valsUnicos = [...new Set(data.EncomendasTerminadas.map(r => JSON.stringify(r[numFatKey])))];
                            console.log('üìã Valores √∫nicos de', numFatKey, '(' + valsUnicos.length + '):', valsUnicos.slice(0,30));
                        }
                    }
                    const termComFatura = terminadas.filter(e => e.faturada);
                    const termSemFatura = terminadas.filter(e => !e.faturada);
                    console.log('üìã Terminadas:', terminadas.length, '| Com fatura:', termComFatura.length, '| Sem fatura:', termSemFatura.length, '| Valor faturado terminadas:', termComFatura.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                    if(termComFatura.length > 0) console.log('üîç Exemplos faturadas:', termComFatura.slice(0,3).map(e => ({caixa:e.caixa, numFatura:e.numFatura, numFaturaType:typeof e.numFatura, numFaturaLen: (e.numFatura||'').toString().length, valor:e.valor})));
                    if(termSemFatura.length > 0) console.log('üîç Exemplos N√ÉO faturadas:', termSemFatura.slice(0,3).map(e => ({caixa:e.caixa, numFatura:e.numFatura, numFaturaRaw:JSON.stringify(e.numFatura), valor:e.valor})));
                    const faturasUnicas = [...new Set(terminadas.map(e => (e.numFatura||'').toString().trim()))].filter(f => f);
                    console.log('üìã Faturas √∫nicas EncomendasTerminadas (' + faturasUnicas.length + '):', faturasUnicas.slice(0,20));
                    
                    // Processar folha Encomendas (pendentes) - apenas as produzidas/em stock
                    let pendentes = processarFolha('Encomendas');
                    
                    // Separar faturadas de n√£o-faturadas primeiro
                    const pendentesFaturadas = pendentes.filter(e => e.faturada);
                    pendentesFaturadas.forEach(e => e._origem = 'faturada');
                    
                    // N√£o-faturadas: filtrar apenas as que est√£o produzidas (SubEstado = terminada, ou Estado = entregue/em stock)
                    const pendentesProducidas = pendentes.filter(e => {
                        if(e.faturada) return false; // faturadas j√° foram tratadas acima
                        const subEstado = (e.subEstado || '').toString().toLowerCase().trim();
                        const estado = (e.estado || '').toString().toLowerCase().trim();
                        const estadoFinal = (e.estadoFinal || '').toString().toLowerCase().trim();
                        return subEstado === 'terminada' || 
                               estado === 'entregue' || 
                               estado === 'em stock' ||
                               estado === 'produzida' ||
                               estadoFinal.includes('embalada') ||
                               estadoFinal.includes('fornecido') ||
                               estadoFinal.includes('terminada');
                    });
                    pendentesProducidas.forEach(e => e._origem = 'stock');
                    
                    // Evitar duplicados: PO+POS √© a chave √∫nica de uma encomenda
                    const idsTerminadas = new Set(terminadas.map(e => String(e.po||'').trim()+'|'+String(e.pos||'').trim()));
                    const novasFaturadas = pendentesFaturadas.filter(e => {
                        const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                        return !idsTerminadas.has(id);
                    });
                    
                    console.log('üì¶ Pendentes total:', pendentes.length, '| Produzidas/Stock (n√£o fat):', pendentesProducidas.length, '| Faturadas pendentes:', pendentesFaturadas.length, '| Novas faturadas (sem duplicados por PO+POS):', novasFaturadas.length);
                    console.log('üìã Valor faturado pendentes:', pendentesFaturadas.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                    if(pendentesFaturadas.length > novasFaturadas.length) {
                        const duplicadas = pendentesFaturadas.filter(e => {
                            const id = (e.po||'')+'|'+(e.pos||'');
                            return idsTerminadas.has(id);
                        });
                        console.log('‚ö†Ô∏è Faturadas duplicadas (mesmo PO+POS j√° em terminadas):', duplicadas.map(e => ({caixa: e.caixa, po: e.po, pos: e.pos, numFatura: e.numFatura, valor: e.valor})));
                    }
                    
                    // Combinar terminadas + pendentes produzidas + faturadas n√£o terminadas
                    const todasEncomendas = [...terminadas, ...pendentesProducidas, ...novasFaturadas];
                    
                    console.log('‚úÖ Terminadas:', terminadas.length, '| Stock:', pendentesProducidas.length, '| Faturadas novas:', novasFaturadas.length, '| Total:', todasEncomendas.length);
                    console.log('üí∞ Total faturadas no sistema:', terminadas.filter(e=>e.faturada).length + novasFaturadas.length, '(', terminadas.filter(e=>e.faturada).length, 'terminadas +', novasFaturadas.length, 'pendentes)');
                    
                    setEncomendas(todasEncomendas);
                    
                    // Criar mapeamento Caixa ‚Üí Ecode para usar na an√°lise
                    const newMapCaixaEcode = {};
                    todasEncomendas.forEach(e => {
                        if(e.caixa && e.ecode) newMapCaixaEcode[e.caixa] = e.ecode;
                    });
                    setMapCaixaEcode(newMapCaixaEcode);
                    localStorage.setItem('kpi_mapCaixaEcode', JSON.stringify(newMapCaixaEcode));
                    
                    // Debug - mostrar exemplo com valores
                    const comValor = todasEncomendas.filter(e => e.valor > 0);
                    console.log('üìä Com valor > 0:', comValor.length);
                    console.log('üí∞ Valor total:', todasEncomendas.reduce((s,e) => s + e.valor, 0));
                    console.log('üó∫Ô∏è Mapeamento Caixa‚ÜíEcode:', Object.keys(newMapCaixaEcode).length, 'entradas');
                    
                    showMsg(`‚úÖ ${terminadas.length} terminadas + ${pendentesProducidas.length} em stock + ${novasFaturadas.length} faturadas = ${todasEncomendas.length} encomendas!`,'success');
                } catch(err) { showMsg('‚ùå Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            // Importar Mapa de Horas (Tempo Dispon√≠vel)
            const importMapaHoras = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('‚è≥ A processar mapa de horas...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Procurar folha MapaHoras
                    const sheetName = wb.SheetNames.find(n => n.toLowerCase().includes('mapahoras') || n.toLowerCase().includes('mapa')) || wb.SheetNames[0];
                    const data = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {defval:'', raw:true});
                    
                    const mapa = {};
                    data.forEach(row => {
                        const mesRaw = row['Mes'] || row['mes'] || row['M√™s'] || row['B'] || '';
                        const totalRaw = row['Total'] || row['total'] || row['TotalHoras'] || row['AH'] || 0;
                        const total = parseFloat(totalRaw) || 0;
                        
                        if(mesRaw && total > 0) {
                            // Converter formato "2026-01" para "01/2026"
                            let mesAno = mesRaw.toString();
                            if(mesAno.includes('-')) {
                                const parts = mesAno.split('-');
                                mesAno = parts[1] + '/' + parts[0];
                            }
                            if(!mapa[mesAno]) mapa[mesAno] = 0;
                            mapa[mesAno] += Math.round(total * 60); // horas para minutos
                        }
                    });
                    
                    if(Object.keys(mapa).length > 0) {
                        setMapaHoras(prev => ({...prev, ...mapa}));
                        localStorage.setItem('kpi_mapaHoras', JSON.stringify({...mapaHoras, ...mapa}));
                    }
                    
                    const resumo = Object.entries(mapa).map(([mes, mins]) => `${mes}: ${(mins/60).toFixed(0)}h`).join(', ');
                    showMsg(`‚úÖ Mapa de Horas importado: ${resumo}`,'success');
                    console.log('‚úÖ Mapa Horas importado:', mapa);
                } catch(err) { showMsg('‚ùå Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            const importObjetivos = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('‚è≥ A processar objetivos...','info');
                try {
                    const data = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { const wb=XLSX.read(new Uint8Array(e.target.result),{type:'array'}); res(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]],{defval:'',raw:false})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Fun√ß√£o para converter tempo para minutos
                    const parseTempoParaMinutos = (tempo) => {
                        if(!tempo) return 0;
                        const t = tempo.toString().trim();
                        
                        // Formato "X days HH:MM:SS" (ex: "1 days 05:10:00")
                        const matchDays = t.match(/(\d+)\s*days?\s*(\d{1,2}):(\d{2})/i);
                        if(matchDays) {
                            const dias = parseInt(matchDays[1]) || 0;
                            const horas = parseInt(matchDays[2]) || 0;
                            const mins = parseInt(matchDays[3]) || 0;
                            return (dias * 24 * 60) + (horas * 60) + mins;
                        }
                        
                        // Formato "HH:MM:SS" ou "HH:MM"
                        const matchTime = t.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
                        if(matchTime) {
                            const horas = parseInt(matchTime[1]) || 0;
                            const mins = parseInt(matchTime[2]) || 0;
                            return (horas * 60) + mins;
                        }
                        
                        // Se for n√∫mero (minutos diretos)
                        const num = parseFloat(t);
                        if(!isNaN(num)) return num;
                        
                        return 0;
                    };
                    
                    const objs = {};
                    const objsTipo = {};
                    
                    data.forEach(row => {
                        // Objetivos por opera√ß√£o - normalizar nome
                        const operacaoRaw = findValue(row, ['Opera√ß√£o','operacao','OPERA√á√ÉO','Op']);
                        const operacao = normalizarOperacao(operacaoRaw);
                        const tempoOp = findValue(row, ['Tempo Objetivo','TempoObjetivo','Tempo','tempo','Objetivo','objetivo','Minutos']);
                        if(operacao && tempoOp) {
                            const mins = parseTempoParaMinutos(tempoOp);
                            if(mins > 0) {
                                objs[operacao] = mins;
                                // Tamb√©m guardar com nome original para compatibilidade
                                if(operacaoRaw !== operacao) objs[operacaoRaw] = mins;
                            }
                        }
                        
                        // Objetivos por tipologia
                        const tipologia = findValue(row, ['Tipologia','tipologia','TIPOLOGIA']);
                        const tempoTipo = findValue(row, ['Tempo Objetivo','TempoObjetivo','Tempo Tipologia','Tempo','tempo']);
                        if(tipologia && tempoTipo) {
                            const mins = parseTempoParaMinutos(tempoTipo);
                            if(mins > 0) objsTipo[tipologia] = mins;
                        }
                    });
                    
                    // Guardar os que foram encontrados
                    if(Object.keys(objs).length > 0) {
                        setObjetivos(prev => ({...prev, ...objs}));
                        localStorage.setItem('kpi_objetivos', JSON.stringify({...objetivos, ...objs}));
                    }
                    if(Object.keys(objsTipo).length > 0) {
                        setObjetivosTipologia(prev => ({...prev, ...objsTipo}));
                        localStorage.setItem('kpi_objetivosTipologia', JSON.stringify({...objetivosTipologia, ...objsTipo}));
                    }
                    
                    const totalOps = Object.keys(objs).length;
                    const totalTipo = Object.keys(objsTipo).length;
                    showMsg(`‚úÖ Importado: ${totalOps > 0 ? totalOps + ' opera√ß√µes' : ''}${totalOps > 0 && totalTipo > 0 ? ' + ' : ''}${totalTipo > 0 ? totalTipo + ' tipologias' : ''}!`,'success');
                } catch(err) { showMsg('‚ùå Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            useEffect(() => { 
                try { 
                    const s=localStorage.getItem('kpi_objetivos'); if(s) setObjetivos(JSON.parse(s)); 
                    const st=localStorage.getItem('kpi_objetivosTipologia'); if(st) setObjetivosTipologia(JSON.parse(st));
                    const sm=localStorage.getItem('kpi_mapCaixaEcode'); if(sm) setMapCaixaEcode(JSON.parse(sm));
                    const mh=localStorage.getItem('kpi_mapaHoras'); if(mh) setMapaHoras(JSON.parse(mh));
                } catch(e){} 
            }, []);
            
            const kpis = useMemo(() => {
                let encFiltradas = encomendas;
                let opsFiltradas = registosOperacoes;
                let pertFiltradas = registosPerturbacoes;
                
                // Fun√ß√£o para extrair ano de mesAno (formato "MM/YYYY")
                const getAno = (mesAno) => {
                    if(!mesAno) return '';
                    const parts = mesAno.split('/');
                    return parts.length === 2 ? parts[1] : '';
                };
                
                // Filtro por ano (aplicado primeiro) - prioridade: entrega > embalamento > produ√ß√£o
                if(filtroAno) {
                    const antesAno = encFiltradas.length;
                    const fatAntesAno = encFiltradas.filter(e => e.faturada).length;
                    encFiltradas = encomendas.filter(e => {
                        const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                        // Se n√£o tem data mas tem fatura, incluir (n√£o excluir faturadas sem data)
                        if(!ano && e.faturada) return true;
                        return ano === filtroAno;
                    });
                    const fatDepoisAno = encFiltradas.filter(e => e.faturada).length;
                    console.log(`üîç Filtro ano ${filtroAno}: ${antesAno} ‚Üí ${encFiltradas.length} encomendas | Faturadas: ${fatAntesAno} ‚Üí ${fatDepoisAno}`);
                    // Debug: mostrar encomendas faturadas que foram exclu√≠das pelo filtro
                    if(fatAntesAno > fatDepoisAno) {
                        const excluidas = encomendas.filter(e => e.faturada && !encFiltradas.includes(e));
                        console.log('‚ö†Ô∏è Faturadas exclu√≠das pelo filtro ano:', excluidas.map(e => ({caixa: e.caixa, mesAnoEntrega: e.mesAnoEntrega, mesAnoEmbalamento: e.mesAnoEmbalamento, mesAnoProducao: e.mesAnoProducao, origem: e._origem, valor: e.valor})));
                    }
                    opsFiltradas = registosOperacoes.filter(r => getAno(r.mesAno) === filtroAno);
                    pertFiltradas = registosPerturbacoes.filter(r => getAno(r.mesAno) === filtroAno);
                }
                
                // Filtro por m√™s
                if(filtroMes) {
                    const antesMes = encFiltradas.length;
                    const fatAntesMes = encFiltradas.filter(e => e.faturada).length;
                    encFiltradas = encFiltradas.filter(e => {
                        const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                        // Se n√£o tem data de refer√™ncia mas tem fatura, incluir (n√£o excluir faturadas sem data)
                        if(!mesRef && e.faturada) return true;
                        return mesRef === filtroMes;
                    });
                    const fatDepoisMes = encFiltradas.filter(e => e.faturada).length;
                    console.log(`üîç Filtro m√™s ${filtroMes}: ${antesMes} ‚Üí ${encFiltradas.length} encomendas | Faturadas: ${fatAntesMes} ‚Üí ${fatDepoisMes}`);
                    // Debug: mostrar encomendas faturadas que foram exclu√≠das pelo filtro de m√™s
                    if(fatAntesMes > fatDepoisMes) {
                        const todasAno = encomendas.filter(e => {
                            const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                            return ano === (filtroAno || ano);
                        });
                        const excluidas = todasAno.filter(e => e.faturada).filter(e => {
                            const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                            return mesRef !== filtroMes;
                        });
                        console.log('‚ö†Ô∏è Faturadas exclu√≠das pelo filtro m√™s:', excluidas.map(e => ({caixa: e.caixa, mesAnoEntrega: e.mesAnoEntrega, mesAnoEmbalamento: e.mesAnoEmbalamento, mesAnoProducao: e.mesAnoProducao, mesRef: e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao, origem: e._origem, valor: e.valor})));
                    }
                    if(antesMes > 0 && encFiltradas.length < antesMes) {
                        const filtradas = encomendas.filter(e => {
                            const ano = getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoEntrega) || getAno(e.mesAnoProducao);
                            return ano === (filtroAno || ano);
                        }).filter(e => {
                            const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                            return mesRef !== filtroMes;
                        });
                        if(filtradas.length > 0) console.log('üîç Exemplo exclu√≠da pelo filtro m√™s:', { caixa: filtradas[0].caixa, mesAnoEntrega: filtradas[0].mesAnoEntrega, mesAnoProducao: filtradas[0].mesAnoProducao, mesAnoEmbalamento: filtradas[0].mesAnoEmbalamento, faturada: filtradas[0].faturada, origem: filtradas[0]._origem });
                    }
                    opsFiltradas = opsFiltradas.filter(r => r.mesAno===filtroMes);
                    pertFiltradas = pertFiltradas.filter(r => r.mesAno===filtroMes);
                }
                
                // Filtro por tipologia (com mapeamento entre encomendas e registos)
                if(filtroTipologia) {
                    // Mapeamento de tipologias equivalentes
                    const tipologiasEquivalentes = {
                        'Frac': ['Frac', 'E2-Frac', 'E1'],
                        'E2-Frac': ['Frac', 'E2-Frac'],
                        'E1': ['Frac', 'E1'],
                        'E2': ['E2'],
                        'Praetor': ['Praetor'],
                        'KC390': ['KC390'],
                        'Transporte': ['Transporte'],
                        'Maquinacao': ['Maquinacao', 'Frac']
                    };
                    const tiposValidos = tipologiasEquivalentes[filtroTipologia] || [filtroTipologia];
                    encFiltradas = encFiltradas.filter(e => tiposValidos.includes(e.tipologia));
                    opsFiltradas = opsFiltradas.filter(r => tiposValidos.includes(r.tipologia));
                }
                
                // === KPIs de Encomendas Terminadas ===
                const totalEncomendas = encFiltradas.length;
                const encFaturadas = encFiltradas.filter(e => e.faturada);
                const encNaoFaturadas = encFiltradas.filter(e => !e.faturada);
                const taxaFaturacao = totalEncomendas > 0 ? (encFaturadas.length / totalEncomendas) * 100 : 0;
                
                // Valores
                const valorTotal = encFiltradas.reduce((s,e) => s + (e.valor || 0), 0);
                const valorFaturado = encFaturadas.reduce((s,e) => s + (e.valor || 0), 0);
                const valorPorFaturar = encNaoFaturadas.reduce((s,e) => s + (e.valor || 0), 0);
                
                // Totais ANUAIS (sem filtro de m√™s) para refer√™ncia
                const encAnuais = filtroAno ? encomendas.filter(e => {
                    const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                    return ano === filtroAno || (!ano && e.faturada);
                }) : encomendas;
                const totalFaturadasAnual = encAnuais.filter(e => e.faturada).length;
                const valorFaturadoAnual = encAnuais.filter(e => e.faturada).reduce((s,e) => s + (e.valor || 0), 0);
                const totalEncAnual = encAnuais.length;
                
                console.log('üí∞ KPIs Financeiros (filtrados):', { 
                    totalEnc: totalEncomendas, faturadas: encFaturadas.length, naoFaturadas: encNaoFaturadas.length,
                    valorTotal: valorTotal.toFixed(2), valorFaturado: valorFaturado.toFixed(2), valorPorFaturar: valorPorFaturar.toFixed(2)
                });
                console.log('üí∞ KPIs Financeiros (anuais):', { 
                    totalEncAnual, totalFaturadasAnual, valorFaturadoAnual: valorFaturadoAnual.toFixed(2)
                });
                
                // Valores por Localiza√ß√£o (ANN Comp√≥sitos vs ANN Met√°licos)
                const valorPorLocalizacao = {};
                encFiltradas.forEach(e => {
                    const loc = e.localizacao || 'Sem Localiza√ß√£o';
                    if(!valorPorLocalizacao[loc]) valorPorLocalizacao[loc] = { total: 0, faturado: 0, porFaturar: 0, quantidade: 0 };
                    valorPorLocalizacao[loc].total += e.valor || 0;
                    valorPorLocalizacao[loc].quantidade += e.quantidade || 1;
                    if(e.faturada) {
                        valorPorLocalizacao[loc].faturado += e.valor || 0;
                    } else {
                        valorPorLocalizacao[loc].porFaturar += e.valor || 0;
                    }
                });
                console.log('üìä Valores por Localiza√ß√£o:', valorPorLocalizacao);
                
                // Quantidades - produzidas = terminadas + stock (sem faturadas que falta embalamento)
                const encTerminadasEStock = encFiltradas.filter(e => e._origem === 'terminada' || e._origem === 'stock');
                const totalProduzido = encTerminadasEStock.reduce((s,e) => s + (e.quantidade || 0), 0);
                const totalEntregue = encFiltradas.reduce((s,e) => s + (e.qtdEntregue || 0), 0);
                const totalEmbalado = encFiltradas.reduce((s,e) => s + (e.qtdEmbalada || 0), 0);
                
                // Separar por origem: terminadas, stock, faturadas n√£o terminadas
                const encEntregues = encFiltradas.filter(e => e._origem === 'terminada');
                const encEmStock = encFiltradas.filter(e => e._origem === 'stock');
                const encFaturadasNaoTerminadas = encFiltradas.filter(e => e._origem === 'faturada');
                const totalEncEntregues = encEntregues.length;
                const totalEncEmStock = encEmStock.length;
                const totalEncFatNaoTerm = encFaturadasNaoTerminadas.length;
                const unidadesEmStock = encEmStock.reduce((s,e) => s + (e.quantidade || 0), 0);
                
                console.log('üìä Encomendas:', { total: encFiltradas.length, entregues: totalEncEntregues, emStock: totalEncEmStock, fatNaoTerm: totalEncFatNaoTerm, unidadesStock: unidadesEmStock });
                
                // Por Tipologia
                const porTipologia = {};
                encFiltradas.forEach(e => {
                    const tip = e.tipologia || 'Sem Tipologia';
                    if(!porTipologia[tip]) porTipologia[tip] = { quantidade:0, qtdEntregue:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porTipologia[tip].quantidade += e.quantidade || 1;
                    porTipologia[tip].qtdEntregue += e.qtdEntregue || 0;
                    porTipologia[tip].valor += e.valor || 0;
                    if(e.faturada) {
                        porTipologia[tip].valorFaturado += e.valor || 0;
                        porTipologia[tip].faturadas++;
                    }
                    porTipologia[tip].total++;
                });
                
                // Debug
                console.log('üìä encFiltradas:', encFiltradas.length);
                console.log('üìä porTipologia:', porTipologia);
                console.log('üìä Filtro Ano:', filtroAno, 'M√™s:', filtroMes);
                
                // Por Caixa/Liga√ß√£o
                const porCaixa = {};
                encFiltradas.forEach(e => {
                    const cx = e.ligacao || e.caixa || 'Sem Caixa';
                    if(!porCaixa[cx]) porCaixa[cx] = { quantidade:0, qtdEntregue:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porCaixa[cx].quantidade += e.quantidade || 1;
                    porCaixa[cx].qtdEntregue += e.qtdEntregue || 0;
                    porCaixa[cx].valor += e.valor || 0;
                    if(e.faturada) {
                        porCaixa[cx].valorFaturado += e.valor || 0;
                        porCaixa[cx].faturadas++;
                    }
                    porCaixa[cx].total++;
                });
                
                // Por M√™s (prioridade: entrega > embalamento > produ√ß√£o)
                const porMes = {};
                encFiltradas.forEach(e => {
                    const mes = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao || 'Sem Data';
                    if(mes === 'Sem Data' || !mes) return;
                    if(!porMes[mes]) porMes[mes] = { quantidade:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porMes[mes].quantidade += e.quantidade || 1;
                    porMes[mes].valor += e.valor || 0;
                    if(e.faturada) {
                        porMes[mes].valorFaturado += e.valor || 0;
                        porMes[mes].faturadas++;
                    }
                    porMes[mes].total++;
                });
                
                // === KPIs de Opera√ß√µes (OEE) ===
                const tempoTotalOps = opsFiltradas.reduce((s,r) => s + r.duracao, 0);
                const numOperacoes = opsFiltradas.length;
                
                // Tempo Dispon√≠vel REAL do Mapa de Horas (soma de todos os meses filtrados)
                let tempoDisponivelReal = 0;
                if(Object.keys(mapaHoras).length > 0) {
                    if(filtroMes) {
                        // M√™s espec√≠fico selecionado
                        tempoDisponivelReal = mapaHoras[filtroMes] || 0;
                    } else {
                        // Todos os meses do ano filtrado - somar apenas os meses que t√™m opera√ß√µes
                        const mesesComOps = [...new Set(opsFiltradas.map(r => r.mesAno))].filter(m => m);
                        mesesComOps.forEach(mes => {
                            tempoDisponivelReal += mapaHoras[mes] || 0;
                        });
                        // Se n√£o encontrou por meses com opera√ß√µes, somar todos os do ano
                        if(tempoDisponivelReal === 0 && filtroAno) {
                            Object.entries(mapaHoras).forEach(([mes, mins]) => {
                                if(mes.endsWith('/' + filtroAno)) {
                                    tempoDisponivelReal += mins;
                                }
                            });
                        }
                    }
                }
                
                const usaMapaHoras = tempoDisponivelReal > 0;
                console.log('‚è∞ Tempo Dispon√≠vel:', usaMapaHoras ? 
                    `REAL (Mapa Horas): ${(tempoDisponivelReal/60).toFixed(1)}h` : 
                    `APROXIMADO (Ops): ${(tempoTotalOps/60).toFixed(1)}h`);
                
                // Performance: usar os r√°cios calculados nas an√°lises (se dispon√≠veis)
                // Por agora, usar um valor conservador baseado no r√°cio m√©dio
                // Performance real ser√° calculada depois da an√°lise de opera√ß√µes
                
                // Efici√™ncia por tipologia
                const eficienciaPorTipologia = {};
                const tempoPorTipologia = {};
                opsFiltradas.forEach(r => {
                    if(!tempoPorTipologia[r.tipologia]) tempoPorTipologia[r.tipologia] = {real:0, objetivo:0, count:0};
                    tempoPorTipologia[r.tipologia].real += r.duracao;
                    if(objetivos[r.operacao]) tempoPorTipologia[r.tipologia].objetivo += objetivos[r.operacao];
                    tempoPorTipologia[r.tipologia].count++;
                });
                Object.keys(tempoPorTipologia).forEach(t => {
                    const d = tempoPorTipologia[t];
                    eficienciaPorTipologia[t] = { tempoReal:d.real, tempoObjetivo:d.objetivo, eficiencia: d.real > 0 && d.objetivo > 0 ? (d.objetivo / d.real) * 100 : 0, numOps:d.count };
                });
                
                const tempoPerturbacoes = pertFiltradas.reduce((s,r) => s+r.duracao,0);
                const numPerturbacoes = pertFiltradas.length;
                
                const perturbacoesPorTipo = {};
                pertFiltradas.forEach(r => {
                    if(!perturbacoesPorTipo[r.tipo]) perturbacoesPorTipo[r.tipo] = {tempo:0,count:0};
                    perturbacoesPorTipo[r.tipo].tempo += r.duracao;
                    perturbacoesPorTipo[r.tipo].count++;
                });
                
                // DISPONIBILIDADE:
                // Com Mapa Horas: (Tempo Dispon√≠vel Real - Perturba√ß√µes) / Tempo Dispon√≠vel Real
                // Sem Mapa Horas: (Tempo Opera√ß√µes - Perturba√ß√µes) / Tempo Opera√ß√µes (aproxima√ß√£o)
                const tempoBase = usaMapaHoras ? tempoDisponivelReal : tempoTotalOps;
                const tempoDisponivel = tempoBase > 0 ? tempoBase - tempoPerturbacoes : 0;
                const disponibilidade = tempoBase > 0 ? (tempoDisponivel / tempoBase) * 100 : 0;
                
                // Performance ser√° calculada mais tarde baseada nos r√°cios reais
                let performance = 0;
                const qualidade = 100;
                let oee = 0;
                
                // Meses √∫nicos das encomendas e opera√ß√µes
                const mesesEnc = Object.keys(porMes).filter(m => m && m !== 'Sem Data');
                const mesesOps = [...new Set(opsFiltradas.map(r => r.mesAno))].filter(m => m);
                const mesesUnicos = [...new Set([...mesesEnc, ...mesesOps])].sort((a,b) => {
                    const [ma,ya] = a.split('/').map(Number);
                    const [mb,yb] = b.split('/').map(Number);
                    return ya !== yb ? ya - yb : ma - mb;
                });
                
                // OEE por m√™s
                const oeePorMes = {};
                mesesUnicos.forEach(mes => {
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    const pertMes = pertFiltradas.filter(r => r.mesAno === mes);
                    const tempoOpsMes = opsMes.reduce((s,r) => s + r.duracao, 0);
                    const tempoPertMes = pertMes.reduce((s,r) => s + r.duracao, 0);
                    
                    // Usar tempo do Mapa de Horas se dispon√≠vel, sen√£o usar tempo de opera√ß√µes
                    const tempoBaseMes = mapaHoras[mes] || tempoOpsMes;
                    const tempoDispMes = tempoBaseMes - tempoPertMes;
                    const dispMes = tempoBaseMes > 0 ? (tempoDispMes / tempoBaseMes) * 100 : 0;
                    const perfMes = 0; // Ser√° actualizado depois
                    const oeeMes = 0; // Ser√° actualizado depois
                    oeePorMes[mes] = { 
                        tempoOperacoes: tempoOpsMes, 
                        tempoPerturbacoes: tempoPertMes, 
                        tempoDisponivel: tempoBaseMes,
                        usaMapaHoras: !!(mapaHoras[mes]),
                        disponibilidade: dispMes, 
                        performance: perfMes, 
                        oee: oeeMes 
                    };
                });
                
                // Evolu√ß√£o mensal (encomendas + opera√ß√µes)
                const evolucaoMensal = mesesUnicos.map(mes => {
                    const encMes = porMes[mes] || { quantidade: 0, valor: 0, valorFaturado: 0, total: 0 };
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    const pertMes = pertFiltradas.filter(r => r.mesAno === mes);
                    const tempoOpsMes = opsMes.reduce((s,r) => s + r.duracao, 0);
                    const tempoMapaHorasMes = mapaHoras[mes] || 0;
                    const horasDisponiveisMes = tempoMapaHorasMes > 0 ? tempoMapaHorasMes / 60 : tempoOpsMes / 60;
                    return { 
                        mes, 
                        encomendas: encMes.total,
                        quantidade: encMes.quantidade,
                        valor: encMes.valor,
                        valorFaturado: encMes.valorFaturado,
                        tempoOperacoes: tempoOpsMes,
                        horasOperacoes: tempoOpsMes / 60,
                        horasDisponiveis: horasDisponiveisMes,
                        usaMapaHoras: tempoMapaHorasMes > 0,
                        entregues: encMes.total,
                        perturbacoes: pertMes.reduce((s,r) => s + r.duracao, 0)
                    };
                });
                
                // Tipologias √∫nicas (apenas tipologias reais, n√£o liga√ß√µes/caixas)
                const tipologias = [...new Set([
                    ...encomendas.map(e => e.tipologia),
                    ...registosOperacoes.map(r => r.tipologia)
                ])].filter(t => t).sort();
                
                // Calcular quantidade produzida por tipologia das encomendas FILTRADAS
                const qtdPorTipologia = {};
                encFiltradas.forEach(e => {
                    const tip = e.tipologia || 'Sem Tipologia';
                    if(!qtdPorTipologia[tip]) qtdPorTipologia[tip] = 0;
                    qtdPorTipologia[tip] += e.qtdEntregue || e.quantidade || 0;
                });
                
                // Calcular quantidade por Caixa/Artigo de TODAS as encomendas (filtradas por ano/m√™s, mas N√ÉO por tipologia)
                // Isto permite que E1-Embalagem (tipologia Frac) seja encontrada quando filtramos por tipologia E1
                const encFiltradasSemTipologia = encomendas.filter(e => {
                    const mesAno = e.mesAnoEmbalamento || e.mesAnoEntrega || e.mesAnoProducao;
                    const ano = mesAno ? mesAno.split('/')[1] : '';
                    if(filtroAno && ano !== filtroAno) return false;
                    if(filtroMes && mesAno !== filtroMes) return false;
                    return true;
                });
                
                // Tamb√©m filtrar encomendas em produ√ß√£o (pendentes) pelo mesmo crit√©rio
                // S√≥ incluir as que t√™m data de produ√ß√£o preenchida (j√° produzidas, em stock)
                const encProducaoFiltradas = encomendasProducao.filter(e => {
                    // S√≥ contar se tem data de produ√ß√£o (j√° foi produzida)
                    if(!e.mesAnoProducao || e.mesAnoProducao === '') return false;
                    
                    const mesAno = e.mesAnoProducao;
                    const ano = mesAno ? mesAno.split('/')[1] : '';
                    if(filtroAno && ano !== filtroAno) return false;
                    if(filtroMes && mesAno !== filtroMes) return false;
                    return true;
                });
                
                // Juntar terminadas + produ√ß√£o para c√°lculo de quantidades do OEE
                const todasEncParaOEE = [...encFiltradasSemTipologia, ...encProducaoFiltradas];
                console.log('üì¶ Encomendas para OEE:', { terminadas: encFiltradasSemTipologia.length, producao: encProducaoFiltradas.length, total: todasEncParaOEE.length });
                
                const qtdPorCaixaArtigo = {};
                const qtdPorCaixaNormalizada = {}; // Com espa√ßos normalizados
                todasEncParaOEE.forEach(e => {
                    const caixa = e.caixa || '';
                    if(caixa) {
                        if(!qtdPorCaixaArtigo[caixa]) qtdPorCaixaArtigo[caixa] = 0;
                        // Usar quantidade PRODUZIDA (n√£o entregue) para OEE
                        qtdPorCaixaArtigo[caixa] += e.quantidade || e.qtdProduzida || e.qtdEntregue || 0;
                        
                        // Tamb√©m guardar vers√£o normalizada (sem espa√ßos extras)
                        const caixaNorm = caixa.replace(/\s+/g, ' ').trim();
                        if(!qtdPorCaixaNormalizada[caixaNorm]) qtdPorCaixaNormalizada[caixaNorm] = 0;
                        qtdPorCaixaNormalizada[caixaNorm] += e.quantidade || e.qtdProduzida || e.qtdEntregue || 0;
                    }
                });
                
                // Performance por Caixa/Artigo (baseado nas opera√ß√µes e objetivos por tipologia/caixa)
                const performancePorCaixa = {};
                // Agrupar opera√ß√µes por caixa/artigo
                const opsPorCaixa = {};
                opsFiltradas.forEach(r => {
                    const caixa = r.caixa || r.artigo || 'Sem Caixa';
                    if(!opsPorCaixa[caixa]) opsPorCaixa[caixa] = { tempoReal: 0, count: 0 };
                    opsPorCaixa[caixa].tempoReal += r.duracao;
                    opsPorCaixa[caixa].count++;
                });
                
                // Fun√ß√£o para normalizar nomes (remover espa√ßos extras, converter * para x)
                const normalizarNome = (nome) => {
                    return nome.replace(/\s+/g, ' ').replace(/\*/g, 'x').trim().toLowerCase();
                };
                
                // Criar mapa de objetivos normalizados
                const objetivosNorm = {};
                Object.entries(objetivosTipologia).forEach(([nome, tempo]) => {
                    objetivosNorm[normalizarNome(nome)] = tempo;
                    objetivosNorm[nome] = tempo;
                    objetivosNorm[nome.toLowerCase()] = tempo;
                    // Tamb√©m sem espa√ßos
                    objetivosNorm[nome.replace(/\s+/g, '').toLowerCase()] = tempo;
                });
                
                // Mapeamentos manuais para nomes que n√£o correspondem
                const mapeamentoNomes = {
                    'transporte': 'transportes',
                    'cxs sobras tipo jaula 1600': 'cxs sobras tipo jaula 1600x1200x800',
                };
                
                // Calcular performance para cada caixa
                Object.entries(opsPorCaixa).forEach(([caixa, dados]) => {
                    // Tentar encontrar objetivo para esta caixa
                    const caixaNorm = normalizarNome(caixa);
                    const caixaSemEspacos = caixa.replace(/\s+/g, '').toLowerCase();
                    
                    // Primeiro tentar nome direto, depois normalizado, depois sem espa√ßos, depois mapeamento
                    let tempoObj = objetivosTipologia[caixa] || 
                                   objetivosNorm[caixaNorm] || 
                                   objetivosNorm[caixaSemEspacos] ||
                                   objetivosNorm[caixa.replace(/\s+/g, ' ').trim()] ||
                                   (mapeamentoNomes[caixaNorm] ? objetivosNorm[mapeamentoNomes[caixaNorm]] : 0) ||
                                   0;
                    
                    // Obter quantidade produzida desta caixa (com normaliza√ß√£o melhorada)
                    const caixaTrim = caixa.replace(/\s+/g, ' ').trim();
                    let qtdProduzida = qtdPorCaixaArtigo[caixa] || 
                                       qtdPorCaixaArtigo[caixaTrim] || 
                                       qtdPorCaixaNormalizada[caixaTrim] || 0;
                    
                    // Se n√£o encontrou, tentar procurar com normaliza√ß√£o mais agressiva
                    if(qtdProduzida === 0) {
                        const caixaLower = caixaNorm;
                        Object.entries(qtdPorCaixaArtigo).forEach(([enc, qtd]) => {
                            // Normalizar: remover espa√ßos extras, lowercase
                            const encNorm = enc.replace(/\s+/g, ' ').trim().toLowerCase();
                            // Tamb√©m comparar sem NENHUM espa√ßo (mais agressivo)
                            const encSemEspacos = enc.replace(/\s+/g, '').toLowerCase();
                            const caixaSemEspacos = caixa.replace(/\s+/g, '').toLowerCase();
                            
                            if((encNorm === caixaLower || encSemEspacos === caixaSemEspacos) && qtd > 0) {
                                qtdProduzida = qtd;
                            }
                        });
                    }
                    
                    // Debug: mostrar caixas sem quantidade
                    if(qtdProduzida === 0 && dados.tempoReal > 60) {
                        console.log('‚ö†Ô∏è Sem quantidade:', caixa, '| Normalizado:', caixaNorm, '| SemEspa√ßos:', caixa.replace(/\s+/g, '').toLowerCase());
                    }
                    
                    // Caso especial: Transporte usa o N√öMERO DE ENCOMENDAS TERMINADAS (entregas feitas)
                    if(caixaNorm === 'transporte' || caixaNorm === 'transportes') {
                        // Usar apenas encomendas terminadas (n√£o pendentes)
                        qtdProduzida = encFiltradasSemTipologia.length;
                        console.log('üöõ Transporte:', qtdProduzida, 'entregas');
                    }
                    
                    const tempoObjetivoTotal = tempoObj > 0 && qtdProduzida > 0 ? tempoObj * qtdProduzida : 0;
                    
                    performancePorCaixa[caixa] = {
                        tempoReal: dados.tempoReal,
                        tempoObjetivo: tempoObjetivoTotal,
                        tempoObjUnitario: tempoObj,
                        quantidade: qtdProduzida,
                        performance: dados.tempoReal > 0 && tempoObjetivoTotal > 0 ? (tempoObjetivoTotal / dados.tempoReal) * 100 : 0,
                        numOps: dados.count
                    };
                });
                
                // Mapeamento de tipologias (Registos Produ√ß√£o ‚Üí Encomendas)
                const mapTipologia = {
                    'E2-Frac': 'Frac',
                    'E1': 'Frac',
                    'Maquinacao': 'Frac',
                    'Transporte': 'Transporte'
                };
                
                // Fun√ß√£o para obter quantidade - primeiro por artigos da opera√ß√£o, depois por tipologia
                const getQtdPorOperacao = (tipologia, artigos, operacao) => {
                    // Caso especial: Transporte usa TODAS as caixas entregues
                    if(operacao && operacao.toLowerCase().includes('transporte')) {
                        let totalEntregue = 0;
                        Object.values(qtdPorTipologia).forEach(q => totalEntregue += q);
                        return totalEntregue;
                    }
                    
                    // Se temos artigos espec√≠ficos, somar quantidade desses artigos
                    if(artigos && artigos.length > 0) {
                        let qtd = 0;
                        artigos.forEach(art => {
                            // Tentar nome exato
                            if(qtdPorCaixaArtigo[art]) {
                                qtd += qtdPorCaixaArtigo[art];
                            } else {
                                // Tentar vers√£o normalizada (sem espa√ßos extras)
                                const artNorm = art.replace(/\s+/g, ' ').trim();
                                if(qtdPorCaixaNormalizada[artNorm]) {
                                    qtd += qtdPorCaixaNormalizada[artNorm];
                                }
                            }
                        });
                        // Se temos artigos espec√≠ficos, retornar a quantidade encontrada (mesmo que seja 0)
                        // N√ÉO usar fallback de tipologia para opera√ß√µes com artigos espec√≠ficos
                        return qtd;
                    }
                    
                    // S√≥ usar tipologia como fallback se N√ÉO temos artigos espec√≠ficos
                    // (ex: opera√ß√µes gen√©ricas sem artigo definido)
                    if(qtdPorTipologia[tipologia]) return qtdPorTipologia[tipologia];
                    // Tentar mapeamento
                    const tipMapped = mapTipologia[tipologia];
                    if(tipMapped && qtdPorTipologia[tipMapped]) return qtdPorTipologia[tipMapped];
                    return 0;
                };
                
                // Debug
                console.log('üìä Qtd por Tipologia (filtrado):', qtdPorTipologia);
                console.log('üìä Qtd por Caixa/Artigo:', qtdPorCaixaArtigo);
                console.log('üìä Encomendas filtradas:', encFiltradas.length);
                
                // An√°lise por Unidade/Tipologia/Opera√ß√£o
                const analiseOperacoes = {};
                opsFiltradas.forEach(r => {
                    const key = `${r.unidadeProducao}|${r.tipologia}|${r.operacao}`;
                    // Buscar objetivo - tentar nome original e normalizado
                    const opNorm = normalizarOperacao(r.operacao);
                    const tempoObj = objetivos[r.operacao] || objetivos[opNorm] || objetivosTipologia[r.tipologia] || 0;
                    if(!analiseOperacoes[key]) {
                        analiseOperacoes[key] = {
                            unidadeProducao: r.unidadeProducao || 'Sem Unidade',
                            caixa: r.artigo || 'Sem Caixa',
                            tipologia: r.tipologia || 'Sem Tipologia',
                            operacao: r.operacao || 'Sem Opera√ß√£o',
                            tempoTotal: 0,
                            tempoObjetivo: tempoObj,
                            numRegistos: 0,
                            artigos: new Set() // Recolher artigos √∫nicos
                        };
                    }
                    analiseOperacoes[key].tempoTotal += r.duracao || 0;
                    analiseOperacoes[key].numRegistos++;
                    if(r.artigo) {
                        analiseOperacoes[key].artigos.add(r.artigo);
                        // Atualizar caixa com o √∫ltimo artigo (ou juntar v√°rios)
                        analiseOperacoes[key].caixa = r.artigo;
                    }
                });
                
                // Calcular m√©tricas derivadas
                const analiseArray = Object.values(analiseOperacoes).map(a => {
                    // Buscar quantidade produzida - primeiro por artigos, depois por tipologia
                    const artigos = Array.from(a.artigos || []);
                    // Se h√° v√°rios artigos, juntar os nomes
                    const caixaDisplay = artigos.length > 1 ? artigos.join(', ') : (artigos[0] || a.caixa);
                    const qtdProduzida = getQtdPorOperacao(a.tipologia, artigos, a.operacao);
                    const tempoMedioPorCaixa = qtdProduzida > 0 ? a.tempoTotal / qtdProduzida : 0;
                    const tempoObjetivoH = a.tempoObjetivo / 60; // converter para horas
                    const tempoMedioH = tempoMedioPorCaixa / 60;
                    const racio = tempoMedioPorCaixa > 0 && a.tempoObjetivo > 0 ? (a.tempoObjetivo / tempoMedioPorCaixa) * 100 : 0;
                    return {
                        ...a,
                        caixaDisplay,
                        qtdProduzida,
                        tempoTotalH: a.tempoTotal / 60,
                        tempoObjetivoH,
                        tempoMedioPorCaixa,
                        tempoMedioH,
                        racio
                    };
                }).sort((a,b) => {
                    // Ordenar por r√°cio do mais alto para o mais baixo
                    // Sem r√°cio (0) vai para o fim
                    if(a.racio > 0 && b.racio === 0) return -1;
                    if(a.racio === 0 && b.racio > 0) return 1;
                    return b.racio - a.racio;
                });
                
                // Calcular OEE com f√≥rmula correcta:
                // Disponibilidade = (Tempo Dispon√≠vel - Perturba√ß√µes) / Tempo Dispon√≠vel
                // Performance = Tempo Objetivo Total Pe√ßas / (Tempo Dispon√≠vel - Perturba√ß√µes)
                // Qualidade = 100% (fixo)
                // OEE = Disponibilidade √ó Performance √ó Qualidade
                
                // Somar total de pe√ßas produzidas e tempo objetivo
                let totalPecasProduzidas = 0;
                let tempoObjetivoTotalPecas = 0;
                
                Object.entries(performancePorCaixa).forEach(([caixa, dados]) => {
                    if(dados.quantidade > 0) {
                        totalPecasProduzidas += dados.quantidade;
                        tempoObjetivoTotalPecas += dados.tempoObjetivo; // j√° √© quantidade √ó tempo unit√°rio
                    }
                });
                
                // Tempo dispon√≠vel para Performance:
                // = Tempo Dispon√≠vel Real (Mapa Horas) - Perturba√ß√µes
                // OU = Tempo Opera√ß√µes - Perturba√ß√µes (se sem Mapa Horas)
                const tempoParagens = tempoPerturbacoes;
                const tempoUtilParaPerformance = tempoDisponivel; // j√° √© tempoBase - perturba√ß√µes
                
                // PERFORMANCE = Tempo Objetivo Total / Tempo √ötil (Dispon√≠vel - Perturba√ß√µes)
                if(tempoUtilParaPerformance > 0 && tempoObjetivoTotalPecas > 0) {
                    performance = (tempoObjetivoTotalPecas / tempoUtilParaPerformance) * 100;
                } else {
                    performance = 0;
                }
                
                // Efici√™ncia geral (para compatibilidade)
                const eficienciaGeral = performance;
                
                // EFICI√äNCIA PRODUTIVA (nova f√≥rmula):
                // = N¬∫ Pe√ßas Produzidas / (Cad√™ncia Te√≥rica √ó (Tempo Dispon√≠vel - Paragens N√£o Planeadas))
                // Como temos m√∫ltiplas caixas com cad√™ncias diferentes:
                // = Œ£ Pe√ßas Produzidas / Œ£ Pe√ßas Esperadas
                // Onde Pe√ßas Esperadas por caixa = Cad√™ncia da caixa √ó Tempo √ötil proporcional
                // Cad√™ncia = 1 / Tempo Objetivo Unit√°rio (pe√ßas/min)
                // Tempo √ötil proporcional = propor√ß√£o do tempo real da caixa aplicada ao tempo √∫til total
                
                let eficienciaProdutiva = 0;
                const tempoUtilTotal = tempoDisponivel; // tempoBase - perturba√ß√µes
                const tempoRealTotal = Object.values(performancePorCaixa).reduce((s,d) => s + d.tempoReal, 0);
                
                if(tempoUtilTotal > 0 && tempoRealTotal > 0 && totalPecasProduzidas > 0) {
                    let pecasEsperadas = 0;
                    Object.entries(performancePorCaixa).forEach(([caixa, dados]) => {
                        if(dados.tempoObjUnitario > 0 && dados.tempoReal > 0) {
                            // Propor√ß√£o do tempo desta caixa no total
                            const proporcaoTempo = dados.tempoReal / tempoRealTotal;
                            // Tempo √∫til atribu√≠do a esta caixa
                            const tempoUtilCaixa = tempoUtilTotal * proporcaoTempo;
                            // Cad√™ncia te√≥rica = 1 pe√ßa / tempoObjUnitario minutos
                            const cadenciaTeor = 1 / dados.tempoObjUnitario;
                            // Pe√ßas esperadas neste tempo √∫til
                            pecasEsperadas += cadenciaTeor * tempoUtilCaixa;
                        }
                    });
                    
                    if(pecasEsperadas > 0) {
                        eficienciaProdutiva = (totalPecasProduzidas / pecasEsperadas) * 100;
                    }
                    
                    console.log('üìä Efici√™ncia Produtiva:', {
                        totalPecasProduzidas,
                        pecasEsperadas: pecasEsperadas.toFixed(0),
                        tempoUtilTotal: (tempoUtilTotal/60).toFixed(1) + 'h',
                        eficienciaProdutiva: eficienciaProdutiva.toFixed(1) + '%'
                    });
                }
                
                // OEE = Disponibilidade √ó Performance √ó Qualidade
                oee = disponibilidade > 0 && performance > 0 ? (disponibilidade/100)*(performance/100)*(qualidade/100)*100 : 0;
                
                // Debug
                console.log('üìä OEE calc:', { 
                    totalPecasProduzidas, 
                    tempoObjetivoTotalPecas: (tempoObjetivoTotalPecas/60).toFixed(1) + 'h',
                    tempoBase: (tempoBase/60).toFixed(1) + 'h (' + (usaMapaHoras ? 'Mapa Horas' : 'Aproxima√ß√£o Ops') + ')',
                    tempoParagens: (tempoParagens/60).toFixed(1) + 'h',
                    tempoUtilParaPerformance: (tempoUtilParaPerformance/60).toFixed(1) + 'h',
                    disponibilidade: disponibilidade.toFixed(1) + '%',
                    performance: performance.toFixed(1) + '%',
                    qualidade: qualidade + '%',
                    oee: oee.toFixed(1) + '%'
                });
                console.log('üìä performancePorCaixa:', performancePorCaixa);
                
                // Atualizar OEE por m√™s com performance calculada individualmente por m√™s
                Object.keys(oeePorMes).forEach(mes => {
                    const tempoBaseMes = oeePorMes[mes].tempoDisponivel;
                    const tempoPertMes = oeePorMes[mes].tempoPerturbacoes;
                    const tempoUtilMes = tempoBaseMes - tempoPertMes;
                    
                    // Calcular tempo objetivo para as opera√ß√µes DESTE m√™s
                    let tempoObjMes = 0;
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    // Agrupar opera√ß√µes do m√™s por caixa
                    const opsPorCaixaMes = {};
                    opsMes.forEach(r => {
                        const caixa = r.caixa || r.artigo || 'Sem Caixa';
                        if(!opsPorCaixaMes[caixa]) opsPorCaixaMes[caixa] = 0;
                        opsPorCaixaMes[caixa] += r.duracao;
                    });
                    // Usar a performance global por caixa como proxy
                    Object.entries(opsPorCaixaMes).forEach(([caixa, tempoReal]) => {
                        const dados = performancePorCaixa[caixa];
                        if(dados && dados.tempoReal > 0 && dados.tempoObjetivo > 0) {
                            // Propor√ß√£o do tempo objetivo para este m√™s
                            const proporcao = tempoReal / dados.tempoReal;
                            tempoObjMes += dados.tempoObjetivo * proporcao;
                        }
                    });
                    
                    const perfMes = tempoUtilMes > 0 && tempoObjMes > 0 ? (tempoObjMes / tempoUtilMes) * 100 : performance;
                    oeePorMes[mes].performance = perfMes;
                    oeePorMes[mes].oee = oeePorMes[mes].disponibilidade > 0 && perfMes > 0 ? 
                        (oeePorMes[mes].disponibilidade/100) * (perfMes/100) * 100 : 0;
                });
                
                // Anos √∫nicos dispon√≠veis (de todas as encomendas e opera√ß√µes, n√£o filtradas)
                const getAnoFromMesAno = (mesAno) => {
                    if(!mesAno) return '';
                    const parts = mesAno.split('/');
                    return parts.length === 2 ? parts[1] : '';
                };
                const anosEnc = encomendas.map(e => getAnoFromMesAno(e.mesAnoEmbalamento) || getAnoFromMesAno(e.mesAnoEntrega) || getAnoFromMesAno(e.mesAnoProducao));
                const anosOps = registosOperacoes.map(r => getAnoFromMesAno(r.mesAno));
                const anosUnicos = [...new Set([...anosEnc, ...anosOps])].filter(a => a && a >= '2026').sort().reverse();
                
                return { 
                    totalEncomendas, encFaturadas: encFaturadas.length, encNaoFaturadas: encNaoFaturadas.length,
                    taxaFaturacao, valorTotal, valorFaturado, valorPorFaturar, valorPorLocalizacao,
                    totalFaturadasAnual, valorFaturadoAnual, totalEncAnual,
                    totalProduzido, totalEntregue, totalEmbalado, totalEncEntregues, totalEncEmStock, totalEncFatNaoTerm, unidadesEmStock,
                    porTipologia, porCaixa, porMes,
                    tempoTotalOps, numOperacoes, eficienciaGeral, eficienciaPorTipologia, performancePorCaixa,
                    tempoPerturbacoes, numPerturbacoes, perturbacoesPorTipo,
                    disponibilidade, performance, qualidade, oee, oeePorMes, eficienciaProdutiva,
                    evolucaoMensal, mesesUnicos, tipologias, analiseArray, anosUnicos
                };
            }, [encomendas, encomendasProducao, registosProducao, registosOperacoes, registosPerturbacoes, objetivos, objetivosTipologia, mapCaixaEcode, mapaHoras, filtroAno, filtroMes, filtroTipologia]);
            
            useEffect(() => {
                if(kpis.evolucaoMensal.length===0) return;
                const ctx = document.getElementById('chartEvolucao');
                if(!ctx) return;
                if(chartRefs.current.evolucao) chartRefs.current.evolucao.destroy();
                chartRefs.current.evolucao = new Chart(ctx, {
                    type:'bar',
                    data:{ labels:kpis.evolucaoMensal.map(d=>d.mes), datasets:[
                        { label:'Valor Faturado (‚Ç¨)', data:kpis.evolucaoMensal.map(d=>d.valorFaturado), backgroundColor:'rgba(16,185,129,0.7)', borderColor:'#10b981', borderWidth:1, yAxisID:'y' },
                        { type:'line', label:'Encomendas', data:kpis.evolucaoMensal.map(d=>d.encomendas), borderColor:'#f59e0b', backgroundColor:'transparent', borderWidth:2, tension:0.4, yAxisID:'y1' }
                    ]},
                    options:{ responsive:true, maintainAspectRatio:false, interaction:{mode:'index',intersect:false}, plugins:{legend:{labels:{color:'#94a3b8'}}}, scales:{ x:{ticks:{color:'#64748b'},grid:{color:'rgba(148,163,184,0.1)'}}, y:{type:'linear',position:'left',ticks:{color:'#3b82f6',callback:v=>formatCurrency(v)},grid:{color:'rgba(148,163,184,0.1)'}}, y1:{type:'linear',position:'right',ticks:{color:'#f59e0b'},grid:{drawOnChartArea:false}} } }
                });
            }, [kpis.evolucaoMensal]);
            
            // Gr√°fico de Produtividade (‚Ç¨ faturados / hora trabalhada)
            useEffect(() => {
                if(kpis.evolucaoMensal.length === 0 || activeTab !== 'produtividade') return;
                const ctx = document.getElementById('chartProdutividade');
                if(!ctx) return;
                if(chartRefs.current.produtividade) chartRefs.current.produtividade.destroy();
                
                // Calcular produtividade por m√™s: valor faturado / horas dispon√≠veis (Mapa de Horas quando dispon√≠vel)
                const prodFaturadoData = kpis.evolucaoMensal.map(d => {
                    const horas = d.horasDisponiveis || 0;
                    return horas > 0 ? (d.valorFaturado || 0) / horas : 0;
                });
                
                chartRefs.current.produtividade = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: kpis.evolucaoMensal.map(d => d.mes),
                        datasets: [{
                            label: '‚Ç¨ Faturado/hora',
                            data: prodFaturadoData,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16,185,129,0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 6,
                            pointBackgroundColor: '#10b981'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#94a3b8' } },
                            tooltip: { callbacks: { label: (ctx) => ctx.parsed.y.toFixed(2) + ' ‚Ç¨/h' } }
                        },
                        scales: {
                            x: { ticks: { color: '#64748b' }, grid: { color: 'rgba(148,163,184,0.1)' } },
                            y: { ticks: { color: '#3b82f6', callback: v => v.toFixed(0) + ' ‚Ç¨' }, grid: { color: 'rgba(148,163,184,0.1)' } }
                        }
                    }
                });
            }, [kpis.evolucaoMensal, activeTab]);
            
            // Gr√°fico de Perturba√ß√µes Top 5
            useEffect(() => {
                if(Object.keys(kpis.perturbacoesPorTipo || {}).length === 0 || activeTab !== 'perturbacoes') return;
                const ctx = document.getElementById('chartPerturbacoes');
                if(!ctx) return;
                if(chartRefs.current.perturbacoes) chartRefs.current.perturbacoes.destroy();
                
                // Top 5 perturba√ß√µes por tempo
                const top5 = Object.entries(kpis.perturbacoesPorTipo)
                    .sort((a, b) => b[1].tempo - a[1].tempo)
                    .slice(0, 5);
                
                const cores = ['#f59e0b', '#ef4444', '#8b5cf6', '#10b981', '#3b82f6'];
                
                chartRefs.current.perturbacoes = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: top5.map(([tipo]) => tipo.length > 30 ? tipo.substring(0, 30) + '...' : tipo),
                        datasets: [{
                            label: 'Tempo (horas)',
                            data: top5.map(([, d]) => d.tempo / 60),
                            backgroundColor: cores,
                            borderColor: cores,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            legend: { display: false },
                            tooltip: { callbacks: { label: (ctx) => ctx.parsed.x.toFixed(1) + 'h' } }
                        },
                        scales: {
                            x: { ticks: { color: '#64748b', callback: v => v + 'h' }, grid: { color: 'rgba(148,163,184,0.1)' } },
                            y: { ticks: { color: '#94a3b8' }, grid: { display: false } }
                        }
                    }
                });
            }, [kpis.perturbacoesPorTipo, activeTab]);
            
            const exportarPDF = async () => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('l','mm','a4');
                doc.setFontSize(20); doc.setFont('helvetica','bold'); doc.text('Relat√≥rio de KPIs',14,20);
                doc.setFontSize(10); doc.setFont('helvetica','normal'); doc.text('Gerado em: '+new Date().toLocaleDateString('pt-PT'),14,28);
                if(filtroMes) doc.text('Per√≠odo: '+filtroMes,14,34);
                if(filtroTipologia) doc.text('Tipologia: '+filtroTipologia,100,34);
                
                doc.autoTable({ startY:45, head:[['Indicador','Valor','Meta']], body:[
                    ['Taxa de Conclus√£o',kpis.taxaConclusao.toFixed(1)+'%','90%'],
                    ['Taxa de Fatura√ß√£o',kpis.taxaFaturacao.toFixed(1)+'%','100%'],
                    ['OEE',kpis.oee.toFixed(1)+'%','85%'],
                    ['Efici√™ncia Geral',kpis.eficienciaGeral.toFixed(1)+'%','100%'],
                    ['Efici√™ncia Produtiva',kpis.eficienciaProdutiva.toFixed(1)+'%','100%'],
                    ['Lead Time M√©dio',kpis.leadTimeMedia.toFixed(1)+' dias','< 7 dias'],
                    ['Taxa de Atraso',kpis.taxaAtraso.toFixed(1)+'%','< 5%']
                ], styles:{fontSize:9}, headStyles:{fillColor:[59,130,246]} });
                
                const y = doc.lastAutoTable.finalY + 15;
                doc.autoTable({ startY:y, head:[['Descri√ß√£o','Valor']], body:[
                    ['Valor Faturado',formatCurrency(kpis.valorFaturado)],
                    ['Valor Pendente',formatCurrency(kpis.valorPendente)]
                ], styles:{fontSize:9}, headStyles:{fillColor:[16,185,129]} });
                
                doc.save('Relatorio_KPIs_'+new Date().toLocaleDateString('pt-PT').replace(/\//g,'-')+'.pdf');
                showMsg('‚úÖ PDF exportado!','success');
            };
            
            const temDados = encomendas.length>0 || registosProducao.length>0 || registosOperacoes.length>0;
            
            return e('div',{className:'app'},
                e('header',{className:'header'},
                    e('div',{className:'header-left'},
                        e('div',{className:'logo'},'üìä'),
                        e('div',null, 
                            e('h1',null,'Sistema de KPIs'), 
                            e('p',null, lastUpdate ? '√öltima atualiza√ß√£o: ' + lastUpdate.toLocaleString('pt-PT') : 'Indicadores de Produ√ß√£o e Encomendas')
                        )
                    ),
                    e('div',{style:{display:'flex',gap:'12px',alignItems:'center'}},
                        e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading||!urlPowerAutomate,style:{background:isLoading?'#64748b':!urlPowerAutomate?'#475569':''}},
                            isLoading ? '‚è≥ A carregar...' : 'üîÑ Atualizar'
                        ),
                        e('button',{className:'btn btn-secondary',onClick:()=>setActiveTab('importar')},'üì• Importar'),
                        e('button',{className:'btn btn-secondary',onClick:()=>setShowConfig(!showConfig)},'‚öôÔ∏è'),
                        temDados && e('button',{className:'btn btn-secondary',onClick:exportarPDF},'üìÑ PDF')
                    )
                ),
                
                // Modal de Configura√ß√£o
                showConfig && e('div',{className:'section',style:{marginBottom:'24px',background:'linear-gradient(135deg, var(--bg-secondary), var(--bg-card))'}},
                    e('div',{className:'section-header'},
                        e('h3',{className:'section-title'},'‚öôÔ∏è Configura√ß√£o Power Automate'),
                        e('button',{className:'btn btn-secondary',onClick:()=>setShowConfig(false),style:{padding:'6px 12px'}},'‚úï')
                    ),
                    e('div',{style:{display:'grid',gap:'16px'}},
                        e('div',null,
                            e('label',{style:{display:'block',marginBottom:'6px',fontSize:'13px',color:'var(--text-secondary)'}},'üîó URL do Fluxo Power Automate:'),
                            e('input',{type:'text',value:urlPowerAutomate,onChange:ev=>setUrlPowerAutomate(ev.target.value),placeholder:'https://prod-XX.westeurope.logic.azure.com/...',style:{width:'100%',padding:'10px 14px',borderRadius:'var(--radius-sm)',background:'var(--bg-primary)',border:'1px solid var(--border-color)',color:'var(--text-primary)',fontSize:'13px'}})
                        ),
                        urlPowerAutomate && e('div',{style:{display:'flex',gap:'12px'}},
                            e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading},
                                isLoading ? '‚è≥ A testar...' : 'üß™ Testar Liga√ß√£o'
                            )
                        ),
                        e('div',{style:{padding:'12px',background:'var(--accent-blue-soft)',borderRadius:'var(--radius-sm)',fontSize:'12px',color:'var(--text-secondary)'}},
                            e('strong',{style:{color:'var(--accent-blue)'}},'‚ÑπÔ∏è Como configurar: '),
                            e('ol',{style:{margin:'8px 0 0 16px'}},
                                e('li',null,'Cria um fluxo no Power Automate com trigger HTTP'),
                                e('li',null,'Adiciona a√ß√µes para ler os ficheiros Excel'),
                                e('li',null,'Retorna JSON com: producao, perturbacoes, encomendas, objetivosOperacao, objetivosTipologia, mapaHoras'),
                                e('li',null,'Cola o URL HTTP POST aqui')
                            )
                        ),
                        e('div',{style:{padding:'12px',background:'var(--accent-green-soft)',borderRadius:'var(--radius-sm)',fontSize:'12px'}},
                            e('strong',{style:{color:'var(--accent-green)'}},'üì± Instalar como App: '),
                            'No browser, clica no menu (‚ãÆ) e seleciona "Instalar aplica√ß√£o" ou "Adicionar ao ecr√£ inicial"'
                        )
                    )
                ),
                
                e('div',{className:'tabs'},
                    e('button',{className:`tab ${activeTab==='dashboard'?'active':''}`,onClick:()=>setActiveTab('dashboard')},'üìä Dashboard'),
                    e('button',{className:`tab ${activeTab==='operacoes'?'active':''}`,onClick:()=>setActiveTab('operacoes')},'üîß Opera√ß√µes'),
                    e('button',{className:`tab ${activeTab==='perturbacoes'?'active':''}`,onClick:()=>setActiveTab('perturbacoes')},'‚ö†Ô∏è Perturba√ß√µes'),
                    e('button',{className:`tab ${activeTab==='produtividade'?'active':''}`,onClick:()=>setActiveTab('produtividade')},'üìà Produtividade'),
                    e('button',{className:`tab ${activeTab==='oee'?'active':''}`,onClick:()=>setActiveTab('oee')},'‚öôÔ∏è OEE'),
                    e('button',{className:`tab ${activeTab==='detalhes'?'active':''}`,onClick:()=>setActiveTab('detalhes')},'üìã Detalhes')
                ),
                
                temDados && activeTab!=='importar' && e('div',{className:'filter-bar'},
                    e('select',{className:'filter-select',value:filtroAno,onChange:ev=>setFiltroAno(ev.target.value)},
                        e('option',{value:''},'üìÜ Todos os anos'),
                        (kpis.anosUnicos || ['2026']).map(a=>e('option',{key:a,value:a},a))
                    ),
                    e('select',{className:'filter-select',value:filtroMes,onChange:ev=>setFiltroMes(ev.target.value)},
                        e('option',{value:''},'üìÖ Todos os meses'),
                        kpis.mesesUnicos.map(m=>e('option',{key:m,value:m},m))
                    ),
                    e('select',{className:'filter-select',value:filtroTipologia,onChange:ev=>setFiltroTipologia(ev.target.value)},
                        e('option',{value:''},'üè∑Ô∏è Todas tipologias'),
                        kpis.tipologias.map(t=>e('option',{key:t,value:t},t))
                    ),
                    (filtroAno||filtroMes||filtroTipologia) && e('button',{className:'btn btn-secondary',onClick:()=>{setFiltroAno('2026');setFiltroMes('');setFiltroTipologia('');}},'‚úï Limpar')
                ),
                
                activeTab==='importar' && e('div',null,
                    // Power Automate
                    e('div',{className:'section',style:{marginBottom:'24px'}},
                        e('div',{className:'section-header'},
                            e('h3',{className:'section-title'},'üîÑ Carregar via Power Automate'),
                            e('div',{style:{display:'flex',gap:'8px'}},
                                e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading||!urlPowerAutomate},
                                    isLoading ? '‚è≥ A carregar...' : 'üîÑ Carregar Todos os Dados'
                                )
                            )
                        ),
                        e('div',{style:{display:'grid',gridTemplateColumns:'repeat(4, 1fr)',gap:'16px',marginTop:'16px'}},
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-blue)'}},registosOperacoes.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Opera√ß√µes')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-amber)'}},registosPerturbacoes.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Perturba√ß√µes')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-green)'}},encomendas.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Encomendas')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-cyan)'}},Object.keys(mapaHoras).length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Meses Mapa Horas')
                            )
                        ),
                        !urlPowerAutomate && e('div',{style:{marginTop:'16px',padding:'12px',background:'var(--accent-amber-soft)',borderRadius:'var(--radius-sm)',fontSize:'13px',color:'var(--accent-amber)'}},
                            '‚ö†Ô∏è Configure o URL do Power Automate clicando em ‚öôÔ∏è no canto superior direito'
                        )
                    ),
                    
                    // Importa√ß√£o manual
                    e('div',{className:'section'},
                        e('h3',{className:'section-title',style:{marginBottom:'20px'}},'üìÅ Importar Ficheiros Excel (manual)'),
                        e('div',{className:'kpi-grid'},
                            e('label',{className:'upload-zone',style:{gridColumn:'span 2',background:'linear-gradient(135deg, var(--accent-blue-soft), var(--accent-purple-soft))'}},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importRegistosProducao}),
                                e('div',{className:'upload-icon'},'üìä'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Registos Produ√ß√£o (√âvora)'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},
                                    registosOperacoes.length>0 || registosPerturbacoes.length>0 
                                        ? `‚úÖ ${registosOperacoes.length} opera√ß√µes + ${registosPerturbacoes.length} perturba√ß√µes`
                                        : 'Ficheiro com folhas Produ√ß√£o + Perturba√ß√µes'
                                )
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importEncomendas}),
                                e('div',{className:'upload-icon'},'üßæ'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Encomendas'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},encomendas.length>0?`‚úÖ ${encomendas.length} registos`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importObjetivos}),
                                e('div',{className:'upload-icon'},'üéØ'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Objetivos Opera√ß√µes'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(objetivos).length>0?`‚úÖ ${Object.keys(objetivos).length} opera√ß√µes`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importObjetivos}),
                                e('div',{className:'upload-icon'},'üìã'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Objetivos Tipologias'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(objetivosTipologia).length>0?`‚úÖ ${Object.keys(objetivosTipologia).length} tipologias`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone',style:{background:'linear-gradient(135deg, var(--accent-green-soft), var(--accent-cyan-soft))'}},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importMapaHoras}),
                                e('div',{className:'upload-icon'},'‚è∞'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Mapa de Horas (Tempo Dispon√≠vel)'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(mapaHoras).length>0?`‚úÖ ${Object.keys(mapaHoras).length} meses carregados`:'Ficheiro Configura√ß√µes App Produ√ß√£o')
                            )
                        )
                    )
                ),
                
                activeTab==='dashboard' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'üìä'), e('div',{className:'empty-state-title'},'Nenhum dado importado'), e('div',{className:'empty-state-text'},'V√° ao separador "Importar" para carregar os ficheiros Excel.'))) :
                    e('div',null,
                        // KPI cards
                        e('div',{className:'kpi-grid'},
                            e(KPICard,{icon:'üì¶',iconColor:'blue',label:'Encomendas',value:formatNumber(kpis.totalEncomendas),valueColor:'blue',meta:`${formatNumber(kpis.totalEncEntregues)} entregues ¬∑ ${formatNumber(kpis.totalEncEmStock)} stock` + (kpis.totalEncFatNaoTerm > 0 ? ` ¬∑ ${formatNumber(kpis.totalEncFatNaoTerm)} fat.` : '')}),
                            e(KPICard,{icon:'üíµ',iconColor:'green',label:'Valor Faturado',value:formatCurrency(kpis.valorFaturado),valueColor:'green',meta:`${kpis.encFaturadas} de ${kpis.totalEncomendas} faturadas`}),
                            e(KPICard,{icon:'üìä',iconColor:'red',label:'Perturba√ß√µes',value:minutosParaHoras(kpis.tempoPerturbacoes),valueColor:kpis.tempoPerturbacoes>0?'red':'green',meta:`${kpis.numPerturbacoes} ocorr√™ncias`})
                        ),
                        // Gauges OEE e Efici√™ncia Produtiva
                        e('div',{className:'section',style:{textAlign:'center'}},
                            e('div',{style:{display:'flex',justifyContent:'center',alignItems:'flex-start',gap:'40px',flexWrap:'wrap'}},
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.oee,label:'OEE Geral'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'D √ó P √ó Q')
                                ),
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.eficienciaProdutiva,label:'Efici√™ncia Produtiva'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'Pe√ßas / (Cad√™ncia √ó T.√ötil)')
                                )
                            )
                        ),
                        e('div',{className:'grid-2'},
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üí∞ Valores Financeiros'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Valor Faturado'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},formatCurrency(kpis.valorFaturado))),
                                // Totais anuais quando m√™s filtrado
                                filtroMes && e('div',{style:{marginTop:'12px',paddingTop:'12px',borderTop:'1px dashed var(--border-color)'}},
                                    e('div',{style:{fontSize:'11px',color:'var(--text-muted)',marginBottom:'8px',fontStyle:'italic'}},'üìÖ Total Anual ('+filtroAno+'):'),
                                    e('div',{className:'summary-row'}, e('span',{className:'summary-label',style:{fontSize:'12px'}},'Faturado no Ano'), e('span',{className:'summary-value',style:{color:'var(--accent-green)',fontSize:'13px'}},formatCurrency(kpis.valorFaturadoAnual))),
                                    e('div',{className:'summary-row'}, e('span',{className:'summary-label',style:{fontSize:'12px'}},'Enc. Faturadas / Total'), e('span',{className:'summary-value',style:{fontSize:'13px'}},kpis.totalFaturadasAnual + ' / ' + kpis.totalEncAnual))
                                ),
                                // Valores por Localiza√ß√£o
                                Object.keys(kpis.valorPorLocalizacao || {}).length > 0 && e('div',{style:{marginTop:'16px',paddingTop:'16px',borderTop:'1px solid var(--border-color)'}},
                                    e('div',{style:{fontSize:'13px',fontWeight:'600',marginBottom:'12px',color:'var(--text-secondary)'}},'Por Localiza√ß√£o:'),
                                    Object.entries(kpis.valorPorLocalizacao).filter(([loc]) => loc && loc !== 'Sem Localiza√ß√£o').sort((a,b) => b[1].total - a[1].total).map(([loc, dados]) => 
                                        e('div',{key:loc,className:'summary-row',style:{marginBottom:'4px'}}, 
                                            e('span',{className:'summary-label'},loc), 
                                            e('span',{className:'summary-value',style:{color:'var(--accent-cyan)'}},formatCurrency(dados.total))
                                        )
                                    )
                                )
                            ),
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìä Resumo Encomendas'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Terminadas Entregues e Faturadas'), e('span',{className:'summary-value'},formatNumber(kpis.totalEncEntregues))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Em Stock'), e('span',{className:'summary-value',style:{color:'var(--accent-amber)'}},formatNumber(kpis.totalEncEmStock))),
                                kpis.totalEncFatNaoTerm > 0 && e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Faturadas (Entregues mas falta Embalamento)'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},formatNumber(kpis.totalEncFatNaoTerm))),
                                e('div',{className:'summary-row',style:{borderTop:'1px solid var(--border-color)',paddingTop:'8px',marginTop:'4px'}}, e('span',{className:'summary-label',style:{fontWeight:'600'}},'Total'), e('span',{className:'summary-value',style:{fontWeight:'700'}},formatNumber(kpis.totalEncomendas))),
                                e('div',{className:'summary-row',style:{borderTop:'2px solid var(--border-color)',paddingTop:'12px',marginTop:'8px'}}, e('span',{className:'summary-label'},'Unidades Produzidas'), e('span',{className:'summary-value',style:{color:'var(--accent-blue)'}},formatNumber(kpis.totalProduzido))),
                                kpis.unidadesEmStock > 0 && e('div',{style:{fontSize:'11px',color:'var(--text-muted)',textAlign:'right',marginTop:'2px'}},'(inclui '+formatNumber(kpis.unidadesEmStock)+' em stock)')
                            )
                        ),
                        // Tabela por Tipologia
                        Object.keys(kpis.porTipologia).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üì¶ Quantidade por Tipologia'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipologia'), e('th',null,'Quantidade'), e('th',null,'Valor Total'), e('th',null,'Encomendas'))),
                                e('tbody',null, Object.entries(kpis.porTipologia).sort((a,b)=>b[1].quantidade-a[1].quantidade).slice(0,10).map(([t,d])=>{
                                    return e('tr',{key:t}, 
                                        e('td',null,e('strong',null,t)), 
                                        e('td',null,formatNumber(d.quantidade)), 
                                        e('td',null,formatCurrency(d.valor)), 
                                        e('td',null,formatNumber(d.total))
                                    );
                                }))
                            )
                        ),
                        // Gr√°fico evolu√ß√£o mensal
                        kpis.evolucaoMensal.length>0 && e('div',{className:'section'}, e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìà Evolu√ß√£o Mensal'), e('div',{className:'chart-container'}, e('canvas',{id:'chartEvolucao'})))
                    )
                ),
                
                // SEPARADOR OPERA√á√ïES
                activeTab==='operacoes' && (!registosOperacoes.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'üîß'), e('div',{className:'empty-state-title'},'Sem dados de opera√ß√µes'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Registos de Produ√ß√£o para ver a an√°lise.'))) :
                    e('div',null,
                        // Tabela de An√°lise de Opera√ß√µes
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üîß An√°lise de Opera√ß√µes por Unidade / Tipologia'),
                            e('div',{style:{overflowX:'auto'}},
                                e('table',{className:'data-table'},
                                    e('thead',null, 
                                        e('tr',null, 
                                            e('th',null,'Unidade Produ√ß√£o'),
                                            e('th',null,'Caixa'),
                                            e('th',null,'Tipologia'),
                                            e('th',null,'Opera√ß√£o'),
                                            e('th',null,'Tempo Total (h)'),
                                            e('th',null,'Qtd Prod.'),
                                            e('th',null,'T. Obj/cx (h)'),
                                            e('th',null,'T. M√©dio/cx (h)'),
                                            e('th',null,'R√°cio T.Obj/T.Real')
                                        )
                                    ),
                                    e('tbody',null, 
                                        (kpis.analiseArray || []).map((a, idx) => {
                                            const racioColor = a.racio >= 100 ? 'excellent' : a.racio >= 80 ? 'good' : a.racio > 0 ? 'warning' : '';
                                            return e('tr',{key:idx}, 
                                                e('td',null, a.unidadeProducao),
                                                e('td',null, e('strong',null, a.caixaDisplay || a.caixa)),
                                                e('td',null, a.tipologia),
                                                e('td',null, a.operacao),
                                                e('td',null, a.tempoTotalH.toFixed(1)),
                                                e('td',null, formatNumber(a.qtdProduzida)),
                                                e('td',null, a.tempoObjetivoH > 0 ? a.tempoObjetivoH.toFixed(2) : 'N/A'),
                                                e('td',null, a.tempoMedioH.toFixed(2)),
                                                e('td',null, e('span',{className:`status-badge ${racioColor}`}, a.racio > 0 ? a.racio.toFixed(0) + '%' : 'N/A'))
                                            );
                                        })
                                    )
                                )
                            )
                        ),
                        // Resumo por Unidade de Produ√ß√£o
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üè≠ Resumo por Unidade de Produ√ß√£o'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Unidade'), e('th',null,'Tempo Total (h)'), e('th',null,'N¬∫ Opera√ß√µes'), e('th',null,'M√©dia/Op (h)'))),
                                e('tbody',null, 
                                    Object.entries(
                                        (kpis.analiseArray || []).reduce((acc, a) => {
                                            if(!acc[a.unidadeProducao]) acc[a.unidadeProducao] = {tempo:0, ops:0};
                                            acc[a.unidadeProducao].tempo += a.tempoTotalH;
                                            acc[a.unidadeProducao].ops += a.numRegistos;
                                            return acc;
                                        }, {})
                                    ).sort((a,b) => b[1].tempo - a[1].tempo).map(([unidade, d]) =>
                                        e('tr',{key:unidade},
                                            e('td',null, e('strong',null, unidade)),
                                            e('td',null, d.tempo.toFixed(1)),
                                            e('td',null, formatNumber(d.ops)),
                                            e('td',null, d.ops > 0 ? (d.tempo / d.ops).toFixed(2) : 'N/A')
                                        )
                                    )
                                )
                            )
                        )
                    )
                ),
                
                // SEPARADOR PERTURBA√á√ïES
                activeTab==='perturbacoes' && (!registosPerturbacoes.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'‚ö†Ô∏è'), e('div',{className:'empty-state-title'},'Sem dados de perturba√ß√µes'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Registos de Produ√ß√£o para ver as perturba√ß√µes.'))) :
                    e('div',null,
                        // Gr√°fico de Perturba√ß√µes Top 5
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'‚ö†Ô∏è Perturba√ß√µes - Top 5'),
                            e('div',{className:'chart-container',style:{height:'300px'}}, e('canvas',{id:'chartPerturbacoes'}))
                        ),
                        // Tabela detalhada de perturba√ß√µes
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìã Detalhe de Perturba√ß√µes'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo'), e('th',null,'Tempo (h)'), e('th',null,'Ocorr√™ncias'), e('th',null,'% do Total'))),
                                e('tbody',null, 
                                    Object.entries(kpis.perturbacoesPorTipo || {})
                                        .sort((a,b) => (b[1].tempo||0) - (a[1].tempo||0))
                                        .map(([tipo, dados]) => {
                                            const tempo = dados.tempo || 0;
                                            const count = dados.count || 0;
                                            const percentagem = kpis.tempoPerturbacoes > 0 ? (tempo / kpis.tempoPerturbacoes * 100) : 0;
                                            return e('tr',{key:tipo},
                                                e('td',null, e('strong',null, tipo)),
                                                e('td',null, (tempo/60).toFixed(1)),
                                                e('td',null, count),
                                                e('td',null, e('span',{className:'status-badge warning'}, percentagem.toFixed(1) + '%'))
                                            );
                                        })
                                )
                            )
                        ),
                        // Resumo
                        e('div',{className:'kpi-grid'},
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, (kpis.tempoPerturbacoes/60).toFixed(1) + 'h'),
                                e('div',{className:'kpi-label'},'Tempo Total Perturba√ß√µes')
                            ),
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, formatNumber(kpis.numPerturbacoes)),
                                e('div',{className:'kpi-label'},'Total Ocorr√™ncias')
                            ),
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, Object.keys(kpis.perturbacoesPorTipo || {}).length),
                                e('div',{className:'kpi-label'},'Tipos Diferentes')
                            )
                        )
                    )
                ),
                
                // SEPARADOR PRODUTIVIDADE
                activeTab==='produtividade' && (!encomendas.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'üìà'), e('div',{className:'empty-state-title'},'Sem dados de encomendas'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Encomendas para ver a produtividade.'))) :
                    e('div',null,
                        // Gr√°fico de Produtividade (‚Ç¨/hora)
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üí∞ Produtividade (‚Ç¨ Faturado / Hora Dispon√≠vel)'),
                            Object.keys(mapaHoras).length > 0 
                                ? e('div',{style:{marginBottom:'12px',fontSize:'11px',color:'var(--accent-green)'}},'‚úÖ Calculado com Mapa de Horas')
                                : e('div',{style:{marginBottom:'12px',fontSize:'11px',color:'var(--accent-amber)'}},'‚ö†Ô∏è Aproxima√ß√£o pelo tempo de opera√ß√µes ‚Äî importe o Mapa de Horas para dados reais'),
                            e('div',{className:'chart-container',style:{height:'300px'}}, e('canvas',{id:'chartProdutividade'}))
                        ),
                        // KPIs de Produtividade
                        (() => {
                            const totalHorasDisp = kpis.evolucaoMensal.reduce((s,d) => s + (d.horasDisponiveis || 0), 0);
                            const euroHoraTotal = totalHorasDisp > 0 ? kpis.valorTotal / totalHorasDisp : 0;
                            const euroHoraFaturado = totalHorasDisp > 0 ? kpis.valorFaturado / totalHorasDisp : 0;
                            return e('div',null,
                                e('div',{className:'kpi-grid'},
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value',style:{color:'var(--accent-green)'}}, formatCurrency(kpis.valorFaturado)),
                                        e('div',{className:'kpi-label'},'Valor Faturado')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, totalHorasDisp.toFixed(1) + 'h'),
                                        e('div',{className:'kpi-label'}, Object.keys(mapaHoras).length > 0 ? 'Horas Dispon√≠veis (MH)' : 'Horas Trabalhadas')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value',style:{color:'var(--accent-green)'}}, totalHorasDisp > 0 ? formatCurrency(euroHoraFaturado) + '/h' : 'N/A'),
                                        e('div',{className:'kpi-label'},'‚Ç¨ Faturado / Hora')
                                    )
                                ),
                                e('div',{className:'kpi-grid',style:{marginTop:'12px'}},
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, formatNumber(kpis.totalEncomendas)),
                                        e('div',{className:'kpi-label'},'Total Encomendas')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, formatNumber(kpis.encFaturadas)),
                                        e('div',{className:'kpi-label'},'Faturadas')
                                    )
                                )
                            );
                        })(),
                        // Tabela de produtividade por m√™s
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìä Produtividade Mensal'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'M√™s'), e('th',null,'Faturado'), e('th',null,'Horas'), e('th',null,'‚Ç¨/Hora'), e('th',null,'Enc.'), e('th',null,'Fonte'))),
                                e('tbody',null, 
                                    kpis.evolucaoMensal.map(m => {
                                        const horas = m.horasDisponiveis || 0;
                                        const euroHoraFat = horas > 0 ? (m.valorFaturado || 0) / horas : 0;
                                        return e('tr',{key:m.mes},
                                            e('td',null, e('strong',null, m.mes)),
                                            e('td',null, e('span',{style:{color:'var(--accent-green)'}}, formatCurrency(m.valorFaturado || 0))),
                                            e('td',null, horas.toFixed(1)),
                                            e('td',null, e('span',{className:`status-badge ${euroHoraFat >= 50 ? 'excellent' : euroHoraFat >= 30 ? 'good' : 'warning'}`}, formatCurrency(euroHoraFat))),
                                            e('td',null, formatNumber(m.entregues || 0)),
                                            e('td',null, e('span',{style:{fontSize:'10px',color: m.usaMapaHoras ? 'var(--accent-green)' : 'var(--accent-amber)'}}, m.usaMapaHoras ? '‚úÖ MH' : '~ Ops'))
                                        );
                                    })
                                )
                            )
                        )
                    )
                ),
                
                activeTab==='oee' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'‚öôÔ∏è'), e('div',{className:'empty-state-title'},'Sem dados para OEE'))) :
                    e('div',null,
                        e('div',{className:'section',style:{textAlign:'center'}},
                            e('h3',{className:'section-title',style:{marginBottom:'20px'}},'‚öôÔ∏è OEE - Overall Equipment Effectiveness'),
                            // Dois gauges lado a lado
                            e('div',{style:{display:'flex',justifyContent:'center',alignItems:'flex-start',gap:'40px',flexWrap:'wrap'}},
                                // Gauge OEE Geral
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.oee,label:'OEE Geral'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'D √ó P √ó Q')
                                ),
                                // Gauge Efici√™ncia Produtiva
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.eficienciaProdutiva,label:'Efici√™ncia Produtiva'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'Pe√ßas Produzidas / (Cad√™ncia √ó T.√ötil)'),
                                    e('div',{style:{marginTop:'4px',fontSize:'10px',color: Object.keys(mapaHoras).length > 0 ? 'var(--accent-green)' : 'var(--accent-amber)'}},
                                        Object.keys(mapaHoras).length > 0 ? '‚úÖ Mapa de Horas' : '‚ö†Ô∏è Aproxima√ß√£o'
                                    )
                                )
                            ),
                            // Componentes OEE
                            e('div',{style:{marginTop:'40px',display:'flex',justifyContent:'space-around',gap:'30px',flexWrap:'wrap',maxWidth:'700px',margin:'40px auto 0'}},
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-blue)'}},kpis.disponibilidade.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Disponibilidade'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-blue)',marginTop:'4px',opacity:0.8}},'(T.Dispon√≠vel - Perturba√ß√µes) / T.Dispon√≠vel')
                                ),
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-green)'}},kpis.performance.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Performance'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-green)',marginTop:'4px',opacity:0.8}},'T.Objetivo Total / T.√ötil')
                                ),
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-purple)'}},kpis.qualidade.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Qualidade'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-purple)',marginTop:'4px',opacity:0.8}},'Pe√ßas Boas / Pe√ßas Totais')
                                )
                            ),
                            e('div',{style:{marginTop:'20px',fontSize:'12px',color:'var(--text-muted)'}},'OEE = Disponibilidade √ó Performance √ó Qualidade'),
                            // Indicador da fonte de dados
                            e('div',{style:{marginTop:'16px',padding:'10px 16px',background: Object.keys(mapaHoras).length > 0 ? 'var(--accent-green-soft)' : 'var(--accent-amber-soft)',borderRadius:'var(--radius-sm)',display:'inline-block',fontSize:'12px'}},
                                Object.keys(mapaHoras).length > 0 
                                    ? e('span',{style:{color:'var(--accent-green)'}}, '‚úÖ Tempo Dispon√≠vel: Mapa de Horas (real)')
                                    : e('span',{style:{color:'var(--accent-amber)'}}, '‚ö†Ô∏è Tempo Dispon√≠vel: Aproxima√ß√£o pelo tempo de opera√ß√µes ‚Äî importe o Mapa de Horas para dados reais')
                            )
                        ),
                        // Diferen√ßa entre OEE e Efici√™ncia Produtiva
                        e('div',{className:'section',style:{padding:'20px'}},
                            e('div',{style:{display:'flex',gap:'20px',flexWrap:'wrap'}},
                                // OEE
                                e('div',{style:{flex:'1',minWidth:'250px',background:'rgba(139,92,246,0.08)',borderLeft:'3px solid var(--accent-purple)',borderRadius:'var(--radius-sm)',padding:'16px'}},
                                    e('div',{style:{fontWeight:'700',fontSize:'14px',color:'var(--accent-purple)',marginBottom:'8px'}},'‚öôÔ∏è OEE ‚Äî Efici√™ncia Global do Equipamento'),
                                    e('div',{style:{fontSize:'12px',color:'var(--text-muted)',lineHeight:'1.6'}},
                                        'Mede a efici√™ncia global considerando ',
                                        e('strong',null,'todos os factores de perda'),
                                        ': tempo parado (perturba√ß√µes), velocidade abaixo do objectivo e defeitos. Penaliza por tudo o que reduz a produ√ß√£o face ao potencial m√°ximo.'
                                    ),
                                    e('div',{style:{marginTop:'10px',fontSize:'11px',color:'var(--accent-purple)',fontFamily:'JetBrains Mono, monospace'}},'OEE = Disponibilidade √ó Performance √ó Qualidade')
                                ),
                                // Efici√™ncia Produtiva
                                e('div',{style:{flex:'1',minWidth:'250px',background:'rgba(34,197,94,0.08)',borderLeft:'3px solid var(--accent-green)',borderRadius:'var(--radius-sm)',padding:'16px'}},
                                    e('div',{style:{fontWeight:'700',fontSize:'14px',color:'var(--accent-green)',marginBottom:'8px'}},'üìä Efici√™ncia Produtiva'),
                                    e('div',{style:{fontSize:'12px',color:'var(--text-muted)',lineHeight:'1.6'}},
                                        'Mede se a quantidade produzida atingiu o ',
                                        e('strong',null,'objectivo te√≥rico'),
                                        ' para o tempo √∫til dispon√≠vel. Compara as pe√ßas reais com as pe√ßas que deveriam ter sido produzidas √† cad√™ncia te√≥rica, descontando apenas as paragens n√£o planeadas.'
                                    ),
                                    e('div',{style:{marginTop:'10px',fontSize:'11px',color:'var(--accent-green)',fontFamily:'JetBrains Mono, monospace'}},'EP = Pe√ßas Produzidas / (Cad√™ncia Te√≥rica √ó T.√ötil)')
                                )
                            ),
                            e('div',{style:{marginTop:'14px',fontSize:'11px',color:'var(--text-muted)',textAlign:'center',fontStyle:'italic'}},
                                'O OEE √© sempre ‚â§ Efici√™ncia Produtiva porque multiplica pela Disponibilidade e Qualidade. A Efici√™ncia Produtiva isola apenas o ritmo de produ√ß√£o face ao objectivo.'
                            )
                        ),
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìê Detalhe do C√°lculo OEE'),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Dispon√≠vel Total'), e('span',{className:'summary-value',style:{color:'var(--accent-cyan)'}},minutosParaHoras(Object.keys(mapaHoras).length > 0 ? (filtroMes ? (mapaHoras[filtroMes]||0) : Object.entries(mapaHoras).filter(([m])=> !filtroAno || m.endsWith('/'+filtroAno)).reduce((s,e)=>s+e[1],0)) : kpis.tempoTotalOps))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Perturba√ß√µes'), e('span',{className:'summary-value',style:{color:'var(--accent-red)'}},minutosParaHoras(kpis.tempoPerturbacoes))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo √ötil (Dispon√≠vel - Perturba√ß√µes)'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},minutosParaHoras(Math.max(0, (Object.keys(mapaHoras).length > 0 ? (filtroMes ? (mapaHoras[filtroMes]||0) : Object.entries(mapaHoras).filter(([m])=> !filtroAno || m.endsWith('/'+filtroAno)).reduce((s,e)=>s+e[1],0)) : kpis.tempoTotalOps) - kpis.tempoPerturbacoes)))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Opera√ß√µes Registado'), e('span',{className:'summary-value'},minutosParaHoras(kpis.tempoTotalOps))),
                            e('div',{className:'summary-row',style:{borderTop:'2px solid var(--border-color)',paddingTop:'12px',marginTop:'4px'}}, 
                                e('span',{className:'summary-label',style:{fontWeight:'600'}},'F√≥rmulas Utilizadas:'), 
                                e('span',{style:{fontSize:'11px',color:'var(--text-muted)'}},
                                    'Disp = (T.Dispon√≠vel - Perturba√ß√µes) / T.Dispon√≠vel | Perf = T.Objetivo Total / T.√ötil | OEE = D √ó P √ó Q'
                                )
                            )
                        ),
                        Object.keys(kpis.performancePorCaixa||{}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìä Performance por Caixa/Artigo'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Caixa/Artigo'), e('th',null,'Tempo Real'), e('th',null,'T.Obj/Cx'), e('th',null,'Qtd'), e('th',null,'T.Obj Total'), e('th',null,'Performance'))),
                                e('tbody',null, Object.entries(kpis.performancePorCaixa).filter(([c,d])=>c!=='Sem Caixa'&&d.tempoReal>0).sort((a,b)=>b[1].tempoReal-a[1].tempoReal).slice(0,25).map(([caixa,d])=>
                                    e('tr',{key:caixa}, 
                                        e('td',null,e('strong',null,caixa)), 
                                        e('td',null,minutosParaHoras(d.tempoReal)), 
                                        e('td',null,d.tempoObjUnitario>0?minutosParaHoras(d.tempoObjUnitario):'N/A'),
                                        e('td',null,d.quantidade||'-'),
                                        e('td',null,d.tempoObjetivo>0?minutosParaHoras(d.tempoObjetivo):'N/A'), 
                                        e('td',null,e('span',{className:`status-badge ${d.performance>=100?'excellent':d.performance>=80?'good':d.performance>0?'warning':''}`},d.performance>0?d.performance.toFixed(1)+'%':'N/A'))
                                    )
                                ))
                            )
                        ),
                        Object.keys(kpis.perturbacoesPorTipo).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'‚ö†Ô∏è Perturba√ß√µes por Tipo'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo'), e('th',null,'Tempo Total'), e('th',null,'Ocorr√™ncias'), e('th',null,'% do Total'))),
                                e('tbody',null, Object.entries(kpis.perturbacoesPorTipo).sort((a,b)=>b[1].tempo-a[1].tempo).map(([t,d])=>
                                    e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,minutosParaHoras(d.tempo)), e('td',null,d.count), e('td',null,e('span',{className:'status-badge warning'},(d.tempo/kpis.tempoPerturbacoes*100).toFixed(1)+'%')))
                                ))
                            )
                        ),
                        Object.keys(kpis.oeePorMes||{}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìÖ OEE por M√™s'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'M√™s'), e('th',null,'T. Dispon√≠vel'), e('th',null,'T. Opera√ß√µes'), e('th',null,'Perturba√ß√µes'), e('th',null,'Disponibilidade'), e('th',null,'Performance'), e('th',null,'OEE'))),
                                e('tbody',null, Object.entries(kpis.oeePorMes).sort((a,b)=>{const[ma,ya]=a[0].split('/').map(Number),[mb,yb]=b[0].split('/').map(Number);return yb!==ya?yb-ya:mb-ma;}).map(([mes,d])=>
                                    e('tr',{key:mes}, 
                                        e('td',null,e('strong',null,mes)), 
                                        e('td',null,
                                            e('span',{style:{color: d.usaMapaHoras ? 'var(--accent-cyan)' : 'var(--text-muted)'}},
                                                minutosParaHoras(d.tempoDisponivel),
                                                d.usaMapaHoras ? ' ‚úÖ' : ' ~'
                                            )
                                        ),
                                        e('td',null,minutosParaHoras(d.tempoOperacoes)), 
                                        e('td',null,e('span',{style:{color:'var(--accent-red)'}},minutosParaHoras(d.tempoPerturbacoes))), 
                                        e('td',null,e('span',{className:`status-badge ${d.disponibilidade>=90?'excellent':d.disponibilidade>=80?'good':'warning'}`},d.disponibilidade.toFixed(1)+'%')),
                                        e('td',null,e('span',{className:`status-badge ${d.performance>=100?'excellent':d.performance>=80?'good':d.performance>0?'warning':''}`},d.performance>0?d.performance.toFixed(1)+'%':'N/A')),
                                        e('td',null,e('span',{className:`status-badge ${d.oee>=85?'excellent':d.oee>=60?'good':d.oee>0?'warning':'critical'}`,style:{fontWeight:'700'}},d.oee>0?d.oee.toFixed(1)+'%':'N/A'))
                                    )
                                ))
                            )
                        )
                    )
                ),
                
                activeTab==='detalhes' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'üìã'), e('div',{className:'empty-state-title'},'Sem dados'))) :
                    e('div',null,
                        Object.keys(kpis.porTipologia || {}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üì¶ Quantidade Entregue por Tipologia'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipologia'), e('th',null,'Qtd Entregue'), e('th',null,'Valor Faturado'), e('th',null,'Efici√™ncia'))),
                                e('tbody',null, Object.entries(kpis.porTipologia).sort((a,b)=>b[1].qtdEntregue-a[1].qtdEntregue).map(([t,d])=>{
                                    const ef = kpis.eficienciaPorTipologia && kpis.eficienciaPorTipologia[t] ? kpis.eficienciaPorTipologia[t].eficiencia : 0;
                                    return e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,formatNumber(d.qtdEntregue)), e('td',null,formatCurrency(d.valorFaturado)), e('td',null,e('span',{className:`status-badge ${ef>=100?'excellent':ef>=80?'good':ef>0?'warning':''}`},ef>0?ef.toFixed(0)+'%':'N/A')));
                                }))
                            )
                        ),
                        Object.keys(kpis.porCaixa || {}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìã Quantidade Entregue por Tipo de Caixa'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo Caixa'), e('th',null,'Qtd Entregue'), e('th',null,'Valor Faturado'))),
                                e('tbody',null, Object.entries(kpis.porCaixa).sort((a,b)=>b[1].qtdEntregue-a[1].qtdEntregue).map(([t,d])=>{
                                    return e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,formatNumber(d.qtdEntregue)), e('td',null,formatCurrency(d.valorFaturado)));
                                }))
                            )
                        ),
                        e('div',{className:'grid-2'},
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'üìä Estat√≠sticas Opera√ß√µes'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Total'), e('span',{className:'summary-value'},formatNumber(kpis.numOperacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Total'), e('span',{className:'summary-value'},minutosParaHoras(kpis.tempoTotalOps))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'M√©dia/Opera√ß√£o'), e('span',{className:'summary-value'},kpis.numOperacoes>0?minutosParaHoras(Math.round(kpis.tempoTotalOps/kpis.numOperacoes)):'N/A'))
                            ),
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'‚ö†Ô∏è Estat√≠sticas Perturba√ß√µes'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Total'), e('span',{className:'summary-value'},formatNumber(kpis.numPerturbacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Perdido'), e('span',{className:'summary-value',style:{color:'var(--accent-red)'}},minutosParaHoras(kpis.tempoPerturbacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'% do Tempo Ops'), e('span',{className:'summary-value'},kpis.tempoTotalOps>0?(kpis.tempoPerturbacoes/kpis.tempoTotalOps*100).toFixed(1)+'%':'N/A'))
                            )
                        )
                    )
                ),
                
                msg && e('div',{className:`msg-toast ${msgType}`},msg)
            );
        }
        
        ReactDOM.render(e(App), document.getElementById('root'));
    </script>
</body>
</html>
