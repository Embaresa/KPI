<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="KPI Embaresa">
    <meta name="theme-color" content="#0f172a">
    <meta name="description" content="Sistema de KPIs - Produção e Encomendas Embaresa PT">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjogIlNpc3RlbWEgS1BJcyBFbWJhcmVzYSIsICJzaG9ydF9uYW1lIjogIktQSSBFbWJhcmVzYSIsICJkZXNjcmlwdGlvbiI6ICJTaXN0ZW1hIGRlIEtQSXMgLSBQcm9kdVx1MDBlN1x1MDBlM28gZSBFbmNvbWVuZGFzIEVtYmFyZXNhIFBUIiwgInN0YXJ0X3VybCI6ICIuIiwgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMwZjE3MmEiLCAidGhlbWVfY29sb3IiOiAiIzBmMTcyYSIsICJvcmllbnRhdGlvbiI6ICJhbnkiLCAiaWNvbnMiOiBbeyJzcmMiOiAiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFNQUFBQURBQ0FZQUFBQlMzR3dIQUFBTTcwbEVRVlI0bk8zZGVWalVkUjRIOERmRFlFQWFJbTFaQ1hpa0lnaUtET0JkdXBWcGVYUjRwVTlxcmZvOHVyVmxoMjI1dWJiMXROdVdQYnV1bHFXbDVaRkhYcHVheW5xVkY0S2NBb3FLRWw0b2w2Z3d3TXpzSDRyT09EUE0vR2FHWStiemZ2MlQvYjYvK2Y2KytIemVmTCsveXdHSWlJaUl4UEdxcjQ1RHV2UXgxRmZmSkZOKzlqNlgxNnZMT21UQlUwTnpSU0NjN3NCYTRaY1ZsempiTlpHSmdGYUJGcmM3RXdTSFAyaXA4Rm4wMUZBc2hjR1JJRGdVQU9QaVo5RlRZek1PZzlJUXFKUWVqTVZQVFkxeEhTbzlGN1U3TFN4OGNnZEtad083WmdBV1A3a0xwYk9Cb2lVUWk1L2NnWkk2dFJtQTJoU3grTW1kMU5hcnJWbWd6Z0N3K01tZDJSTUNxd0hnblYzeUpOYnFXVzNyZzVKKys4OTZQQWw2QUFZdlFPOEZHSER6djNmOHVYWWY0ei9YN3QvVVB3c0FHUXMwRGZpMzJyaktpa3VzM2tFR3JNd0FYUHFRSjZsckthVDRSaGlSSnpFTEFOZis1TW51ckcrck13Q1hQK1JKck5VemwwQWtHZ05Bb3BrRWdGZC95Sk5adWhwazh6NkFKQi91a0hOOTNKS0tiMWRiYmZPYk5Lb0JSOUp3dUFRaUFIVVh2ejN0N29vQklORVlBQktOQVNEUkdBQVNqUUVnMFJnQUVvMEJJTkVZQUJLTkFTRFJHQUFTalFFZzBSZ0FFbzBCSU5FWUFCS043d040a0dmbXBscHRXeitqZTRPTnc1MXdCdkFRZFJXL1BlMVNNUUFrR2dOQW9qRUFKQm9EUUtJeEFDUWFBMENpTVFBa0dnTkFvakVBSkJvRFFLSXhBQ1FhSDRaem9ZMnZwRnR0R3o0dnFnRkhRdmJpRE9BaWRSVy9QZTNVT0JnQUVvMEJJTkVZQUJLTkFTRFJHQUFTalFFZzBSZ0FFbzBCSU5FWUFCS05BU0RSR0FBU2pRRWcwVHpxYWRCWmp5ZFpiZnR3aDZZQlIwTHV3bU5tZ0xxSzM1NTJrc2xqQWtEa0NBYUFSR01BU0RRR2dFUmpBRWcwQm9CRVl3QklOQWFBUkdNQVNEU1BlaFRDV1F2N0oxdHRtN28zcGdGSFFnMkZNOEJOZFJXL1BlM2tuaGdBRW8wQklORVlBQktOQVNEUkdBQVNqUUVnMFhnZm9BbnBPdDM2VzJ1WjgvbEtaMzNnRE5CRTFGWDg5clNUWXhnQUVvMEJJTkVZQUJLTkFTRFJHQUFTalFFZzBSZ0FFbzBCSU5FWUFCS05BU0RSR0FBU2pRRWcwUmdBRW8wQklORVlBQktOQVNEUkdBQVNqUUVnMFJnQUVvMEJJTkVZQUJLTkFTRFJHQUFTalFFZzBSZ0FFbzBCSU5FWUFCS05BU0RSR0FBU2pRRWcwUmdBRW8wQklORThKZ0FmN3FqN0cxUnN0ZHY2Sm5oYjdjUG5SVG5WYnVzYllHeTFyNS9SM2FsMnYwbWpuR3AzVjE3Ry94UFNwWThCQU1xS1N4cG5ORVQxTEtCVklBQWdQM3VmRitCQk13Q1JJeGdBRW8wQklORVlBQktOQVNEUkdBQVNqUUVnMFJnQUVvMEJJTkVZQUJLTkFTRFIxSTA5Z0taczRvdGo4TUZmWjVwc081NTdFbzhOZXQ3aS91RmRPbUg1OTE4aTZPYnpKclhPbmoyUDBlT21JRCsvd0dxL2Q5THA5TGg2OVNyT1g3aUk5SXdzYk5tU2dOMTc5ME92MXpzOVRycU5BWENSYmxFUldMWjBBUUlDN2pIWmZ2ck1ieGc3YmdyT25ydWdxRDl2YnhVQ0F1NUJRTUE5Q092Y0VhT2VINDZNekd6OGFjWjdPSEVpejVWREY0MUxJQmVJMVVSajViS0Zac1YvNGtRZW5oLzlrdUxpdHlheWF4ZXNXYmtJSVNGdFhOSWZNUUJPNjlNN0RzdVdMa0R6NW5lYmJNL0tQbzZSWTE1R1llRmxseDR2S0tnVjVyei9sa3Y3bEl3QmNNTEFBZjJ3WlBFOCtQbjVtbXhQU3orSzBTOU1ScEdDOXlxTzU1NUVTUHRvaExTUFJtaUhIdWdSOXhoZW16RUxSVVhGWnZzT2VMUXZnb0phT1QxK1lnQWNOdVRKMzJQUndybTQ2NjVtSnR1VGtsTXhkdnhVbEpWZGNiaHZnOEdBeTVlTHNHN0Racno5NXcvTTJsVXFGU0s3aGpuY1A5M0dBRGpnbWVGRE1IL2VKMUNyVGE4aDdEK1FpUEVUcHVIcTFXc3VPMVphK2xHTDIxc0dCTGpzR0pJeEFBcUZCTGZCNTUvOURkN2VwbjkxdTNidnc0U1hYc0gxNnhVdVBWNjNxQWlMMjB2THlseDZIS2w0R1ZRaFg5Kzd6TFp0Mjc0TDAxNlppZXJxYXBjZEp5aW9GZnIzN1luM1o3MWgxcWJYNjVHUm1lT3lZMG5HQURpcHFMZ0VyODJZNVhUeGQrcllBZm1uVXV6YWQ5ZnVYeTJlSEpOeVhBSTVLYWhWSUJaKzhhbkZtYUUrRkJVVlkvWUgvMnlRWTBuQUFMaEEvMzY5c0dUeFBQajcrOVhyY1RJeXN6Rnk3Qjl1UFZKQnp1TVNTS0g4L0FJVW5EMkgzcjNpVExiMzdoV0xaVXNYNE1WSmYzVEpWU0NkVG85cjE2N2gzUGtMeU1qSXh1YXRDZGl6ZHg5ME92Tm5nY2h4RElCQ2xWb3RKcjc4S3I3K2NpNGU2ZC9icEUwVDB4MHJ2djhTNHlkTXc1VXI1WXI2NWNOcmpZTkxJQWRVVm1yeDhwVFhzU05oajFsYjkyNWRzV3I1VndnTTVIVjZkOEFBT0tpcXFncFRwNzJKTFZzVHpOb2lJc0t3YXNYWGZGekJEVEFBVHFpcHFjSDBWMmRpdzZhdFptMWhuVHRpemNwRnVPKytleHRoWkdRdkJzQkpPcDBlcjgyWWhkVnJONXExUGZ4d082eGQ5UTBlZktCMUk0eU03TUVBdUlCZXI4ZGJNK2RnMmZLMVptMXRRNE94ZHRWaUJBYy8xQWdqSTFzWUFCY3hHQXg0OXk4ZllmRTN5ODNhMnJSNUVHdCtXSVMyb2NHTk1ES3FDNzhmZ0VUaDl3TVFHV0VBU0RRR2dFUmpBRWcwQm9CRWMrdUg0WjRiTXhZOU5MRm0yd3N2WE1DL1B2M0VaSjhqU1lmeDR3OHJUZlo3OHVtaDZQZm9BT1FleThHU3I3K3kyR2RGUlFYT0ZSUmcrNWJOS1BndDMreFlEejcwRUthLy9nYnlUNS9Hd3YvODIrcjQ5SG85eWtwTGtaV1pnWVJ0UDZOS3ExWDBjL2o2K21MZ0U0TVEzalVTelZ1MFFFbFJFZExUVW5IZ2w3Mm9yS3kwZTB5V1dCcG5SbG9xZnQyekcrLysxZnlsZkdPSkJ3NWc0NDlyYkI2anFYTHJBQUJBM3NtVFdQVEYvRHIzS1MwcFFXUzNidmhwdzNwb2J4YUx0N2Mzb21NMEtDMHh2K1JyM0dmekZpMHdaTmh3VEp3OEJSL1BtUTJkVG1leXJ5YStGd3AreTBkd2FDaCtkLy85dUhUeG9zVytWQ29WZ2tORE1YN1NTMUNyZmJCcDNWcUwrMWt6OG9WeGFCa1lpSlhmTFVIaHhZdG9HUmlJeU83UjZCRWJoLzIvN0ZVMEprdHFqKy90N1kzUWR1MHhidUlrTkd2V0RPKzlPZVBXUGozNzlNWGdvY013KzUyM2JmYm5Ma1FzZ1M0VlhzU0Y4K2NSMVQzNjFyYXc4QWhvdFpVNGszZXF6czllTFMvSDRZTUg0ZWZ2ajVhQnBnKzMrZmo0b0Z1UEh0aTVmUnRPNXVaQ0V4ZHZ0Uis5WG84emVYbElUVTVHNS9BdWlzYXZWcXZSS2F3TGZ0MnpHMmNMQ2xCZFhZMUxoWVhZdVgyYldmRXJHWk1sT3AwT3AwN2tJaVhwTU1JaUxMK1E3MGxFQkFBQWtnOGRRa3pjN1pkWU5QSHhTRTVNdFBtNXU1czNSMHhjSElxTGlsQmFZdm9lYnRlb2J0QldWdUo0VGc0T0h6eUE2QmdOdkwyOWJmYXA5bFkyOGVwME9sUlZWYUY5aDQ0MiszZDBURks1L1JLb1hZY08rT2pUdVNiYmtoSVBZZjNxVlNiYjBsTlRNR1Q0Q056WHVqVzBGWlhvMExFVDFxMWVoY0ZQRDdYWlozbDVPWlovKzQyRjVVODhraElQd1dBd0lQdG9Kb1krOHl6Q0lpSndORDNkckUrVlNvWGdrRkIwajRsQmFuS3lvcC9EWURCZzA0OXJNV0xrS0lSRmhPTk0zbW5rbjg1RFZtWUdMbCs2NVBDWUxGR3BWQWh0MXc3Uk1ScWtwUnl4NnpQdXpPMERZTTg1QUFCb3RWcGtwcVZCRXh1UGlzb0s1QjdMUWZrVnkvOTZtM0dmZm41KzZOV3ZQeVpPbVlyNW4zK0c0cUlpQUVEUXZmY2lwRzA3ckY1eDQ5a2ZuVTZINU1PSjBNVDFOQ20yT3dzN0t6TURXLys3U2ZIUGtaWnlCTG5IanFGajU4NElhZHNXbXZoNFBENTRDSDdhc0E2SDl1OVhOQ1pMYXNkWmV4S2NuSmlJaEczbWozbDdHcmNQZ0JKSmlRY3hic0lrVkZWVllmUEdEWFo5cHFLaUFqdTNiME92UG4zUkl6WU9DVC9mS0FwTmZFK29WQ3E4UGV0OWsvME5CZ01DV3JaRVdXa3BnTnVGclZhckVSNFpoZWRHajBGNDEwaGtwcWNwSHYvMTY5ZVFsbklFYVNsSDRPWGxoV2RIajhIZ29jTncrT0JCNlBWNnU4ZGtpYjIvU0R5TnFBQ2N5Y3REUmNWMStQcjY0VmgybHJJUGUrSFdXbHFsVWlGYUU0c2ZsbjJIak5SVWs5MG1UNXVPbU5nNDdOeXgzV1I3VFUwTjBsT09vUFVERDJEWXM4OGg5MWdPdEVhWFFwVXlHQXc0azVlSDZCZ04xRDQrcUttdVZqd21FblFTWE92emYvd2RIOCtaYmZHYlZpeng4L1BEd0NjR3dkZlhEOWxITXdFQW5idUV3OS9mSDhkenpQOTF0cXpNVE1URXhjUEx5OHVzRFFEMi9PL0dLNVQ5Qmd5MGU4eHF0UnFUcDAxSFJHUVVBZ0phd3NmSEI4R2hvZWpiL3hHY09wR0xLcTNXcVRGSjV2WXpnS1dUeDZxcUtzeDU5eDJYOUttdHJFUmg0VVdzV1BvdDhrK2ZCbkRqUlBOa2J1NnRld3JHc2pJek1HVFljRHpjc1pQRnZyVmFMWFlsN01DZ3A1N0NvZjM3YnAySDFQVnoxTlRVWU1mV3JlalZ0eCtlR2pFQy92NTNvL3pLRmVSa0hiMzFXOTNlTWVVZVArYnczNHNuNHZzQUpBcmZCeUF5d2dDUWFDWUJxSjBXQXU3NG1rOGlUM0RuOGdmZ0RFRENNUUFrbXRVQWNCbEVuc1JhUFpzRndIaDlST1JwN3F4dkxvRklOSXNCNE5VZzhpU1dydjdVc2prRE1BVGt6bXpWcjlVQThGeUFQSW0xZXE1ekJ1QlNpTnhaWFV1ZldqYVhRQXdCdVNON2loOVFlQldJSVNCM29LUk83UXFBY1lvWUFtcktqT3ZUbnZOWXhTZTZ0ZThNQUh4dmdKb09wWVZmUy9HTk1NNEcxTlE0V3Z5QUF6TkFMZU9ab0JabkJHb29sbjc1T25McDN1bHIvWmFDQURBTTVIcldWaHpPM0xOeTJjMHVhMEVncWkrdXVGbGJiM2Q3R1FoeU5UNmRRRVJFcnZOL2VNL3BBMGF4UG00QUFBQUFTVVZPUks1Q1lJST0iLCAidHlwZSI6ICJpbWFnZS9wbmciLCAic2l6ZXMiOiAiMTkyeDE5MiIsICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSJ9LCB7InNyYyI6ICJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWdBQUFBSUFDQVlBQUFEMGVOVDZBQUFuUDBsRVFWUjRuTzNkZDJBVVpmN0g4Yzl1R2dtUlFDQlVEYjIza0FSUVVSUVF3WEsydS9NOHNUYzR6OHBQVDg5eW5wNTY1M2tpWjIvb3FYallrUU1MZ29BRkd5VWhkSkFxUllRRUVFZ2h5ZTd2RDgyU1RkMHlzN1BKODM3OWxjM3VQUHRkQi9QOXpETXp6MG9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNCeVhFNFg0TFQwM3NPOFR0Y0FBSERHMXRVTGplMkR4bnh3R2owQUlGQW1CSU5HK3dGcCtBQUFxelRHUU5Db1BsQW9UWDkvd1Y0N1NnRUFOQUFwcVMyQzNxYXhoSUZHOFNFQ2FmdzBlZ0JBb0FJSkJnMDlDRFRZNG1uNkFJQklhS3hob01FVlhGZmpwK0VEQU94V1Z5Qm9TRUdnd1JSSzR3Y0FSSk9HSGdTaXZrQWFQd0FnbWpYVUlCQzFoVW0xTjM4YVB3QWcydFFXQktJMUJFUmxVVFIrQUVCRDFWQ0NRRlFWSTlYYy9HbjhBSUNHcHFZZ0VFMGhJR29La2FvM2Z4by9BS0NocXhvRW9pVUVSRVVSSFBVREFCcXphSndOY0R2NTVoTE5Id0RRK05YVTE1eit6aHBIMHdkVC9nQUEwMFRMS1FISFpnQm8vZ0FBRTFYdGQwN05CRGdTQUdqK0FBQ1RSVU1JaUhnQW9Qa0RBT0I4Q0lob0FLRDVBd0J3aEpNaElHSUJnT1lQQUVCMVRvV0FpQVFBbWo4QUFMVnpJZ1RZSGdCby9nQUExQy9TSWNEV0FFRHpCd0FnY0pFTUFSRzdCb0RtRHdCQS9TTFZMMjBMQUpWVEM4MGZBSURBVmU2YmRzMEMyQklBbkY3ZkdBQ0F4c1NPdm1wNUFPQzhQd0FBNGJQN2VnQmJyd0dnK1FNQUVEbzcrNmlsQVlEei9nQUFXTXV1NndFcyt3cENwdjdodEx0R0w1WlhVc1UvUks4a3VheDU3UHVkcTlKellUNjJzajdxalZDOWtsWThsUzBnMHV6NENtRmJUZ0hRL0FFQXNJNGRmZFdTQU1CVi93QUFSSTRWZmRmeUdRQ08vZ0VBc0o3Vi9UWHNBTURSUHdBQWtSZHUvN1YwQm9DamZ3QUE3R05sbncwckFIRDBEd0NBYzhMcHc1Yk5BSEQwRHdDQS9henF0eEg3TmtBQUFCQTlRZzRBclBvSEFJQXpyRmdka0JrQUFBQU1GRklBNE9nZkFBQm5oVHNMd0F3QUFBQUdJZ0FBQUdDZ29BTUE5LzREQUJCOWd1M1BZYzBBY1A0ZkFBRG5oTk9IT1FVQUFJQ0JDQUFBQUJnb3FBREE3WDhBQUVTWFVHOEhaQVlBQUFBREVRQUFBREJRck5NRkFGYTVmMDYyMHlVQVFTbDY2VTFMeGttOC9IeEx4b0ZaQ0FBQUVHRldOZjZxNHhFRUVBeE9BUUFBWUtDQUF3QjNBQUJBK0t3KytvL1UySWh1b2R3SndBd0FBQUFHSWdBQUFHQWdBZ0FBQUFZaUFBQUFZQ0FDQUFBQUJpSUFBQUJnSUFJQUFBQUdJZ0FBQUdBZ0FnQUFBQVlpQUFBQVlDQUNBQUFBQmlJQUFBQmdJQUlBQUFBR0lnQUFBR0FnQWdBQUFBWWlBQUFBWUNBQ0FBQUFCaUlBQUFCZ0lBSUFBQUFHSWdBQUFHQWdBZ0FBQUFZaUFBQUFZQ0FDQUFBQUJpSUFBQUJnSUFJQUFBQUdJZ0FBQUdBZ0FnQUFBQVlpQUFBQVlDQUNBQUFBQmlJQUFBQmdJQUlBQUFBR0lnQUFBR0FnQWdBQUFBWWlBQUFBWUNBQ0FBQUFCaUlBQUFCZ0lBSUFBQUFHaW5XNkFBQ3cwcm1UY2kwWlovckVERXZHQWFJVkFRQkFvMkJWNDY4NkhrRUFqUlduQUFBQU1CQUJBRUNEWi9YUmY2VEdCcHhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQU1SQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURCVHJkQUdBcVdaY24yZkpPR2MvUHNDU2NRQ1loUUFBUkpoVmpiL3FlQVFCQU1IZ0ZBQUFBQVlpQUFBUlpQWFJmNlRHQnRENEVBQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQU1SQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQVBGT2wwQW90OWRveGRiTXM3OWM3SXRHUWNBRUQ0Q0FHcGxWZU92T2g1QkFBQ2N4eWtBQUFBTVJBQkFqYXcrK28vVTJBQ0F3QkFBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQU1SQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURCUXJOTUZBRlo2ZHZnU1M4WVovMW1XSmVNQVFMUWlBS0JSc0tyeFZ4MlBJQUNnc2VJVUFBQUFCaUlBb01Heit1Zy9VbU1EZ0pNSUFBQUFHSWdBQUFDQWdRZ0FBQUFZaUFBQUFJQ0JDQUFBQUJpSUFBQUFnSUVJQUFBQUdJZ0FBQUNBZ1FnQUFBQVlpQUFBQUlDQkNBQUFBQmlJQUFBQWdJRUlBQUFBR0lnQUFBQ0FnUWdBQUFBWWlBQUFBSUNCWXAwdUFFRDA2L2ZIeFphTXMrTEpiRXZHQVJBK0FnQ0FXbG5WK0t1T1J4QUFuTWNwQUFBQURFUUFBRkFqcTQvK0l6VTJnTUFRQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQU1SQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQU1SQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQU1SQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFBQUF3RUFFQUFBQURFUUFBQURBUUFRQUFBQU1SQUFBQU1CQUJBQUFBQXhFQUFBQXdFQUVBQUFBREVRQUFBREFRQVFBQUFBTVJBQUFBTUJBQkFBQUFBeEVBQUFBd0VBRUFBQUFERVFBQUFEQVFBUUFBQUFNUkFBQUFNQkFCQUFBQUF4RUFVS1A3NTJRM21MSEhmNVpsNlhoMmpuMzI0d01zSGMvT3NWYzhhZCsvQWF2SG5qNHh3OUx4N0J3NzhmTHpMUjB2VW1PajhTRUFBQUJnSUZlZ0wwenZQY3hiOGZQK2dyMzJWSU9vZE5mb3haYU1ZK2VzUW9Wbmh5K3haQnc3WnhVcXpMZyt6NUp4N0p4VnFORHZqOWI4RzdCelZxSEN1Wk55TFJuSHpsbUZDa1V2dlduSk9CejVRNUpTVWx2NGZ0NjZlbUc5L1owQUFBQkFJeEJzQU9BVUFBQUFCaUlBQUFCZ0lBSUFBQUFHSWdBQUFHQWdBZ0FBQUFZaUFBQUFZQ0FDQUFBQUJpSUFBQUJnSUFJQUFBQUdJZ0FBQUdBZ0FnQUFBQVlpQUFBQVlDQUNBQUFBQmlJQUFBQmdJQUlBQUFBR0lnQUFBR0FnQWdBQUFBWWlBQUFBWUNBQ0FBQUFCaUlBQUFCZ0lBSUFBQUFHSWdBQUFHQWdBZ0FBQUFZaUFBQUFZQ0FDQUFBQUJpSUFBQUJnSUFJQUFBQUdJZ0FBQUdBZ0FnQUFBQVlpQUFBQVlDQUNBQUFBQmlJQUFBQmdJQUlBQUFBR0lnQUFBR0NnV0tjTEFKd1FHeE9qamVzWGg3VHRoUmRQMEJjTHY3R2tqcGdZdHliOTYyODY5K3pUUXg1anc0Yk4rdDI0cS9YamozdHFmRDZjenhxbzB0SlNsUncrck1KRFJkcTlKMSs3ZCtkcjArYXRXdi9kQmkxYnRsS3JWcTlWZWJuSGx2ZU9sbjBKTkRRRUFNQWhzVEV4ZW16eWd6cnpqRk5ESG1QdHV1OTB3Ymp4eXM4dnNMQ3k0TVhGeFNrdUxrN0pUWnVxZGV0V2txU1RUenJlOS96QlE0ZjAyZWRmYSthczJab3o5MU1kUG56WXFWSUIvSUlBQURnZ05qWldUejMra01hT0dSbnlHQ3RYcmRXNGl5ZW9ZTzgrNndxelNYTFRwanA5N0NpZFBuYVU4dk1MOVBLcmIraUZLYS9wNEtGRFRwY0dHSXRyQUlBSWk0K1AxL1BQUEJKVzg4OWJ2a29Yakx1bVFUVC9xbHEyVE5YRW0vNmdUK2ZOMERsbm5lWjBPWUN4Q0FCQUJEVnBrcUFwenoycVVTT0hoenpHMHB6bCt2MUY0N1YvLzA4V1ZoWjVhV2t0OWRqa0J6WDVrZnVWa0JEdmREbUFjUWdBUUlRa0pqYlJmNlk4cHBPR0gxLy9pMnV4YUhHT0xycmtEenB3NEtDRmxUbnJ2SFBQME5TWG4xWnljbE9uU3dHTVFnQUFJcUJwVXBKZWVlbEpIWC9ja0pESCtPcnJ4YnI0c2o4Mnl2UG1RNGRrNnJtbkgxRnNUSXpUcFFER0lBQUFOa3RPYnFxcHJ6eXRvVU15UXg3ajh5KysxcVZYWEtmQ3dpSUxLNHN1Snd3YnF0dHZ1OUhwTWdCakVBQUFHNldrTk5PMHFjOHFLM05BeUdQTVg3QlFWMXg5bzRxTFN5eXNMRHBkZGNVNERjcm83M1FaZ0JFSUFJQk5XclJJMGV0VG45WEFBWDFESG1QTzNFOTExZmliVlZKaXhuM3picmRidC8vcEJxZkxBSXpBT2dDQURWcTJUTlcwcWMrb1Y4L3VJWS94d1VlZjZMb2JibGRaV1ptRmxRV252cFh5NHVMaWxKTFNUTWNjM1Y1Wm1RTjEzam1ucTErLzNtRzk1M0hIWml0allEL2xMbHNSMWpnQTZzWU1BR0N4MXExYjZhMXBMNFRWL1A4M2M3YXV1LzQyUjV0L0lFcExTN1ZuVDc1eWNwZnJoUmVuNnZTekx0U1YxOXlrL0lLOVlZMzc2L1BPdEtoQ0FMVWhBQUFXYXRlMmpkNmM5b0s2ZGVzYzhoanZUbjlmTjA2OFEyWGw1UlpXRmpsejVuNnFzODY5T0t6bGlVZWZjcEtGRlFHb0NRRUFzRWlIRHUzMDF1c3ZxRXZuamlHUDhmcWI3Mm5pclgreDdZdHpJdVg3NzdmcjVsdnVEbm43OXUzYXFrT0hkaFpXQktBcUFnQmdnZlQwby9YMjYxT1VubjUweUdOTWZlMXQzZmJuKytUeE5Pem1YMkhCcDE5cXlkSzhrTGNQNXhRS2dQb1JBSUF3ZGU2VXJyZGVmeUdzSTlhWC9qTk5kOXo5Z0x4ZXI0V1ZPZS9qdVF0QzNyWmp4OURERklENmNSY0FFSVp1M1RycmpkZWVWMXBheTVESGVQYjVWL1RBM3grMXNLcm9rWmUzTXVSdFUxczB0NjRRQU5VUUFJQVE5ZXJaWGRPbVBxT1dMVk5ESHVPSnA2Ym9uLzk2d3NLcW9rdEJHSGNESkNVbFdsZ0pnS29JQUVBSSt2YnRwZisrOG94YXRFZ0plWXhILy8yc0h2MzNNeFpXRlgxY0xsZkkyemEyMHlGQXRDRUFBRUVhT0tDdkpseHpxVkpTbW9VOHhrTVBQNjRubjM3UndxcWlVMnBxaTVDM0xTd3N0ckFTQUZVUkFJQWczWGJyOVdGdGYvK0RrL1RjQzY5YVZFMTB5eGpZTCtSdEMvYUd0NWdRZ0xvUkFJQUl1dWZlaC9UU3k2ODdYVWJFbkRyNjVKQzMzYnAxdTNXRkFLaUdBQUJFZ05mcjFSMTNQNmpYL3Z1MjA2VkV6S2lSdzhPYUFWaXpacDJGMVFDb2lnQUEyTXpqOGVpMlAvOU5iN3oxbnRPbFJFekg5S1AxeU1QM2hyejk5aDAvYVB1T0h5eXNDRUJWTEFRRTJLaTgzS09KdC96RnFPWS8rcFNUTkdQNnEySGR4ejhuakFXRUFBU0dHUURBSm1YbDVicng1anMxYzlac3AwdXhUV3hzckZLYUhhVmpqdW1nN0t3TS9mcmNNOVMzYjYrd3gzM24zVmtXVkFlZ0xnUUF3Q1pscFdWaExZUVREZjc3YXVUWEtmanlxMFZhRnNZS2dnQUN3eWtBd0NaTm1pVG9wUmNlMC9BVGozTzZsQWJENC9Ib29ZY2ZkN29Nd0FnRUFNQkdUWm9rNk1YbkoydkV5Y09jTHFWQmVIN0tWT1hrTG5lNkRNQUlCQURBWnZIeDhYcmgyVWMxYXVSd3AwdUphZ3UvL0ZZUC9mTXhwOHNBakVFQUFDSWdMaTVPenozOUw0MDVkWVRUcFVTbGI3NWRxcXNuVEZSWmViblRwUURHSUFBQUVSSVhGNmVubi9pblRoODd5dWxTb3NxNzc3MnZpeSs3VmdjUEhuSzZGTUFvQkFBZ2dtSmpZL1hFNHcvcHpETk9kYm9VeCszWms2K2JKdDZsbXliZXBlTGlFcWZMQVl6RGJZQkFrSEp5bDJ0UVJ2K1F0NCtOaWRIamsvK3VHTGRiTTJaK1pHRmxEVU4rd1Y2OTh1cWJlbjdLcXh6MUF3NGlBQUJCZXZpUkp6Vnl4QW02Nm9xTFFoNGpKc2F0eVpNZVVFeHNqTjZkL3I2RjFVV25nNGNPNmZNdnZ0Yk1XUjlyenR3RktpazU3SFJKZ1BFSUFFQUk3cnYvRVpXVmxXdkNOWmVHUEVaTWpGdVRIcjVQc1RHeGV2UHRHUlpXRjNsbFpXVXFPWHhZaFllS3RDZS9RTHQzNzlHbXpWdTFidDBHNVMxZnBSVXJWNnU4M09OMG1RQXFJUUFBSVhyd0g1TlZYbDZ1UC83aGlwREhjTHZkZXZpaGV4UVQ0OWEwTjZaYldKMDFMcng0Z3I1WStJM1RaUUN3QVJjQkFtRjQ2T0hIOWUvSG53OXJESmZMcFg4OGVMY3VHdmNiaTZvQ2dQb1JBSUF3UGZMb1U1bzArZW13eG5DNVhIcmd2anQwNmNXL3M2Z3FBS2diQVFDd3dPVEhuZ3Q3RFh1WHk2Vy8zWHU3cnJqOFFvdXFBb0RhRVFBQWl6ejU5SXQ2OEIrVHd4N25yM2ZmcW11dXVqajhnZ0NnRGdRQXdFTFBQUGV5N3IzL1gyR1BjOWNkRTNYdGhNc3RxQWdBYWtZQUFDdzI1Y1hYOUplL1BoVDJPTGYvNlFiZGNOM1ZGbFFFQU5VUkFBQWIvT2VWMTNYbjNRL0s2L1dHTmM0dEU2L1Z6VGRPc0tncUFEaUNBQURZNU5YWDN0THRkL3d0N0JCdzg0M2pkY3ZFYXkycUNnQitSZ0FBYkRUdGplbTY5Ylo3NWZHRXR3cmVEZGRkcmR2L2RJTkZWUUVBQVFDdzNadHZ6OURFVy84UzlsSzQxMDY0WEhmKytXYUxxZ0pnT2dJQUVBSHZUbjlmTjAyOE0rd1FNUDdxUzNUUFhiZFlWQlVBa3hFQWdBaVpNZk1qWFgvVG4xVldYaDdXT0ZkZU1VNzMvZlUyaTZvQ1lDb0NBQkJCczk3L1dIKzg3amFWbFpXRk5jNWxsMXlnQi85MnAxd3VsMFdWQVRBTkFRQ0lzQTluZjZMeDE5NmkwdExTc01hNWFOeHY5UGNIN2lJRUFBZ0pBUUJ3d0p5NW4rcnFDZitudzRjUGh6WE9oUmVjcDRjZnVrZHVOLzhyQXdnT2Z6VUFoOHliLzdtdUduK3pTa3JDQ3dIbi8rWnNUWHI0UGtJQWdLRHdGd053MElKUHY5VGxWOTJnNHVLU3NNWTU3OXd6TkhuUy9ZcUo0WDlwQUlIaHJ3WGdzQzhXZnFQTHJyeGVSVVhGWVkxenpsbW42ZkhKZjFkc1RJeEZsUUZvekFLK2VpaTk5ekRmZXFiN0MvYmFVdzBBQUFoSlNtb0wzODliVnkrc3Q3OHpBd0FBZ0lFSUFBQUFHSWdBQUFDQWdRZ0FBQUFZaUFBQUFJQ0JDQUFBQUJpSUFBQUFnSUVJQUFBQUdJZ0FBQUNBZ1FnQUFBQVlpQUFBQUlDQkNBQUFBQmlJQUFBQWdJRUlBQUFBR0lnQUFBQ0FnUWdBQUFBWUtOYnBBZ0NZcVYzNzl1cWZNVWpIcEtlclpWcWFFcHNrS2lZMlZpWEZ4ZHEvZjc5KzJMRkRXN2RzMHBwVnEvVFQvdjFPbHdzME9xNUFYNWplZTVpMzR1ZjlCWHZ0cVFhMjY5cTloNjRZUHlIc2NWNTQraWx0MnZCZHdPTi9NdnNqelp2emNkRHZjL0VWVjZsWG56N1Zmdi9BUFhlcjhOQ2hHcmNKOURONlBCNlZGQmZyNElFRDJybGp1NzVidDA3TDg1YnBjRWxKMEhWVzFhZGZmNDI3N0hLLzMwMTk2VVd0WHJraTZMRUMrVHdlajBmRnhVVXFQSFJJTzNmczBPYU5HNVdYazZQQ3dwci9HNFg2UG9HbzdkOUdoVlpwYVRyNzE3OVZsMjdkQWhyUDYvVnE2NWJOK21iaFFxM0lXNmJ5OHZLUTZySnlud1Fya1ArMjVlWGxLaTRxMHNFREI3UnQyL2Zhc0c1ZGpaODNKYVc1L25UM1gyeXJkZG9yTDJ0RjNqTGJ4b2Q5VWxKYitIN2V1bnBodmYyZEdRQkVSRVpXZHRBQm9HbHlzbnIwNm1WVFJaTGI3VlppVXBJU2s1S1UxcWFOQmd6SzFPbG5uYTJQWnMzVW9tKytEbXZzek1GRHF2MHVhOGdRMjVxTjIrMVdVbEpUSlNVMVZhdTAxdW8vTUVPbi9lb3NmVDUvbnViUG5STnkwN1JhdHg0OWROSGxWeW91TGk3Z2JWd3VsenAyNnF5T25Uckw2L1VxTHpjbnBQZU85RDRKVmt4TWpKb21KNnRwY3JMYXRHdW5yTUZEZE1iWjUyam05SGUxZkZtdTArV2hFU0lBSUNKYXRtcWw5STZkdEhYTDVvQzNHVGdvVTI1M1pDOVRhWktZcUhOK2U3NVNXN1hTN1BkbmhUUkcwK1JrOWV6ZHU5cnZlL2J1bzZiSnlUcDA4R0M0WlFZa05qWldJMGFmcW5ZZGp0WnIvM2xSSG84bkl1OWJtN1RXclhYUjVWZjROZjk5Ky9acTBWZGZhY1A2OWRxeiswY2RQbnhZaVVsSlNrMXRxZTY5ZXFuL3dBeWx0VzRkOW50SHl6NEpWdFBrWkYxdzhTVkthOTA2cEJrMG9DNEVBTVBOL2VoRHpaODd4N2J4UzBwS2xKQ1FJRWthbEowZFZBREl5TXF1Y1p4ZzFmWVpZMkppbEp4OGxJN3VtSzZoeHcxVDErN2RmYzhOSHpGU216WnMwTG8xcTROK3YwRloyYjdnNHZYK2ZPYk01WExKN1hZckl6TkxDei83TktUUFVhR216MU54OUhoTWVrY2RPK3dFdituMVhuMzY2S1NSbzRMZXoxYi8yemo5ckhNVUZ4ZnZlN3g4V2E3ZWVmMTFsWlllOW52ZHdRTUhkUERBQVczZHNsbnpQcDZ0M24zN2FkU1lNV3Jicm4zSTcyMzNQZ2xXYmZ1d1dVcUt1blRycnVFalJxaFYycEhnTTJyTVdPM1l2bDFyVnEzVS92MzdkT2N0RSt0OWp4NjlldW5TcTY2cDh6MWhOdTRDZ0sxV0xzL3ovZHgvWUlaaVltSUMycTUxbXpicWNQVFJrbjQrTjdwMjFVckxheXN2TDlmKy9mdTBNaTlQTHo3N3RENWZNTi92K1pOUE9TV2tjVE1IRC9iOXZQRzc5WDZoSjZ1R2FXZ3JsSmVYNjZmOSs3VnllWjZtUFBPVVBwcy96Ky81RTBlTVZIeDhmQzFiMjY5WnMyYnEzck9uNy9HZTNUL3FyZisrVnEzNVYrWDFlclZxeFhJOStlZ2t6WDUvVnIydnI0MFQreVJZNWVYbDJsdFFvQ1hmZnFNbkprM1MrclZyL0o0ZmMvb1pjcmtDdm13THFCY0JBTGJhK04xNjdkKy9UNUtVbUpTa1huMzZCclRkb093amY3RFhyRnFwd3NKQ084cnpNK2ZERDN5MVNsSjZ4MDVxa3BnWTFCZ2RqamxHYmRxMjh6M09YYkpFdVV1VytCNjNhZGRPN1RzY0hYYXQ5Zm40Zy9mMTQ2NWR2c2NKQ1FucTNMV3I3ZTlibTA1ZHUvazFyOFhmZkJQVWRRa2VqMGVmelorbjFTdURENExSc2srQ1VWcDZXRys4TmxVbHhjVyszN1Z1MjFadDI3V3JZeXNnT0FRQTJNcnI5V3JaMHFXK3h4bFpXZlZ1NDNLNU5EQXowL2U0OGg5ck81V1hsMnZqK2lOWHI3dGNMcVdrTkE5cWpNcEhrNldscFZxNVBFL0xsK1g2TmJ1c0lmWWZjWHE5M21wWGNqdlo1Sm8xYStiM2VQZVB1MnA1cGZXaVpaOEVxNml3c05yRmY1MjZPQmZpMFBnUUFHQzduTVdMZkQvMzdOMUhTVWxONjN4OWwyN2RmSTIzc1BDUTFxNWVaV2Q1ZnFyZVdoZ1hIL2pWNnJHeHNSb3c2RWh3V2JOeXBVcEtTbFJVV09qM0dRWU1HaFR3cVpCd0ZPelo0L2U0YVhLeTdlOVptNm9YYzdyZDluOStLZnIyU2JDMmI5dm05N2haU29wRGxhQXhJZ0RBZGovdTJ1WDdReFlURTZQK0dSbDF2bjVRMXBIcC83eWNuSWpld3BiVTFEK2NCSE4xZU8rKy9aUlk2WlJCN3RJbE5mNmNsTlJVdmZ2MkM2UEt3RlE5WCt6aytlT0RCdy80UFU3djFDa2k3eHR0K3lSWXhaVk9BVWhTUWtJVGh5cEJZMFFBUUVUa0xsbnMrM2xRZG5hdHI0dVBqMWZmL3YwcmJSZVo2WC9wNTNCUytlcjVRd2NQYXQvZXdCZTlxbnlmZVdIaEliK0x1TmF1V3FYaW9xSWFYMnVYMUpZdC9SNGYrT2tuMjkrek5sczNiL1o3UE9TNDQvM095OXNsMnZaSnNKbzA4Vy80eGNWRnRid1NDQjRCQUJHeExHZXA3ejcwWTlJN3FtV3J0QnBmMTdmL0FNWC9jcnZmbnQyNzlmM1dMUkdyY2RTWXNVcHAzdHozZU9uaVJiNWJ4dXJUckZremRldlJ3L2Q0ZWE3L0NtNWxaV1YrNStTNzkreXBvNnFjRjdlU3krVlN2NEVaZnIvYlVxVUpSOUtlM2J1MWVkTkczK09FaEFSTnVPRkdqUm96VnMyYnQ2aGp5OUJGMno0SlJjV2RNQldjREhGb2ZBZ0FpSWhEQnc5cTNab2pSMSsxelFKVXZ2ZS84cXlCSFNydXUrN1RyNzh1dTJhOFRobzV5dmZjN2wyN2dycG5lbEQyWUwvejNMbExxOWRlZWNyWjdYWnJVRmJ0TXlIaE92WDBNL3dXME1uZnMwZWJOMjZ3N2YwQ01mUGRkM1g0OEpIYitPTGo0elZ5OUttNjlhNjdkY010dCtyc1gvOVdnNGNlcXc1SEgyM0orZmhvMnlmQlNreE1WUDhxSVc3enhvMDF2eGdJQVFzQkdlNlVzYWZwbExHbkJiWE55cnc4L2ZlVi93VDlYamxMRnZuVzljL0l6Tkluc3oveU84SnUxcXlaYnpFZXI5ZnI5OGM1SE1GOFJvL0hvK1c1T1pvMTR6Mi9XN0RxVS9rKzg3MEZCZFdtdktXZi8zanYyN2ZYZDhTYm1UMjQydjM2b1hLNzNiNkZnSTQ3NFFSMTZYWmtVU09QeDZNWjc3d2Q4R3hHQmF2L2JmeXdjNGRlZnY0NVhYREpwVHJxcUtQOG5tdlR0dDB2cHdTT2svVHpiWEJiTjIvUmlyeGxXcDZibzZLaTRLZStuZDRuNFlpTGk5TnZMN3hJQ1pWT0FlemV0VXMvN056aFlGVm9iQWdBaUpnMUsxZXF1S2hJVFJJVDFTSTFWUjA3ZC9FN0tzM0l5dlpkcUxaNTQwYnRMU2lJYUgwbEpTWDZZc0Y4ZmZuRjUzN25odXVUM3FtVDM2cHR0UVdYaWxzaUsyWWEwdHEwMFRIcEhZTSt6UkZNWXk0cEtkRTdiMHpUaHZYcmdub1B1MnpldEZHVC8va1BuWGp5Q0EwNTdyaGE3d2lKaTR0WDErN2QxYlY3ZDQwOTgxZjZmUDQ4ZlRaL1hzQVhoRVo2bjFnaEppWkdSeDNWVEYyNmQ5UHdrMGNxclUwYnYrYy8vdkNEb0VNY1VCY0NBQ0ttckt4TXkvT1dhZkRRWXlWSmc3S3lxZ1NBSTJzRTJEMzlYNU9FaEFTTkdqTldKNTQ4UW5ObmY2UXZQLzhzb0QrNFZWZVNXMWJIekVYdWtzVitweG95QncrMnBkbDR2VjU5OGVrQ2ZmSHBBaDA4Y0tEK0RTS291S2hJY3o3OFFQTStucTF1UFhxcVc0OGU2dGk1aTlxMGJhdlkyT3Ava2hJU0VuVEsyTlBVclVjUHZmTGlsSUJtWnFKeG4xUVc3T3pLZ2svbWF0V0s1VFpXQkJNUkFBd1g2ZlhCY3hZdjhnV0FmZ016TkhQNnV5b3JLMVA3RGgxOFY0VlhCQVdyMVBZWlhTNlg0aE1TMUxKbFMzWHAxbDNIblhDaW1yZG9vZmlFQkoxKzF0bHEyYXFWL3ZmdU8zV09IUmNYNTNlZWR2dTJiZHI5NDQrMXZ2N0hYYnUwYzhkMnRXdmZRWkkwSUdPUTNwL3huc3JLeWtMN2NMVnd1VnpxTjJDZ1Z1YmxoUndBN1A2M1VWNWVycldyVi9udXgzZTczVXByMDBhZE9uZFdqMTU5MUwxblQ3OXJBVHAxNmFyZi9uNmNwcjQwcGM1eG8zV2ZoS0t3OEpBKytOOE01U3lPZkNCRzQwY0FRRVJ0MmJSSkJmbjVTbTNaVWsyYU5GSHZ2djIwZkZtdTM5Sy9xMWVzQ09yOGU2aThYcTlLaW91MVkvdDI3ZGkrWGQ5KzlhVXV1ZklxZGU3Njg2MkFRNDhmcHMwYk45YjU5Yk45Qnd6d08wOWIxNUZtaGR3bFMzek5wa2xpb3ZyMEg2QzhuS1gxYkhWRTFjYnNkcnQxVkxObWFwV1dwcUhIRDFPZmZ2M2xjcm5VSWpWVmw0K2ZvQ2xQUDFsdFFabG81UEY0dEd2blR1M2F1VlBmZlBtbG1yZG9vVitkZTU3Zjh0RzkrL1pWOXg0OXRYN2QybHJIY1dLZldNSGo4YWk0dUVnSGZ6cWc3ZHUyYWNQNmRWcStMRGNxZ2dnYUp3SUFJaTUzeVdLTlBIV01wSi92QmxpNVBFOERNZ2I1bnM5WnNxaTJUVzExK1BCaHZUMXRtaWIrK1E3ZmtlZklVOGZVR1FBcVR6VjdQSjZBbXNheW5LVWFjOGFadml2VU13Y1BEcXZaZUR3ZTdkKzNUL3YzN2RPRzllczFZRkNtenI5d25Gd3VseElTRXZTN2l5N1JFNVArNVhjRmZrT3diKzllVFgzcFJWMTh4WlhxMmJ1UDcvZURCZyt1TXdCRXd6NnBEOS9NaDJoQUFFREU1VlFLQU4xNzlsSkdWcGFTZjdrcS9PQ0JBMXEvdHZZLzduYmJ0Mit2dnQreTJiZm1lbHJyMW1xVmxxWTl1M2RYZTIzekZpMThzd1hTejBmaXQ5OXpiOUR2MmExN0Q2V2tOUGY3SXFKdzVPVXNWYnYyN1RWOHhFaEpVc3RXclRScXpGaDlPUE4vbG93ZlNWNnZWM00rL01BdkFLUjM3RlRyNjZOMW53RFJpSFVBRUhFRitmbStXN0xjYnJmT1BPYzgzM041dVRtK0JZT2NrbDlsRGYyMDFtMXFmRjFtOW1CTGx0ZDF1Vngxcm80WWlrOW1mK1MzaXVHeHcwNVFpOVJVUzk4alVuYnUyT0gzTmNESlZXNGhyQ3lhOXdrUWJRZ0FjRVRsYWY2RVgxYitrL3kvT01ncExwZi8veFp4OGZFMXZNYmxkOTFDdUNyZnMyNkZzckl5emZ0NHR1OXhiR3lzYjlhbElmS1VId21GdFFYRWFOOG5RTFRoRkFBY2taZWJxelBPUHRmdnRxOGZmL2hCTzdadmQ3Q3FuNlcyOGw5RHYvQlE5UzhFNnRTbHE5OWErOTk4dWJEZU93YXFPdVBzYzNUOGljTWxTUzFicGFsanA4N2FzbmxUQ0JYWExHZkpZbzBZZmFydnlEOGpNMHZ6NTN5c2d2eDh5OTRqRWxKU212dGQxRmZiY3JnTllaOEEwWVFaQURpaXVLaElhMWF0OVB0ZGpnUDMvbGZWSWpWVng2UjM5RDMyZXIzYXRYTm50ZGRWUFRvTTVVdUxxcTUxa0dueGQ5SjdQQjU5T3U4VDMyTzMyNjJUUnAxaTZYc0Vha0RHSUkwNFpYU045L25YNS9qaHcvMGVWLzVPZ2NvYXdqNEJva25BL3pkdVhiM1FsZDU3bUZlU1VsSmJhSDlCNE4rU0J0UmsyaXN2TzEyQ24vaUVCUDNtOXhmNjNYdStlZU5HSGFoeUgzMThRb0w2RFJqb2UxeVFuNit0V3pZSC9YN2J0MjNUN2wyN2ZDdSs5UitZb1ZuVHAvdWQ3dzdYMGtYZmFzVG8wVXBKYVM1SkdwU1ZyZmx6UGc3cVd3NnRFUC9MWWo3WlE0L1Y1d3ZtSzJmeElwV1VsTlM3M1hFbm5LaGh3MC95KzExTmpiMGg3UlBBRGltcFI3NVVhK3ZxaFFGZENNTU1BSXhWY1p0Y3UvWWRkTUpKSit2R1cvK2tUcDI3K0o3M2VyMzZhTmJNYXR2MUg1aWgrRXJYQllUem5RVzVPVWUyVFVoSVVMOEJBMEllcXlibDVlWDZmUDU4MytPWW1CaS9WZThpcmVMZS90dnV2a2ZuWHpoT1dVT0dxblhidGtwS2FpcTMyNjJFSmszVXJuMTdEVDMrZVAzaHhwdDA1am5uK2wzVXR6dzNWNXMyZkZkdDNJYTBUNEJvd1RVQWhndmxDMThrNmV1Rlgyam05SGR0cU1oNm9YeEdyOWVyZDk2WXBtM2ZiNjMybkJWVHpaVzNQV1hNYWI0bWx6bDRpT1duUWhaOS9aVk9HbldLN3d0NHNvWU0xWUs1Yyt1OXhjM09meHNKVFpwb1lHYVdCbVptMWZtNnl0YXZXNnQzM3BoVzQzTU5iWjhBMFlBWkFLQ0tYVC9zMVBOUFBWSGo4cXN0VzdYeW15WFl0bldyOHZkVVh5TWdVUHYyN3ZYN2xyck9YYnRhZnJ0ZVdWbVp2bGpnUHdzd2ZPUklTOStqUHJsTEZtdmFxeTlyN2VwVkFYK2hUNFhDd2tPYTlkNTB2ZkxDOHlvdExhMzJmRVBjSjBBMFlBWUFSaXN0UGF6aW9tTGw1Ky9SOXUrLzE2b1ZLN1JsMDhaYXZ3UW9NOXYvb2pBcnZySTRaOGxpZGV6Y1dkS1JXOWtxMzhKbmhXKy8rbElualJ5bHBLWS9mL3RlOXRCanRlQ1R1YlZlVVcrMXNySXlyVmkyVEN1V0xWTjhRb0s2ZHV1bVRsMjZxbTI3OW1xVmxxYkVwQ1RGeGNXcHRMUlVKY1hGS3NqZm81MDdkbWpEK25WYXQyWk5uYUdob2U0VHdHbEJyWmhSY1JHZ0pDNENCQUFnU3RoK0VXRGxRU3UvR1FBQWNFWW96Vi9pR2dBQUFJeEVBQUFBd0VCaEJRQk9Bd0FBNEp4dytuRFFBU0NZOHdzQUFDQXlndTNQbkFJQUFNQkFCQUFBQUF3VVVnRGdka0FBQUp3VjZ1MS9GWmdCQUFEQVFDRUhBR1lCQUFCd1JyaEgveEl6QUFBQUdNbXlBTUFzQUFBQTlyT3EzNFlWQUZnVEFBQUE1NFRUaHkwOUJjQXNBQUFBOXJHeXo0WWRBSmdGQUFBZzhzTHR2NVpmQk1nc0FBQUExck82djFvU0FKZ0ZBQUFnY3F6b3U3YmNCc2dzQUFBQTFyR2pyMW9XQUpnRkFBREFmbGIxVzB0bkFGZ2RFQUFBYTFteDZsOU5iRjBKa0JBQUFFRG83T3lqbGdlQXF1bUVFQUFBUVBDcTlrK3JUN1hiTWdQQTlRQUFBRmpIanI1cTJ5a0FyZ2NBQUNBMGRwMzNyeXhpM3daSUNBQUFvSDZSNnBlMkJnQ3VCd0FBSUhCMm4vZXZ6UFlaQUVJQUFBRDFpMlR6bHlKMENvQVFBQUJBN1NMZC9LVUlYZ05BQ0FBQW9Eb25tcjhVd1FBZ0VRSUFBS2pNcWVZdlJUZ0FTSVFBQUFBa1o1dS81RUFBa0FnQkFBQ3pPZDM4SlljQ2dFUUlBQUNZS1JxYXZ5UTV2bVJ2ZXU5aDNxcS8yMSt3MTRsU0FBQ3dUVTBIdWs0dW5lL1lERUNGbWo0OHN3RUFnTVlrMnBxL0ZBVXpBSlZWblExZ0pnQUEwTkJGeTVSL1ZWRlJSR1djRWdBQU5BYlJlTlJmV2RRVVVsbE5JVUFpQ0FBQW9sOXRwN0dqcWZsTFVSb0FLaEFFQUFBTlJVTnAvQldpc3FqS2Fnc0JFa0VBQU9DOHVpNWNqOWJtTHpXQUFGQ0JJQUFBaUNZTnRmRlhpUG9DcXlJSUFBQ2MxTkFiZjRVR1UyaFZkUVdCQ2dRQ0FFQzRBbG1icGlFMS9nb05ydUNhRUFZQUFGWnFyRTIvc2daZGZGV0JCSUdxQ0FZQVlLNVFWcDV0NkkyL1FxUDRFRFVKSlF3QUFGQ1R4dEwwSzJ0MEg2ZzJCQUlBUUtBYVk4T3ZxdEYvd1BvUURBREFYQ1kwZWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUlYK0h4clZMZXNnWGxEdkFBQUFBRWxGVGtTdVFtQ0MiLCAidHlwZSI6ICJpbWFnZS9wbmciLCAic2l6ZXMiOiAiNTEyeDUxMiIsICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSJ9XX0=">
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAM70lEQVR4nO3deVjUdR4H8DfDYEAaIm1ZCXikIgiKDOBdupVpeXR4pU9qrfo8urVlh225ubb1tNuWPbuulqWl5ZFHXpuaynqVF4KcAoqKEl4ol6gwwMzsH4rOODPM/GaGY+bzfv2T/b6/+f6++HzefL+/ywGIiIiIxPGqr45DuvQx1FffJFN+9j6X16vLOmTBU0NzRSCc7sBa4ZcVlzjbNZGJgFaBFrc7EwSHP2ip8Fn01FAshcGRIDgUAOPiZ9FTYzMOg9IQqJQejMVPTY1xHSo9F7U7LSx8cgdKZwO7ZgAWP7kLpbOBoiUQi5/cgZI6tRmA2hSx+Mmd1NarrVmgzgCw+Mmd2RMCqwHgnV3yJNbqWW3rg5J++896PAl6AAYvQO8FGHDzv3f8uXYf4z/X7t/UPwsAGQs0Dfi32rjKikus3kEGrMwAXPqQJ6lrKaT4RhiRJzELANf+5MnurG+rMwCXP+RJrNUzl0AkGgNAopkEgFd/yJNZuhpk8z6AJB/ukHN93JKKb1dbbfObNKoBR9JwuAQiAHUXvz3t7ooBINEYABKNASDRGAASjQEg0RgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINEYABKN7wN4kGfmplptWz+je4ONw51wBvAQdRW/Pe1SMQAkGgNAojEAJBoDQKIxACQaA0CiMQAkGgNAojEAJBoDQKIxACQaH4ZzoY2vpFttGz4vqgFHQvbiDOAidRW/Pe3UOBgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINEYABKNASDRGAASjQEg0TzqadBZjydZbftwh6YBR0LuwmNmgLqK3552ksljAkDkCAaARGMASDQGgERjAEg0BoBEYwBINAaARGMASDSPehTCWQv7J1ttm7o3pgFHQg2FM8BNdRW/Pe3knhgAEo0BINEYABKNASDRGAASjQEg0XgfoAnpOt36W2uZ8/lKZ33gDNBE1FX89rSTYxgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINE8JgAf7qj7G1Rstdv6Jnhb7cPnRTnVbusbYGy1r5/R3al2v0mjnGp3V17G/xPSpY8BAMqKSxpnNET1LKBVIAAgP3ufF+BBMwCRIxgAEo0BINEYABKNASDRGAASjQEg0RgAEo0BINEYABKNASDR1I09gKZs4otj8MFfZ5psO557Eo8Net7i/uFdOmH5918i6ObzJrXOnj2P0eOmID+/wGq/d9Lp9Lh69SrOX7iI9IwsbNmSgN1790Ov1zs9TrqNAXCRblERWLZ0AQIC7jHZfvrMbxg7bgrOnrugqD9vbxUCAu5BQMA9COvcEaOeH46MzGz8acZ7OHEiz5VDF41LIBeI1URj5bKFZsV/4kQenh/9kuLityayaxesWbkIISFtXNIfMQBO69M7DsuWLkDz5nebbM/KPo6RY15GYeFllx4vKKgV5rz/lkv7lIwBcMLAAf2wZPE8+Pn5mmxPSz+K0S9MRpGC9yqO555ESPtohLSPRmiHHugR9xhemzELRUXFZvsOeLQvgoJaOT1+YgAcNuTJ32PRwrm4665mJtuTklMxdvxUlJVdcbhvg8GAy5eLsG7DZrz95w/M2lUqFSK7hjncP93GADjgmeFDMH/eJ1CrTa8h7D+QiPETpuHq1WsuO1Za+lGL21sGBLjsGJIxAAqFBLfB55/9Dd7epn91u3bvw4SXXsH16xUuPV63qAiL20vLylx6HKl4GVQhX9+7zLZt274L016ZierqapcdJyioFfr37Yn3Z71h1qbX65GRmeOyY0nGADipqLgEr82Y5XTxd+rYAfmnUuzad9fuXy2eHJNyXAI5KahVIBZ+8anFmaE+FBUVY/YH/2yQY0nAALhA/369sGTxPPj7+9XrcTIyszFy7B9uPVJBzuMSSKH8/AIUnD2H3r3iTLb37hWLZUsX4MVJf3TJVSCdTo9r167h3PkLyMjIxuatCdizdx90OvNngchxDIBClVotJr78Kr7+ci4e6d/bpE0T0x0rvv8S4ydMw5Ur5Yr65cNrjYNLIAdUVmrx8pTXsSNhj1lb925dsWr5VwgM5HV6d8AAOKiqqgpTp72JLVsTzNoiIsKwasXXfFzBDTAATqipqcH0V2diw6atZm1hnTtizcpFuO++exthZGQvBsBJOp0er82YhdVrN5q1PfxwO6xd9Q0efKB1I4yM7MEAuIBer8dbM+dg2fK1Zm1tQ4OxdtViBAc/1AgjI1sYABcxGAx49y8fYfE3y83a2rR5EGt+WIS2ocGNMDKqC78fgETh9wMQGWEASDQGgERjAEg0BoBEc+uH4Z4bMxY9NLFm2wsvXMC/Pv3EZJ8jSYfx4w8rTfZ78umh6PfoAOQey8GSr7+y2GdFRQXOFRRg+5bNKPgt3+xYDz70EKa//gbyT5/Gwv/82+r49Ho9ykpLkZWZgYRtP6NKq1X0c/j6+mLgE4MQ3jUSzVu0QElREdLTUnHgl72orKy0e0yWWBpnRloqft2zG+/+1fylfGOJBw5g449rbB6jqXLrAABA3smTWPTF/Dr3KS0pQWS3bvhpw3pobxaLt7c3omM0KC0xv+Rr3GfzFi0wZNhwTJw8BR/PmQ2dTmeyrya+Fwp+y0dwaCh+d//9uHTxosW+VCoVgkNDMX7SS1CrfbBp3VqL+1kz8oVxaBkYiJXfLUHhxYtoGRiIyO7R6BEbh/2/7FU0Jktqj+/t7Y3Qdu0xbuIkNGvWDO+9OePWPj379MXgocMw+523bfbnLkQsgS4VXsSF8+cR1T361raw8AhotZU4k3eqzs9eLS/H4YMH4efvj5aBpg+3+fj4oFuPHti5fRtO5uZCExdvtR+9Xo8zeXlITU5G5/AuisavVqvRKawLft2zG2cLClBdXY1LhYXYuX2bWfErGZMlOp0Op07kIiXpMMIiLL+Q70lEBAAAkg8dQkzc7ZdYNPHxSE5MtPm5u5s3R0xcHIqLilBaYvoebteobtBWVuJ4Tg4OHzyA6BgNvL29bfap9lY28ep0OlRVVaF9h442+3d0TFK5/RKoXYcO+OjTuSbbkhIPYf3qVSbb0lNTMGT4CNzXujW0FZXo0LET1q1ehcFPD7XZZ3l5OZZ/+42F5U88khIPwWAwIPtoJoY+8yzCIiJwND3drE+VSoXgkFB0j4lBanKyop/DYDBg049rMWLkKIRFhONM3mnkn85DVmYGLl+65PCYLFGpVAht1w7RMRqkpRyx6zPuzO0DYM85AABotVpkpqVBExuPisoK5B7LQfkVy/96m3Gffn5+6NWvPyZOmYr5n3+G4qIiAEDQvfcipG07rF5x49kfnU6H5MOJ0MT1NCm2Ows7KzMDW/+7SfHPkZZyBLnHjqFj584IadsWmvh4PD54CH7asA6H9u9XNCZLasdZexKcnJiIhG3mj3l7GrcPgBJJiQcxbsIkVFVVYfPGDXZ9pqKiAju3b0OvPn3RIzYOCT/fKApNfE+oVCq8Pet9k/0NBgMCWrZEWWkpgNuFrVarER4ZhedGj0F410hkpqcpHv/169eQlnIEaSlH4OXlhWdHj8HgocNw+OBB6PV6u8dkib2/SDyNqACcyctDRcV1+Pr64Vh2lrIPe+HWWlqlUiFaE4sfln2HjNRUk90mT5uOmNg47Nyx3WR7TU0N0lOOoPUDD2DYs88h91gOtEaXQpUyGAw4k5eH6BgN1D4+qKmuVjwmEnQSXOvzf/wdH8+ZbfGbVizx8/PDwCcGwdfXD9lHMwEAnbuEw9/fH8dzzP91tqzMTMTExcPLy8usDQD2/O/GK5T9Bgy0e8xqtRqTp01HRGQUAgJawsfHB8Ghoejb/xGcOpGLKq3WqTFJ5vYzgKWTx6qqKsx59x2X9KmtrERh4UWsWPot8k+fBnDjRPNkbu6tewrGsjIzMGTYcDzcsZPFvrVaLXYl7MCgp57Cof37bp2H1PVz1NTUYMfWrejVtx+eGjEC/v53o/zKFeRkHb31W93eMeUeP+bw34sn4vsAJArfByAywgCQaCYBqJ0WAu74mk8iT3Dn8gfgDEDCMQAkmtUAcBlEnsRaPZsFwHh9RORp7qxvLoFINIsB4NUg8iSWrv7UsjkDMATkzmzVr9UA8FyAPIm1eq5zBuBSiNxZXUufWjaXQAwBuSN7ih9QeBWIISB3oKRO7QqAcYoYAmrKjOvTnvNYxSe6te8MAHxvgJoOpYVfS/GNMM4G1NQ4WvyAAzNALeOZoBZnBGooln75OnLp3ulr/ZaCADAM5HrWVhzO3LNy2c0ua0Egqi+uuFlbb3d7GQhyNT6dQERErvN/eM/pA0axPm4AAAAASUVORK5CYII=">
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAFo0lEQVR4nLWXTYwcVxHHf/Ved8/MzuwGe73erD9ib4IiEjsWUhzbBPFlHBAkEiLCIA4gISEl4mABwYAVJAISEiAhIY4ckDiARCROHAgHLnxIoEjIiBBDHGcDNrZxvOv17Hx09/soDj2TzXpnvWOc1KWnp6te/etV1f+9EsAA8e4Dj2zPi5XHo497iRFAuEGsScGYG/9G17xFonfrdADFGIyVK/WJ2q9eOf27s3DcCsCOdzz8LtfPf+adn0d1lDEg5L5NjB5BKnRaoRRAdOBDEmx9CkQYBLIGqIhgrV3OGrUnLr70p2dlfv/R2ZXrS6dd6e5UjV5GRF4ZK4f2fIZmc46cEm8FZ8AbcBacKCFN6fUu89pffop4D1lWARnGJKCKgiRploZma/Jwkvc7x2OIlXORZIPwUY3cPXOErVvuo02fMjUUFvKE6mkjrj7B8uLfee3Ms8TZHZiLF8D7CsQQgwCqPoaYlEX+RBJD2KuqulHkQzFi+fnzT6Ia1ykO3yXJkJU28f0fpvj6M9RPfB6zcA7qDdA3pENEVFVjDHclIuLZxPlQrEk3+CKAUvZXSEIAY0F1TeQjjUSCGdf5GksRrLG8XoIaEWN54GNfYfu9RwhlD5H13TJqqbG01lgg+OC43l8magARVAM2rfPOT5xg7oEPEooeMqJdR8kYWsNGqyL30THdmuUj+x+nkTUrEIMUFB2PL3ubbf2tAVANRPWVshh6rsuBXYf4wad+yNwdu3C+QAYOxdhxt348AIqS2gb1ZBJFETEYDD56VvKAbkhabwIAI5bcrfDYvm/w2Yd+TIglRegR1CMYjNjbdn5TAEOZSN9GM5sGhL2T+7gj2/Z6SipZrZG3BEDUgAs5NdvgWw/+kqM7P03Pr2AGPjU6NI48fN4cAMMIBanqYNgRBkLRYe49J9n72I/QUCKb0ekI2ZD7xxHVSH3mXia23f9/r3HLRLQOhMuJrvdWAlB0cJ5Wz8HvYQsKq8Sjq983vlfcIgAjCVZSBCGRBCMV2aRWKgIyCWJSQDCJQYytAKXpWIy4aQ303DK1cpGgnuXyKnnoUvg+i902Ljgo2vj+Eho9eXsJl3eQskSWFsG5TUHInfMHv1fkxVdj8AFZyy6Kkpo6RixF6NCwk+S+j00Eqxm57xJISJIUiTmSTiDREWJAGhPQ627kN4gYm9WzX980BYLgQp/CdxAMuXZoNDO63R6TW2rU63X27JhmasJQOk8zheBLRBVW2pttLjBGCkQsIkI/77P//vt46ktPcuYfZ3HOcXVxieMff5Tldoff//HPHDn0IF848bXByslYhTgGD1SLGBG6vS6PfvQYe+7axbsPH+apU98EgVarybbprTQatVUiGrMLxiIiESGqMjnZ4sUzL7Hw6r/54smnsdZSOs+XT5xkamaWR469jxAC1o5/UN0UwLDXnXOgyn8uXOTU09/h9F9f4NjR93Lx0mWe+81vObtwnt1qeObb36/AxoiqYo3ZtAsSbhxsBhF779myZSvTMzOoRrKshrWWc69eYG7HTk6/8E+SJEFVOXDwIdrL13l54Tyt1iSTU1PMzG6n3+uzcO5l4g0DyhtjTFR1JAhVJc0yslqGRqXVamGtZX5+nhACzVaLXrcDIvz30mV27t5FLatx4fx5slrGtaUlNEa8c9gB0BFbbBNj7BVERFk9yVSVJElYWrxKt7NCnhfE4Kk1GqBKWZZYa4kxUqvXCd6zvHyNsiiqy6gq3nvSNMVYO8J5xdkiZlHevu8D91xrL/3NFa4hqB9c6oaET9SIkSqXw600xqCqCBBVq+lLwRipxoEqj5XO2hoQUNWISWs1mWg1P1QNp/cc+WRRFj8J3jfXtY+MStBtSDWckmXpqUuvPP9dYTCe797/8EHf958LIewBvb171mhRACPmSq1R/8W/XvzDc4D5H7lijMm6lDmNAAAAAElFTkSuQmCC">
    <title>Sistema de KPIs v90 - Produção e Encomendas</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root { --bg-primary:#0f172a;--bg-secondary:#1e293b;--bg-card:#1e293b;--bg-card-hover:#334155;--text-primary:#f1f5f9;--text-secondary:#94a3b8;--text-muted:#64748b;--accent-green:#10b981;--accent-green-soft:rgba(16,185,129,0.15);--accent-blue:#3b82f6;--accent-blue-soft:rgba(59,130,246,0.15);--accent-amber:#f59e0b;--accent-amber-soft:rgba(245,158,11,0.15);--accent-red:#ef4444;--accent-red-soft:rgba(239,68,68,0.15);--accent-purple:#8b5cf6;--accent-purple-soft:rgba(139,92,246,0.15);--accent-cyan:#06b6d4;--accent-cyan-soft:rgba(6,182,212,0.15);--border-color:#334155;--shadow:0 4px 6px -1px rgba(0,0,0,0.3);--radius:12px;--radius-sm:8px; }
        * { box-sizing:border-box;margin:0;padding:0; }
        body { font-family:'DM Sans',-apple-system,sans-serif;background:var(--bg-primary);color:var(--text-primary);min-height:100vh;-webkit-tap-highlight-color:transparent; }
        
        /* PWA - Safe area para iPhones com notch */
        @supports (padding: max(0px)) {
            .app { padding: 20px; padding-top: max(20px, env(safe-area-inset-top)); padding-bottom: max(20px, env(safe-area-inset-bottom)); }
        }
        
        /* PWA - Standalone mode */
        @media all and (display-mode: standalone) {
            .header { padding-top: 10px; }
        }
        
        .app { max-width:1600px;margin:0 auto;padding:20px; }
        .header { display:flex;align-items:center;justify-content:space-between;padding:20px 0;margin-bottom:24px;border-bottom:1px solid var(--border-color);flex-wrap:wrap;gap:12px; }
        .header-left { display:flex;align-items:center;gap:16px; }
        .logo { width:48px;height:48px;background:linear-gradient(135deg,var(--accent-blue),var(--accent-purple));border-radius:var(--radius);display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0; }
        .header h1 { font-size:24px;font-weight:700; }
        .header p { font-size:13px;color:var(--text-muted); }
        
        /* Loading spinner */
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-spinner { display:inline-block;width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin 0.8s linear infinite;margin-right:8px; }
        .btn { display:inline-flex;align-items:center;gap:8px;padding:10px 16px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;cursor:pointer;transition:all 0.2s;border:none;font-family:inherit; }
        .btn-primary { background:var(--accent-blue);color:white; }
        .btn-primary:hover { background:#2563eb;transform:translateY(-1px); }
        .btn-secondary { background:var(--bg-card);color:var(--text-primary);border:1px solid var(--border-color); }
        .tabs { display:flex;gap:4px;background:var(--bg-secondary);padding:4px;border-radius:var(--radius);margin-bottom:24px; }
        .tab { padding:10px 20px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;cursor:pointer;transition:all 0.2s;border:none;background:transparent;color:var(--text-secondary);font-family:inherit; }
        .tab:hover { color:var(--text-primary);background:var(--bg-card-hover); }
        .tab.active { background:var(--accent-blue);color:white; }
        .kpi-grid { display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-bottom:24px; }
        .kpi-card { background:var(--bg-card);border-radius:var(--radius);padding:20px;border:1px solid var(--border-color);transition:all 0.2s; }
        .kpi-card:hover { border-color:var(--accent-blue);transform:translateY(-2px);box-shadow:var(--shadow); }
        .kpi-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:12px; }
        .kpi-icon { width:40px;height:40px;border-radius:var(--radius-sm);display:flex;align-items:center;justify-content:center;font-size:20px; }
        .kpi-icon.green { background:var(--accent-green-soft); }
        .kpi-icon.blue { background:var(--accent-blue-soft); }
        .kpi-icon.amber { background:var(--accent-amber-soft); }
        .kpi-icon.red { background:var(--accent-red-soft); }
        .kpi-icon.purple { background:var(--accent-purple-soft); }
        .kpi-icon.cyan { background:var(--accent-cyan-soft); }
        .kpi-trend { display:flex;align-items:center;gap:4px;font-size:12px;font-weight:500;padding:4px 8px;border-radius:20px; }
        .kpi-trend.up { background:var(--accent-green-soft);color:var(--accent-green); }
        .kpi-trend.down { background:var(--accent-red-soft);color:var(--accent-red); }
        .kpi-value { font-size:32px;font-weight:700;font-family:'JetBrains Mono',monospace;margin-bottom:4px; }
        .kpi-value.green { color:var(--accent-green); }
        .kpi-value.blue { color:var(--accent-blue); }
        .kpi-value.amber { color:var(--accent-amber); }
        .kpi-value.red { color:var(--accent-red); }
        .kpi-value.purple { color:var(--accent-purple); }
        .kpi-value.cyan { color:var(--accent-cyan); }
        .kpi-label { font-size:13px;color:var(--text-secondary);margin-bottom:8px; }
        .kpi-progress { height:6px;background:var(--bg-primary);border-radius:3px;overflow:hidden;margin-top:12px; }
        .kpi-progress-bar { height:100%;border-radius:3px;transition:width 0.5s ease; }
        .kpi-progress-bar.green { background:var(--accent-green); }
        .kpi-progress-bar.blue { background:var(--accent-blue); }
        .kpi-progress-bar.amber { background:var(--accent-amber); }
        .kpi-progress-bar.red { background:var(--accent-red); }
        .kpi-meta { display:flex;justify-content:space-between;margin-top:8px;font-size:11px;color:var(--text-muted); }
        .section { background:var(--bg-card);border-radius:var(--radius);padding:20px;border:1px solid var(--border-color);margin-bottom:24px; }
        .section-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:16px; }
        .section-title { font-size:16px;font-weight:600; }
        .chart-container { height:300px;position:relative; }
        .data-table { width:100%;border-collapse:collapse; }
        .data-table th,.data-table td { padding:12px 16px;text-align:left;border-bottom:1px solid var(--border-color); }
        .data-table th { font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);background:var(--bg-primary); }
        .data-table td { font-size:13px; }
        .data-table tr:hover td { background:var(--bg-card-hover); }
        .status-badge { display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:20px;font-size:11px;font-weight:500; }
        .status-badge.excellent { background:var(--accent-green-soft);color:var(--accent-green); }
        .status-badge.good { background:var(--accent-blue-soft);color:var(--accent-blue); }
        .status-badge.warning { background:var(--accent-amber-soft);color:var(--accent-amber); }
        .status-badge.critical { background:var(--accent-red-soft);color:var(--accent-red); }
        .upload-zone { border:2px dashed var(--border-color);border-radius:var(--radius);padding:40px;text-align:center;cursor:pointer;transition:all 0.2s; }
        .upload-zone:hover { border-color:var(--accent-blue);background:var(--accent-blue-soft); }
        .upload-zone input { display:none; }
        .upload-icon { font-size:48px;margin-bottom:16px; }
        .filter-bar { display:flex;gap:12px;margin-bottom:16px;flex-wrap:wrap; }
        .filter-select { padding:8px 12px;border-radius:var(--radius-sm);background:var(--bg-primary);border:1px solid var(--border-color);color:var(--text-primary);font-size:13px;font-family:inherit; }
        .filter-select:focus { outline:none;border-color:var(--accent-blue); }
        .gauge-container { display:flex;justify-content:center;align-items:center;padding:10px; }
        .gauge-needle { transition:transform 0.8s cubic-bezier(0.4,2,0.2,1); transform-origin:50% 50%; }
        .msg-toast { position:fixed;bottom:24px;right:24px;padding:12px 20px;border-radius:var(--radius-sm);font-size:13px;font-weight:500;z-index:1000;animation:slideIn 0.3s ease; }
        .msg-toast.success { background:var(--accent-green);color:white; }
        .msg-toast.error { background:var(--accent-red);color:white; }
        .msg-toast.info { background:var(--accent-blue);color:white; }
        @keyframes slideIn { from{transform:translateX(100%);opacity:0;} to{transform:translateX(0);opacity:1;} }
        .empty-state { text-align:center;padding:60px 20px; }
        .empty-state-icon { font-size:64px;margin-bottom:16px;opacity:0.5; }
        .empty-state-title { font-size:18px;font-weight:600;margin-bottom:8px; }
        .empty-state-text { font-size:14px;color:var(--text-muted);max-width:400px;margin:0 auto; }
        .grid-2 { display:grid;grid-template-columns:repeat(2,1fr);gap:24px; }
        @media(max-width:1024px) { .grid-2{grid-template-columns:1fr;} }
        .summary-row { display:flex;justify-content:space-between;padding:10px 0;border-bottom:1px solid var(--border-color); }
        .summary-row:last-child { border-bottom:none; }
        .summary-label { color:var(--text-secondary);font-size:13px; }
        .summary-value { font-weight:600;font-family:'JetBrains Mono',monospace; }
        
        /* ===== MOBILE RESPONSIVE ===== */
        @media (max-width: 768px) {
            .app { padding: 10px; }
            
            /* Header */
            .header { padding: 12px 0; margin-bottom: 16px; gap: 10px; }
            .header-left { gap: 10px; }
            .logo { width: 36px; height: 36px; font-size: 18px; border-radius: 8px; }
            .header h1 { font-size: 16px; }
            .header p { font-size: 11px; }
            .header > div:last-child { width: 100%; }
            .header > div:last-child .btn { padding: 8px 10px; font-size: 11px; flex: 1; justify-content: center; }
            
            /* Tabs - scroll horizontal */
            .tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; flex-wrap: nowrap; gap: 2px; padding: 3px; margin-bottom: 16px; }
            .tabs::-webkit-scrollbar { display: none; }
            .tab { white-space: nowrap; padding: 8px 12px; font-size: 12px; flex-shrink: 0; }
            
            /* Filter bar */
            .filter-bar { gap: 8px; margin-bottom: 12px; }
            .filter-select { padding: 7px 8px; font-size: 12px; flex: 1; min-width: 0; }
            
            /* KPI Grid */
            .kpi-grid { grid-template-columns: repeat(2, 1fr) !important; gap: 10px; margin-bottom: 16px; }
            .kpi-card { padding: 14px; }
            .kpi-value { font-size: 22px; }
            .kpi-label { font-size: 11px; }
            .kpi-icon { width: 32px; height: 32px; font-size: 16px; }
            .kpi-meta { font-size: 10px; }
            
            /* Sections */
            .section { padding: 14px; margin-bottom: 16px; border-radius: 10px; }
            .section-header { margin-bottom: 12px; flex-wrap: wrap; gap: 8px; }
            .section-title { font-size: 14px; }
            
            /* Grid 2 colunas -> 1 */
            .grid-2 { grid-template-columns: 1fr !important; gap: 16px; }
            
            /* Tabelas */
            .data-table th, .data-table td { padding: 8px 10px; font-size: 11px; }
            .data-table th { font-size: 10px; }
            .status-badge { font-size: 10px; padding: 3px 7px; }
            
            /* Upload zones */
            .upload-zone { padding: 20px 14px; }
            .upload-icon { font-size: 32px; margin-bottom: 10px; }
            .upload-zone div[style*="fontWeight"] { font-size: 13px; }
            
            /* Charts */
            .chart-container { height: 220px; }
            
            /* Gauge */
            .gauge-container { padding: 4px; }
            
            /* Toast */
            .msg-toast { bottom: 12px; right: 12px; left: 12px; text-align: center; font-size: 12px; padding: 10px 14px; }
            
            /* Empty state */
            .empty-state { padding: 30px 14px; }
            .empty-state-icon { font-size: 40px; }
            .empty-state-title { font-size: 15px; }
            .empty-state-text { font-size: 12px; }
            
            /* Fix spans de upload que usam grid-column span 2 */
            .kpi-grid > label[style*="gridColumn"] { grid-column: span 2 !important; }
            
            /* Stats grid 4 -> 2 colunas em mobile */
            .stats-grid-4 { grid-template-columns: repeat(2, 1fr) !important; gap: 10px !important; }
        }
        
        /* Extra small (< 400px) */
        @media (max-width: 400px) {
            .app { padding: 8px; }
            .header h1 { font-size: 14px; }
            .kpi-grid { grid-template-columns: 1fr !important; }
            .kpi-value { font-size: 20px; }
            .tab { padding: 7px 10px; font-size: 11px; }
            .filter-select { font-size: 11px; }
            .chart-container { height: 180px; }
            .stats-grid-4 { grid-template-columns: repeat(2, 1fr) !important; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        const { useState, useEffect, useMemo, useRef } = React;
        const e = React.createElement;
        
        function findValue(row, keys) { for(let k of keys) if(row[k]!==undefined && row[k]!==null && row[k]!=='') return row[k]; return ''; }
        
        // Verificar se um valor é realmente um número de fatura válido
        function isFaturaValida(numFatura) {
            if(!numFatura) return false;
            const str = numFatura.toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
            if(str === '' || str === 'nan' || str === 'null' || str === 'undefined' || str === '0') return false;
            if(str.length < 2) return false;
            // Deve conter dígitos E pelo menos um separador (/, -)  OU começar com FAC/FT/ND/NC/REC (padrões de fatura portuguesa)
            const temDigitos = /\d/.test(str);
            const temSeparador = /[\/\-]/.test(str);
            const comecaComPrefixo = /^(fac|ft|nd|nc|rec|fat|inv)/i.test(str);
            // Se contém "fornecido" ou "ann" ou outros valores do EstadoFinal, NÃO é fatura
            const pareceEstado = /(fornecido|entregue|terminad|embalad|produzid|stock|pendente|ann\s)/i.test(numFatura.toString());
            if(pareceEstado) return false;
            return (temDigitos && temSeparador) || comecaComPrefixo || (temDigitos && str.length >= 4);
        }
        
        // Função para normalizar nomes de operações (remover espaços extras)
        function normalizarOperacao(op) {
            if(!op) return '';
            return op.toString().replace(/\s+/g, ' ').trim();
        }
        
        function parseExcelDate(serial) {
            if(!serial && serial!==0) return '';
            if(typeof serial==='string') { if(serial.includes('/')) return serial; const num=parseFloat(serial); if(!isNaN(num) && num>0) { const d=new Date((num-25569)*86400*1000); return String(d.getDate()).padStart(2,'0')+'/'+String(d.getMonth()+1).padStart(2,'0')+'/'+d.getFullYear(); } return serial; }
            if(typeof serial==='number' && serial>0) { const d=new Date((serial-25569)*86400*1000); return String(d.getDate()).padStart(2,'0')+'/'+String(d.getMonth()+1).padStart(2,'0')+'/'+d.getFullYear(); }
            return '';
        }
        
        function getMesAno(ds) { if(!ds) return ''; const p=ds.split('/'); return p.length===3 ? p[1]+'/'+p[2] : ''; }
        
        function parseExcelTime(tv) {
            if(!tv) return '';
            try {
                if(typeof tv==='string') { tv=tv.trim(); const m=tv.match(/^(\d{1,2}):(\d{2})/); if(m) return String(m[1]).padStart(2,'0')+':'+String(m[2]).padStart(2,'0'); const n=parseFloat(tv); if(!isNaN(n) && n>=0 && n<=1) { const tm=Math.round(n*24*60); return String(Math.floor(tm/60)).padStart(2,'0')+':'+String(tm%60).padStart(2,'0'); } }
                if(typeof tv==='number' && tv>=0 && tv<=1) { const tm=Math.round(tv*24*60); return String(Math.floor(tm/60)).padStart(2,'0')+':'+String(tm%60).padStart(2,'0'); }
            } catch(e){}
            return '';
        }
        
        function calcDuracao(ini, fim) { try { const i=parseExcelTime(ini), f=parseExcelTime(fim); if(!i||!f) return 0; const [hi,mi]=i.split(':').map(Number), [hf,mf]=f.split(':').map(Number); let d=((hf*60)+mf)-((hi*60)+mi); if(d<0) d=(24*60)+d; return d; } catch(e){return 0;} }
        
        function minutosParaHoras(m) { if(!m||m===0) return '0h'; const h=Math.floor(m/60), min=Math.round(m%60); return min===0 ? h+'h' : h+'h '+min+'m'; }
        function formatNumber(n, d=0) { if(n===undefined||n===null||isNaN(n)) return '0'; return n.toLocaleString('pt-PT',{minimumFractionDigits:d,maximumFractionDigits:d}); }
        function formatCurrency(n) { if(n===undefined||n===null||isNaN(n)) return '0 €'; return n.toLocaleString('pt-PT',{minimumFractionDigits:2,maximumFractionDigits:2})+' €'; }
        
        function KPICard({icon, iconColor, label, value, valueColor, progress, progressColor, meta, target}) {
            return e('div',{className:'kpi-card'},
                e('div',{className:'kpi-header'}, e('div',{className:`kpi-icon ${iconColor}`},icon)),
                e('div',{className:`kpi-value ${valueColor||''}`},value),
                e('div',{className:'kpi-label'},label),
                progress!==undefined && e('div',{className:'kpi-progress'}, e('div',{className:`kpi-progress-bar ${progressColor||'blue'}`,style:{width:Math.min(progress,100)+'%'}})),
                (meta||target) && e('div',{className:'kpi-meta'}, meta && e('span',null,meta), target && e('span',null,'Meta: '+target))
            );
        }
        
        function Gauge({value, label}) {
            const percentage = Math.min(Math.max(value, 0), 120);
            const clampedForColor = Math.min(value, 100);
            
            // Arco de 180° (de -90° a +90°, ou seja, de 9h a 3h)
            const cx = 120, cy = 110, r = 80, r2 = 65;
            const startAngle = -210; // graus (7h)
            const endAngle = 30;    // graus (5h)  
            const sweep = endAngle - startAngle; // 240°
            
            // Função para converter ângulo em coordenadas
            const polarToXY = (angle, radius) => {
                const rad = (angle * Math.PI) / 180;
                return { x: cx + radius * Math.cos(rad), y: cy + radius * Math.sin(rad) };
            };
            
            // Arco de fundo (track)
            const trackStart = polarToXY(startAngle, r);
            const trackEnd = polarToXY(endAngle, r);
            const trackPath = `M ${trackStart.x} ${trackStart.y} A ${r} ${r} 0 1 1 ${trackEnd.x} ${trackEnd.y}`;
            
            // Arco de preenchimento (fill)
            const fillAngle = startAngle + (percentage / 120) * sweep;
            const fillEnd = polarToXY(fillAngle, r);
            const largeArc = (fillAngle - startAngle) > 180 ? 1 : 0;
            const fillPath = `M ${trackStart.x} ${trackStart.y} A ${r} ${r} 0 ${largeArc} 1 ${fillEnd.x} ${fillEnd.y}`;
            
            // Cor baseada no valor
            const getColor = (v) => v >= 85 ? '#22c55e' : v >= 60 ? '#f59e0b' : '#ef4444';
            const fillColor = getColor(clampedForColor);
            
            // Agulha
            const needleAngle = startAngle + (percentage / 120) * sweep;
            const needleTip = polarToXY(needleAngle, r - 8);
            const needleBase1 = polarToXY(needleAngle + 90, 4);
            const needleBase2 = polarToXY(needleAngle - 90, 4);
            
            // Marcações
            const ticks = [0, 20, 40, 60, 80, 100, 120];
            
            return e('div',{className:'gauge-container',style:{flexDirection:'column'}},
                e('svg',{width:240,height:155,viewBox:'0 0 240 155',style:{overflow:'visible'}},
                    // Definições
                    e('defs',null,
                        e('linearGradient',{id:`grad_${label.replace(/\s/g,'')}`,x1:'0%',y1:'0%',x2:'100%',y2:'0%'},
                            e('stop',{offset:'0%',stopColor:'#ef4444'}),
                            e('stop',{offset:'40%',stopColor:'#f59e0b'}),
                            e('stop',{offset:'70%',stopColor:'#22c55e'}),
                            e('stop',{offset:'100%',stopColor:'#22c55e'})
                        ),
                        e('filter',{id:'needleShadow'},
                            e('feDropShadow',{dx:0,dy:1,stdDeviation:2,floodColor:'rgba(0,0,0,0.3)'})
                        )
                    ),
                    // Arco de fundo
                    e('path',{d:trackPath,fill:'none',stroke:'#1e293b',strokeWidth:14,strokeLinecap:'round'}),
                    // Arco de progresso com gradiente
                    percentage > 0.5 && e('path',{d:fillPath,fill:'none',stroke:`url(#grad_${label.replace(/\s/g,'')})`,strokeWidth:14,strokeLinecap:'round'}),
                    // Marcações e números
                    ...ticks.map(t => {
                        const tickAngle = startAngle + (t / 120) * sweep;
                        const outerP = polarToXY(tickAngle, r + 10);
                        const innerP = polarToXY(tickAngle, r + 3);
                        const labelP = polarToXY(tickAngle, r + 22);
                        return e('g',{key:t},
                            e('line',{x1:innerP.x,y1:innerP.y,x2:outerP.x,y2:outerP.y,stroke:'#64748b',strokeWidth:t%20===0?2:1}),
                            e('text',{x:labelP.x,y:labelP.y,textAnchor:'middle',dominantBaseline:'middle',fill:'#94a3b8',fontSize:9,fontFamily:'JetBrains Mono, monospace'},t.toString())
                        );
                    }),
                    // Sub-marcações pequenas
                    ...[10,30,50,70,90,110].map(t => {
                        const tickAngle = startAngle + (t / 120) * sweep;
                        const outerP = polarToXY(tickAngle, r + 7);
                        const innerP = polarToXY(tickAngle, r + 3);
                        return e('line',{key:'sub'+t,x1:innerP.x,y1:innerP.y,x2:outerP.x,y2:outerP.y,stroke:'#475569',strokeWidth:1});
                    }),
                    // Agulha
                    e('polygon',{
                        points:`${needleTip.x},${needleTip.y} ${needleBase1.x},${needleBase1.y} ${needleBase2.x},${needleBase2.y}`,
                        fill:fillColor,
                        filter:'url(#needleShadow)',
                        className:'gauge-needle'
                    }),
                    // Centro da agulha
                    e('circle',{cx:cx,cy:cy,r:8,fill:'#1e293b',stroke:'#334155',strokeWidth:2}),
                    e('circle',{cx:cx,cy:cy,r:3,fill:fillColor}),
                    // Valor digital
                    e('text',{x:cx,y:cy+32,textAnchor:'middle',fill:fillColor,fontSize:22,fontWeight:700,fontFamily:'JetBrains Mono, monospace'},value.toFixed(1)+'%'),
                    // Label
                    e('text',{x:cx,y:cy+48,textAnchor:'middle',fill:'#94a3b8',fontSize:11},label)
                )
            );
        }
        
        function App() {
            const [activeTab, setActiveTab] = useState('dashboard');
            const [msg, setMsg] = useState('');
            const [msgType, setMsgType] = useState('info');
            const [encomendas, setEncomendas] = useState([]);
            const [encomendasProducao, setEncomendasProducao] = useState([]); // Pendentes - só para OEE
            const [registosProducao, setRegistosProducao] = useState([]);
            const [registosOperacoes, setRegistosOperacoes] = useState([]);
            const [registosPerturbacoes, setRegistosPerturbacoes] = useState([]);
            const [objetivos, setObjetivos] = useState({});
            const [objetivosTipologia, setObjetivosTipologia] = useState({});
            const [mapCaixaEcode, setMapCaixaEcode] = useState({});
            const [mapaHoras, setMapaHoras] = useState({}); // {mesAno: totalMinutos} ex: {'01/2026': 109938}
            const [filtroMes, setFiltroMes] = useState('');
            const [filtroAno, setFiltroAno] = useState('2026');
            const [filtroTipologia, setFiltroTipologia] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [lastUpdate, setLastUpdate] = useState(null);
            const chartRefs = useRef({});
            
            const showMsg = (text, type='info') => { setMsg(text); setMsgType(type); setTimeout(()=>setMsg(''),4000); };
            
            // URL único do Power Automate que retorna todos os dados
            const [urlPowerAutomate, setUrlPowerAutomate] = useState(() => {
                try { 
                    return localStorage.getItem('kpi_url_powerautomate') || 'https://defaultcade90c14fe343a3860494c20418f8.fb.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d4580994e5004a7f9934f95e968ae3f5/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=fup1O88I7aEoSyDzrILnUSRbaCYbucNvpKktzTubedQ'; 
                } catch(e) { 
                    return 'https://defaultcade90c14fe343a3860494c20418f8.fb.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d4580994e5004a7f9934f95e968ae3f5/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=fup1O88I7aEoSyDzrILnUSRbaCYbucNvpKktzTubedQ'; 
                }
            });
            
            // Guardar URL quando muda
            useEffect(() => {
                if(urlPowerAutomate) {
                    try { localStorage.setItem('kpi_url_powerautomate', urlPowerAutomate); } catch(e) {}
                }
            }, [urlPowerAutomate]);
            
            // Função para carregar dados do Power Automate
            const carregarDadosPowerAutomate = async () => {
                if(!urlPowerAutomate) {
                    showMsg('⚠️ Configure o URL do Power Automate nas definições', 'error');
                    return;
                }
                
                setIsLoading(true);
                showMsg('🔄 A carregar dados...', 'info');
                console.log('📡 A fazer fetch para:', urlPowerAutomate.substring(0, 50) + '...');
                
                try {
                    const response = await fetch(urlPowerAutomate, {
                        method: 'POST',
                        mode: 'cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ acao: 'ler' })
                    });
                    
                    console.log('📡 Resposta recebida, status:', response.status);
                    
                    if(!response.ok) throw new Error('Erro na resposta: ' + response.status);
                    
                    const textRaw = await response.text();
                    console.log('📄 Resposta raw (primeiros 500 chars):', textRaw.substring(0, 500));
                    
                    let data;
                    try {
                        data = JSON.parse(textRaw);
                    } catch(parseErr) {
                        console.error('❌ Erro a fazer parse do JSON:', parseErr);
                        console.log('📄 Resposta completa:', textRaw);
                        throw new Error('JSON inválido recebido do Power Automate');
                    }
                    
                    console.log('📥 Dados recebidos do Power Automate:', data);
                    
                    // Processar Produção
                    if(data.producao && Array.isArray(data.producao)) {
                        const ops = data.producao.map(row => {
                            // Converter data Excel para formato dd/mm/yyyy
                            let dataFormatada = '';
                            const dataRaw = row['Data'] || row['data'];
                            if(dataRaw) {
                                if(typeof dataRaw === 'number' || /^\d+$/.test(dataRaw)) {
                                    const excelDate = parseInt(dataRaw);
                                    const jsDate = new Date((excelDate - 25569) * 86400 * 1000);
                                    dataFormatada = jsDate.toLocaleDateString('pt-PT');
                                } else {
                                    dataFormatada = dataRaw;
                                }
                            }
                            
                            // Extrair mês/ano
                            let mesAno = '';
                            if(dataFormatada) {
                                const parts = dataFormatada.split('/');
                                if(parts.length >= 3) {
                                    mesAno = parts[1] + '/' + parts[2];
                                }
                            }
                            
                            // Calcular duração a partir do campo Duração (formato "Xh Ymin")
                            let duracao = 0;
                            const duracaoStr = row['Duração'] || row['Duracao'] || row['duracao'] || '';
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            
                            return {
                                data: dataFormatada,
                                unidadeProducao: row['Unidade Produção'] || row['UnidadeProducao'] || row['unidadeProducao'],
                                tipologia: row['Tipo Caixa'] || row['TipoCaixa'] || row['tipologia'],
                                artigo: row['Artigo'] || row['artigo'],
                                caixa: row['Artigo'] || row['Programa ANN'] || row['ProgramaANN'] || row['caixa'],
                                operacao: row['Operação'] || row['Operacao'] || row['operacao'],
                                colaborador: row['Colaborador'] || row['colaborador'],
                                horaInicio: row['Hora Início'] || row['HoraInicio'] || row['horaInicio'],
                                horaFim: row['Hora Fim'] || row['HoraFim'] || row['horaFim'],
                                duracao: duracao,
                                mesAno: mesAno
                            };
                        }).filter(r => r.operacao);
                        setRegistosOperacoes(ops);
                        console.log('✅ Operações carregadas:', ops.length, 'Exemplo:', ops[0]);
                    }
                    
                    // Processar Perturbações
                    if(data.perturbacoes && Array.isArray(data.perturbacoes)) {
                        console.log('🔍 Primeira perturbação raw:', data.perturbacoes[0]);
                        const pert = data.perturbacoes.map(row => {
                            // Calcular duração a partir do campo Duração (formato "Xh Ymin")
                            let duracao = 0;
                            const duracaoStr = row['Duração'] || row['Duracao'] || row['duracao'] || '';
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            
                            // Converter data Excel para formato dd/mm/yyyy
                            let dataFormatada = '';
                            const dataRaw = row['Data'] || row['data'];
                            if(dataRaw) {
                                if(typeof dataRaw === 'number' || /^\d+$/.test(dataRaw)) {
                                    const excelDate = parseInt(dataRaw);
                                    const jsDate = new Date((excelDate - 25569) * 86400 * 1000);
                                    dataFormatada = jsDate.toLocaleDateString('pt-PT');
                                } else {
                                    dataFormatada = dataRaw;
                                }
                            }
                            
                            // Extrair mês/ano
                            let mesAno = '';
                            if(dataFormatada) {
                                const parts = dataFormatada.split('/');
                                if(parts.length >= 3) {
                                    mesAno = parts[1] + '/' + parts[2];
                                }
                            }
                            
                            return {
                                data: dataFormatada,
                                unidadeProducao: row['Unidade Produção'] || row['UnidadeProducao'] || row['Unidade'],
                                tipo: row['Tipo Perturbação'] || row['TipoPerturbação'] || row['Tipo'] || row['tipo'],
                                descricao: row['Descrição'] || row['Descricao'] || row['descricao'] || row['Comentários'],
                                colaborador: row['Colaborador'] || row['colaborador'],
                                duracao: duracao,
                                mesAno: mesAno
                            };
                        }).filter(r => r.tipo);
                        setRegistosPerturbacoes(pert);
                        console.log('✅ Perturbações carregadas:', pert.length, 'Exemplo:', pert[0]);
                    }
                    
                    // Processar Encomendas
                    if(data.encomendas && Array.isArray(data.encomendas)) {
                        console.log('🔍 Primeira encomenda raw:', data.encomendas[0]);
                        console.log('🔍 TODAS as colunas da 1ª encomenda:', JSON.stringify(Object.keys(data.encomendas[0])));
                        
                        const enc = data.encomendas.map(row => {
                            const mesEntrega = row['MesEntrega'] || row['Mês Entrega'] || row['Mes Entrega'];
                            const anoEntrega = row['AnoEntrega'] || row['Ano Entrega'];
                            const mesProducao = row['MesProducao'] || row['Mês Produção'] || row['Mes Producao'] || row['Mes Produção'];
                            const anoProducao = row['AnoProducao'] || row['Ano Produção'] || row['Ano Producao'];
                            const mesEmbalamento = row['MesEmbalamento'] || row['Mês Embalamento'] || row['Mes Embalamento'];
                            const anoEmbalamento = row['AnoEmbalamento'] || row['Ano Embalamento'];
                            
                            const buildMesAno = (mes, ano) => {
                                if(!mes || !ano) return '';
                                const mesesNome = {'janeiro':'01','fevereiro':'02','março':'03','marco':'03','abril':'04','maio':'05','junho':'06','julho':'07','agosto':'08','setembro':'09','outubro':'10','novembro':'11','dezembro':'12'};
                                let mesStr = mes.toString().toLowerCase().trim();
                                let mesNum = mesesNome[mesStr] || (parseInt(mesStr) > 0 ? parseInt(mesStr).toString().padStart(2,'0') : '');
                                return mesNum ? mesNum + '/' + ano : '';
                            };
                            
                            // Extrair mês/ano de uma data raw (número Excel ou string dd/mm/yyyy)
                            const mesAnoFromData = (dataRaw) => {
                                if(!dataRaw) return '';
                                const str = dataRaw.toString().trim();
                                if(!str || str === 'NaN' || str === 'nan') return '';
                                // Número Excel (ex: 46027)
                                if(/^\d{4,5}$/.test(str)) {
                                    const jsDate = new Date((parseInt(str) - 25569) * 86400 * 1000);
                                    if(!isNaN(jsDate.getTime())) {
                                        return (jsDate.getMonth()+1).toString().padStart(2,'0') + '/' + jsDate.getFullYear();
                                    }
                                }
                                // String dd/mm/yyyy ou mm/dd/yyyy
                                const parts = str.split(/[\/\-\.]/);
                                if(parts.length >= 3) {
                                    const d = parseInt(parts[0]), m = parseInt(parts[1]), y = parseInt(parts[2]);
                                    if(y > 2000) return m.toString().padStart(2,'0') + '/' + y;
                                }
                                return '';
                            };
                            
                            let mesAnoEntrega = buildMesAno(mesEntrega, anoEntrega);
                            // Fallback: usar DataEntregaReal se MesEntrega/AnoEntrega estão vazios
                            if(!mesAnoEntrega) {
                                mesAnoEntrega = mesAnoFromData(row['DataEntregaReal'] || row['Data Entrega Real'] || row['dataEntregaReal']);
                            }
                            
                            let mesAnoProducao = buildMesAno(mesProducao, anoProducao);
                            if(!mesAnoProducao) {
                                mesAnoProducao = mesAnoFromData(row['DataProducao'] || row['Data Produção'] || row['dataProducao']);
                            }
                            
                            let mesAnoEmbalamento = buildMesAno(mesEmbalamento, anoEmbalamento);
                            if(!mesAnoEmbalamento) {
                                mesAnoEmbalamento = mesAnoFromData(row['DataEmbalamento'] || row['Data Embalamento'] || row['dataEmbalamento']);
                            }
                            
                            // Fatura - procurar em todas as variantes possíveis de nome de coluna
                            const numFaturaRaw = row['NºFatura'] || row['Nº Fatura'] || row['numFatura'] || row['NumFatura'] || row['N_x00ba_Fatura'] || row['Fatura'] || row['N.º Fatura'] || row['Nº_Fatura'];
                            const numFaturaStr = (numFaturaRaw || '').toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
                            const faturada = isFaturaValida(numFaturaRaw);
                            
                            return {
                                tipologia: row['Tipologia'] || row['tipologia'],
                                caixa: row['Caixa'] || row['caixa'],
                                ligacao: row['Ligação'] || row['Ligacao'] || row['ligacao'],
                                po: row['PO'] || row['po'],
                                pos: row['POS'] || row['pos'] || row['Pos'] || '',
                                ecode: row['Ecode'] || row['ecode'],
                                valor: parseFloat(row['Valor'] || row['valor']) || 0,
                                quantidade: parseInt(row['Quantidade'] || row['quantidade']) || 1,
                                qtdEntregue: parseInt(row['QuantidadeEntregue'] || row['Quantidade Entregue'] || row['qtdEntregue']) || 0,
                                faturada,
                                numFatura: numFaturaRaw,
                                localizacao: row['Localização'] || row['Localizacao'] || row['localizacao'] || row['Local'] || '',
                                mesAnoEntrega,
                                mesAnoProducao,
                                mesAnoEmbalamento,
                                anoEntrega: anoEntrega ? parseInt(anoEntrega) : (mesAnoEntrega ? parseInt(mesAnoEntrega.split('/')[1]) : null),
                                mesEntrega: mesEntrega ? parseInt(mesEntrega) : (mesAnoEntrega ? parseInt(mesAnoEntrega.split('/')[0]) : null),
                                anoProducao: anoProducao ? parseInt(anoProducao) : (mesAnoProducao ? parseInt(mesAnoProducao.split('/')[1]) : null)
                            };
                        }).filter(r => r.tipologia || r.caixa);
                        enc.forEach(e => e._origem = 'terminada');
                        
                        // Debug completo
                        const com2026 = enc.filter(e => e.anoEntrega === 2026);
                        const localizacoes = [...new Set(enc.map(e => e.localizacao).filter(l => l))];
                        const comFatura = enc.filter(e => e.faturada);
                        const comMesEntrega = enc.filter(e => e.mesAnoEntrega);
                        const comMesProd = enc.filter(e => e.mesAnoProducao);
                        const comMesEmb = enc.filter(e => e.mesAnoEmbalamento);
                        console.log('✅ Encomendas carregadas:', enc.length, '| Com 2026:', com2026.length, '| Com fatura:', comFatura.length, '| Sem fatura:', enc.filter(e=>!e.faturada).length, '| Valor faturado:', comFatura.reduce((s,e)=>s+(e.valor||0),0).toFixed(2));
                        // Debug: valores de fatura
                        const valoresNumFatura = [...new Set(enc.map(e => (e.numFatura||'').toString().trim()))];
                        console.log('📋 Valores ÚNICOS de NumFatura (' + valoresNumFatura.length + '):', valoresNumFatura.slice(0,30));
                        // Debug: mostrar quais foram aceites e quais rejeitados
                        const rejeitados = enc.filter(e => !e.faturada && e.numFatura);
                        if(rejeitados.length > 0) console.log('⚠️ NumFatura REJEITADOS (não parecem faturas reais):', [...new Set(rejeitados.map(e => (e.numFatura||'').toString().trim()))].slice(0,20));
                        if(comFatura.length > 0) console.log('✅ NumFatura ACEITES:', [...new Set(comFatura.map(e => (e.numFatura||'').toString().trim()))].slice(0,20));
                        console.log('📅 Datas: mesEntrega:', comMesEntrega.length, '| mesProducao:', comMesProd.length, '| mesEmbalamento:', comMesEmb.length);
                        console.log('🔍 Localizações encontradas:', localizacoes);
                        // Debug: mostrar distribuição por mês de entrega
                        const distMesEntrega = {};
                        enc.forEach(e => { const m = e.mesAnoEntrega || 'SEM'; distMesEntrega[m] = (distMesEntrega[m]||0)+1; });
                        console.log('📅 Distribuição por mês ENTREGA:', distMesEntrega);
                        // Debug: ver colunas raw relacionadas com data de entrega
                        if(data.encomendas[0]) {
                            const rawKeys = Object.keys(data.encomendas[0]);
                            const dataKeys = rawKeys.filter(k => k.toLowerCase().includes('entrega') || k.toLowerCase().includes('data') || k.toLowerCase().includes('mes') || k.toLowerCase().includes('ano') || k.toLowerCase().includes('semana'));
                            console.log('🔍 Colunas RAW com data/entrega/mes/ano:', dataKeys);
                            dataKeys.forEach(k => console.log('   →', k, '=', JSON.stringify(data.encomendas[0][k])));
                        }
                        if(enc.length > 0) {
                            console.log('🔍 1ª enc:', { numFatura: enc[0].numFatura, faturada: enc[0].faturada, valor: enc[0].valor, mesAnoEntrega: enc[0].mesAnoEntrega, mesAnoProducao: enc[0].mesAnoProducao, mesAnoEmbalamento: enc[0].mesAnoEmbalamento });
                            // Mostrar as 3 últimas para ver se têm datas diferentes
                            const last = enc[enc.length-1];
                            console.log('🔍 Última enc:', { caixa: last.caixa, mesAnoEntrega: last.mesAnoEntrega, mesAnoProducao: last.mesAnoProducao, mesAnoEmbalamento: last.mesAnoEmbalamento });
                        }
                        
                        setEncomendas(enc);
                    }
                    
                    // Processar Encomendas em Produção (pendentes)
                    if(data.encomendasProducao && Array.isArray(data.encomendasProducao)) {
                        console.log('🔍 Primeira encomenda produção raw:', data.encomendasProducao[0]);
                        
                        const encProd = data.encomendasProducao.map(row => {
                            // Nomes com espaços (tabela Encomendas) ou sem (tabela EncomendasTerminadas)
                            const mesProducao = row['Mês Produção'] || row['MesProdução'] || row['MesProducao'] || row['Mes Producao'];
                            const anoProducao = row['Ano Produção'] || row['AnoProdução'] || row['AnoProducao'] || row['Ano Producao'];
                            const mesEntrega = row['Mês Entrega'] || row['MesEntrega'] || row['Mes Entrega'];
                            const anoEntrega = row['Ano Entrega'] || row['AnoEntrega'] || row['Ano Entrega'];
                            
                            // Construir mesAnoProducao
                            let mesAnoProducao = '';
                            if(mesProducao && anoProducao && mesProducao !== 'NaN' && anoProducao !== 'NaN') {
                                // Mês pode vir como "Janeiro", "Fevereiro" ou número
                                const mesesNome = {'janeiro':1,'fevereiro':2,'março':3,'abril':4,'maio':5,'junho':6,'julho':7,'agosto':8,'setembro':9,'outubro':10,'novembro':11,'dezembro':12};
                                let mesNum = parseInt(mesProducao);
                                if(isNaN(mesNum) && typeof mesProducao === 'string') {
                                    mesNum = mesesNome[mesProducao.toLowerCase()] || 0;
                                }
                                if(mesNum > 0) {
                                    mesAnoProducao = mesNum.toString().padStart(2,'0') + '/' + anoProducao;
                                }
                            }
                            
                            // Construir mesAnoEntrega
                            let mesAnoEntrega = '';
                            if(mesEntrega && anoEntrega) {
                                const mesesNome = {'janeiro':1,'fevereiro':2,'março':3,'abril':4,'maio':5,'junho':6,'julho':7,'agosto':8,'setembro':9,'outubro':10,'novembro':11,'dezembro':12};
                                let mesNum = parseInt(mesEntrega);
                                if(isNaN(mesNum) && typeof mesEntrega === 'string') {
                                    mesNum = mesesNome[mesEntrega.toLowerCase()] || 0;
                                }
                                if(mesNum > 0) {
                                    mesAnoEntrega = mesNum.toString().padStart(2,'0') + '/' + anoEntrega;
                                }
                            }
                            
                            return {
                                tipologia: row['Tipologia'] || row['tipologia'],
                                caixa: row['Caixa'] || row['caixa'],
                                ligacao: row['Ligação'] || row['Ligacao'] || row['ligacao'],
                                po: row['PO'] || row['po'],
                                pos: row['POS'] || row['pos'] || row['Pos'] || '',
                                ecode: row['Ecode'] || row['ecode'],
                                quantidade: parseInt(row['Quantidade Produzida'] || row['QuantidadeProduzida'] || row['Quantidade'] || row['quantidade']) || 1,
                                qtdProduzida: parseInt(row['Quantidade Produzida'] || row['QuantidadeProduzida']) || 0,
                                qtdEntregue: parseInt(row['Quantidade Entregue'] || row['QuantidadeEntregue']) || 0,
                                estado: row['Estado'] || row['estado'],
                                subEstado: row['SubEstado'] || row['subEstado'],
                                localizacao: row['Localização'] || row['Localizacao'] || row['localizacao'] || row['Local'] || '',
                                valor: parseFloat(row['Valor'] || row['valor']) || 0,
                                numFatura: row['NumFatura'] || row['NºFatura'] || row['Nº Fatura'] || row['numFatura'] || row['N_x00ba_Fatura'] || row['Fatura'],
                                faturada: isFaturaValida(row['NumFatura'] || row['NºFatura'] || row['Nº Fatura'] || row['numFatura'] || row['N_x00ba_Fatura'] || row['Fatura']),
                                mesAnoProducao,
                                mesAnoEntrega,
                                mesAnoEmbalamento: mesAnoProducao, // usar produção como fallback
                                anoProducao: anoProducao ? parseInt(anoProducao) : null,
                                mesProducao: mesProducao,
                                anoEntrega: anoEntrega ? parseInt(anoEntrega) : null,
                                emProducao: true // marcador para distinguir das terminadas
                            };
                        }).filter(r => r.tipologia || r.caixa);
                        // Marcar origem: faturadas vs stock
                        encProd.forEach(e => e._origem = e.faturada ? 'faturada' : 'stock');
                        
                        // Separar pendentes faturadas (não estão terminadas mas têm fatura)
                        const pendFaturadas = encProd.filter(e => e.faturada);
                        
                        // Separar pendentes em stock (não faturadas mas produzidas/entregues)
                        const pendStock = encProd.filter(e => {
                            if(e.faturada) return false;
                            const estado = (e.estado || '').toLowerCase().trim();
                            const subEstado = (e.subEstado || '').toLowerCase().trim();
                            return subEstado === 'terminada' || 
                                   estado === 'entregue' || 
                                   estado === 'em stock' ||
                                   estado === 'produzida';
                        });
                        
                        console.log('✅ Encomendas em produção carregadas:', encProd.length, '| Faturadas:', pendFaturadas.length, '| Em stock:', pendStock.length, '| Valor fat pendentes:', pendFaturadas.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                        if(encProd.length > 0) {
                            console.log('🔍 Primeira enc produção processada:', { 
                                caixa: encProd[0].caixa, 
                                mesAnoProducao: encProd[0].mesAnoProducao,
                                mesAnoEntrega: encProd[0].mesAnoEntrega,
                                anoProducao: encProd[0].anoProducao,
                                quantidade: encProd[0].quantidade,
                                faturada: encProd[0].faturada,
                                numFatura: encProd[0].numFatura
                            });
                        }
                        
                        // Adicionar pendentes faturadas E em stock ao array principal de encomendas
                        setEncomendas(prev => {
                            // Evitar duplicados: PO+POS é a chave única de uma encomenda
                            const idsTerminadas = new Set(prev.map(e => String(e.po||'').trim()+'|'+String(e.pos||'').trim()));
                            const novasFaturadas = pendFaturadas.filter(e => {
                                const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                return !idsTerminadas.has(id);
                            });
                            const novosStock = pendStock.filter(e => {
                                const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                return !idsTerminadas.has(id);
                            });
                            console.log('📋 Adicionando', novasFaturadas.length, 'pendentes faturadas +', novosStock.length, 'em stock ao array principal');
                            if(pendFaturadas.length > novasFaturadas.length) {
                                const dupl = pendFaturadas.filter(e => {
                                    const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                                    return idsTerminadas.has(id);
                                });
                                console.log('⚠️ Duplicadas faturadas (mesmo PO+POS já nas terminadas):', dupl.map(e => ({caixa:e.caixa, po:e.po, pos:e.pos, numFatura:e.numFatura})));
                            }
                            return [...prev, ...novasFaturadas, ...novosStock];
                        });
                        
                        // Guardar separadamente - só para cálculo de OEE
                        setEncomendasProducao(encProd);
                    }
                    
                    // Processar Objetivos por Operação
                    if(data.objetivosOperacao && Array.isArray(data.objetivosOperacao)) {
                        console.log('🔍 Primeiro objetivo operação raw:', data.objetivosOperacao[0]);
                        const objs = {};
                        data.objetivosOperacao.forEach(row => {
                            const operacao = row['Operação'] || row['Operacao'] || row['operacao'];
                            const tempo = row['Tempo Objetivo'] || row['TempoObjetivo'] || row['tempoObjetivo'] || row['Tempo'];
                            if(operacao && tempo) {
                                // Tempo vem em fração de dia (Excel time format)
                                // Ex: 0.5 = 12 horas = 720 minutos
                                // Ex: 0.041666... = 1 hora = 60 minutos
                                let mins = 0;
                                const tempoNum = parseFloat(tempo);
                                if(!isNaN(tempoNum)) {
                                    mins = Math.round(tempoNum * 24 * 60); // dias para minutos
                                }
                                if(mins > 0) objs[operacao] = mins;
                            }
                        });
                        setObjetivos(prev => ({...prev, ...objs}));
                        console.log('✅ Objetivos operação carregados:', Object.keys(objs).length, 'Exemplo:', Object.entries(objs).slice(0,3));
                    }
                    
                    // Processar Objetivos por Tipologia
                    if(data.objetivosTipologia && Array.isArray(data.objetivosTipologia)) {
                        console.log('🔍 Primeiro objetivo tipologia raw:', data.objetivosTipologia[0]);
                        const objsTip = {};
                        data.objetivosTipologia.forEach(row => {
                            const tipologia = row['Tipologia'] || row['tipologia'];
                            const tempo = row['Tempo Objetivo'] || row['TempoObjetivo'] || row['tempoObjetivo'] || row['Tempo'];
                            if(tipologia && tempo) {
                                // Tempo vem em fração de dia (Excel time format)
                                // Ex: 1.215... = ~29 horas = ~1750 minutos
                                let mins = 0;
                                const tempoNum = parseFloat(tempo);
                                if(!isNaN(tempoNum)) {
                                    mins = Math.round(tempoNum * 24 * 60); // dias para minutos
                                }
                                if(mins > 0) objsTip[tipologia] = mins;
                            }
                        });
                        setObjetivosTipologia(prev => ({...prev, ...objsTip}));
                        console.log('✅ Objetivos tipologia carregados:', Object.keys(objsTip).length, 'Exemplo:', Object.entries(objsTip).slice(0,3));
                    }
                    
                    // Processar Mapa de Horas (Tempo Disponível)
                    if(data.mapaHoras && Array.isArray(data.mapaHoras)) {
                        console.log('🔍 Primeiro mapa horas raw:', data.mapaHoras[0]);
                        const mapa = {};
                        data.mapaHoras.forEach(row => {
                            const mesRaw = row['Mes'] || row['mes'] || row['Mês'] || '';
                            const total = parseFloat(row['Total'] || row['total'] || row['TotalHoras'] || 0);
                            if(mesRaw && total > 0) {
                                // Converter formato "2026-01" para "01/2026"
                                let mesAno = mesRaw;
                                if(mesRaw.includes('-')) {
                                    const parts = mesRaw.split('-');
                                    mesAno = parts[1] + '/' + parts[0]; // "01/2026"
                                }
                                if(!mapa[mesAno]) mapa[mesAno] = 0;
                                mapa[mesAno] += Math.round(total * 60); // horas para minutos
                            }
                        });
                        setMapaHoras(prev => ({...prev, ...mapa}));
                        console.log('✅ Mapa Horas carregado:', mapa);
                    }
                    
                    setLastUpdate(new Date());
                    showMsg('✅ Dados carregados com sucesso!', 'success');
                    
                } catch(err) {
                    console.error('❌ Erro ao carregar dados:', err);
                    showMsg('❌ Erro ao carregar: ' + err.message, 'error');
                } finally {
                    setIsLoading(false);
                }
            };
            
            // Estado para configuração
            const [showConfig, setShowConfig] = useState(false);
            
            // Guardar URL
            useEffect(() => {
                try {
                    if(urlPowerAutomate) localStorage.setItem('kpi_url_powerautomate', urlPowerAutomate);
                } catch(e) {}
            }, [urlPowerAutomate]);
            
            // Carregar dados automaticamente ao iniciar (se URL configurado)
            useEffect(() => {
                console.log('🚀 App iniciada, URL:', urlPowerAutomate ? 'configurado' : 'vazio');
                if(urlPowerAutomate) {
                    console.log('🔄 A iniciar carregamento automático...');
                    carregarDadosPowerAutomate();
                }
            }, []);
            
            // Importar Registos Produção Évora (ficheiro com 2 folhas: Produção + Perturbações)
            const importRegistosProducao = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar registos de produção...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Processar folha Produção (Operações)
                    const sheetProd = wb.Sheets['Produção'] || wb.Sheets['Producao'] || wb.Sheets[wb.SheetNames[0]];
                    const dataProd = XLSX.utils.sheet_to_json(sheetProd, {defval:''});
                    
                    const operacoes = dataProd.map(row => {
                        const operacao = findValue(row, ['Operação','operacao','OPERAÇÃO','Op']);
                        const tipologia = findValue(row, ['Tipo Caixa','TipoCaixa','Tipologia','tipologia']);
                        const artigo = findValue(row, ['Artigo','artigo']);
                        const colaborador = findValue(row, ['Colaborador','colaborador']);
                        const unidadeProducao = findValue(row, ['Unidade Produção','UnidadeProducao','unidadeProducao','Unidade']);
                        const dtRaw = findValue(row, ['Data','data']);
                        const dt = typeof dtRaw === 'string' && dtRaw.includes('-') 
                            ? dtRaw.split('-').reverse().join('/').substring(0,10).split('/').map((p,i)=>i<2?p.padStart(2,'0'):p).join('/')
                            : parseExcelDate(dtRaw);
                        const inicio = findValue(row, ['Hora Início','horaInicio','Início']);
                        const fim = findValue(row, ['Hora Fim','horaFim','Fim']);
                        const duracaoStr = findValue(row, ['Duração','duracao']);
                        let duracao = 0;
                        if(duracaoStr) {
                            const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                            if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                        }
                        if(duracao===0) duracao = calcDuracao(inicio, fim);
                        const quantidade = parseFloat(findValue(row, ['Quantidade','quantidade','Qtd']))||0;
                        return { operacao, tipologia, artigo, colaborador, unidadeProducao, data:dt, inicio, fim, duracao, quantidade, mesAno:getMesAno(dt) };
                    }).filter(r => r.operacao && r.data);
                    
                    // Processar folha Perturbações
                    const sheetPert = wb.Sheets['Perturbações'] || wb.Sheets['Perturbacoes'];
                    let perturbacoes = [];
                    if(sheetPert) {
                        const dataPert = XLSX.utils.sheet_to_json(sheetPert, {defval:''});
                        perturbacoes = dataPert.map(row => {
                            const tipo = findValue(row, ['Tipo Perturbação','TipoPerturbacao','Tipo','tipo','Perturbação']);
                            const colaborador = findValue(row, ['Colaborador','colaborador']);
                            const dtRaw = findValue(row, ['Data','data']);
                            const dt = typeof dtRaw === 'string' && dtRaw.includes('-') 
                                ? dtRaw.split('-').reverse().join('/').substring(0,10).split('/').map((p,i)=>i<2?p.padStart(2,'0'):p).join('/')
                                : parseExcelDate(dtRaw);
                            const inicio = findValue(row, ['Hora Início','horaInicio','Início']);
                            const fim = findValue(row, ['Hora Fim','horaFim','Fim']);
                            const duracaoStr = findValue(row, ['Duração','duracao']);
                            let duracao = 0;
                            if(duracaoStr) {
                                const match = duracaoStr.toString().match(/(\d+)h\s*(\d+)?/i);
                                if(match) duracao = parseInt(match[1]||0)*60 + parseInt(match[2]||0);
                            }
                            if(duracao===0) duracao = calcDuracao(inicio, fim);
                            return { tipo, colaborador, data:dt, inicio, fim, duracao, mesAno:getMesAno(dt) };
                        }).filter(r => r.tipo && r.data);
                    }
                    
                    // Também extrair produção agregada por tipologia
                    const producaoAgg = {};
                    operacoes.forEach(r => {
                        const key = r.data + '|' + r.tipologia;
                        if(!producaoAgg[key]) producaoAgg[key] = { data:r.data, tipologia:r.tipologia, quantidade:0, tempoOperacoes:0, mesAno:r.mesAno };
                        producaoAgg[key].quantidade += r.quantidade || 0;
                        producaoAgg[key].tempoOperacoes += r.duracao;
                    });
                    const producao = Object.values(producaoAgg);
                    
                    setRegistosOperacoes(operacoes);
                    setRegistosPerturbacoes(perturbacoes);
                    setRegistosProducao(producao);
                    
                    showMsg(`✅ Importado: ${operacoes.length} operações + ${perturbacoes.length} perturbações!`,'success');
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            const importEncomendas = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar encomendas...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Função para processar uma folha de encomendas
                    const processarFolha = (sheetName) => {
                        if(!wb.SheetNames.includes(sheetName)) return [];
                        const data = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {defval:'', raw:false});
                        console.log('📥 A processar folha:', sheetName, '- Linhas:', data.length);
                        
                        return data.map(row => {
                            const tipologia = findValue(row, ['Tipologia','tipologia','TIPOLOGIA','Tipo']);
                            const caixa = findValue(row, ['Caixa','caixa','CAIXA','TipoCaixa']);
                            const ligacao = findValue(row, ['Ligacao','Ligação','ligacao','TipoCaixa']);
                            const po = findValue(row, ['PO','po','Encomenda']);
                            const pos = findValue(row, ['POS','pos','Pos','Position']);
                            const ecode = findValue(row, ['Ecode','ecode','ECODE','ECode','Código']);
                            
                            // Datas - converter formato ISO ou serial Excel
                            const parseData = (val) => {
                                if(!val) return '';
                                const v = val.toString().trim();
                                if(v.includes('T') || v.match(/^\d{4}-\d{2}-\d{2}/)) {
                                    const parts = v.split('T')[0].split('-');
                                    if(parts.length === 3) return parts[2] + '/' + parts[1] + '/' + parts[0];
                                }
                                if(v.includes('/')) return v;
                                return parseExcelDate(val);
                            };
                            
                            const dataEncomenda = parseData(findValue(row, ['DataEncomenda','Data Encomenda','dataEncomenda']));
                            const dataEntregaPrevista = parseData(findValue(row, ['DataEntregaPrevista','Data Entrega Prevista','dataEntregaPrevista']));
                            const dataProducao = parseData(findValue(row, ['DataProducao','Data Produção','dataProducao']));
                            const dataEntregaReal = parseData(findValue(row, ['DataEntregaReal','Data Entrega Real','dataEntregaReal']));
                            const dataEmbalamento = parseData(findValue(row, ['DataEmbalamento','Data Embalamento','dataEmbalamento']));
                            
                            // Quantidades
                            const quantidade = parseFloat(findValue(row, ['QuantidadeProduzida','Quantidade Produzida','Quantidade','quantidade']))||1;
                            const qtdEntregue = parseFloat(findValue(row, ['QuantidadeEntregue','Quantidade Entregue','qtdEntregue']))||0;
                            const qtdEmbalada = parseFloat(findValue(row, ['QuantidadeEmbalada','Quantidade Embalada','qtdEmbalada']))||0;
                            
                            // Valor e Fatura
                            const valorRaw = findValue(row, [' Valor ', 'Valor', ' Valor', 'Valor ', 'valor', 'VALOR', 'Preço']);
                            let valor = 0;
                            if(valorRaw !== undefined && valorRaw !== null && valorRaw !== '') {
                                const valorStr = String(valorRaw).replace(/€/g, '').replace(/\s/g, '').replace(/,/g, '');
                                valor = parseFloat(valorStr) || 0;
                            }
                            const numFatura = findValue(row, ['NumFatura','NºFatura','Nº Fatura','numFatura','N_x00ba_Fatura','Fatura']);
                            const estadoFinal = findValue(row, ['EstadoFinal','Estado Final','estadoFinal']);
                            const estado = findValue(row, ['Estado','estado']);
                            const subEstado = findValue(row, ['SubEstado','Sub Estado','subEstado']);
                            
                            const numFaturaStr = (numFatura || '').toString().toLowerCase().replace(/[\s\u00A0\u200B\u200C\u200D\uFEFF]/g,'').trim();
                            const faturada = isFaturaValida(numFatura);
                            
                            // Mês/Ano para agrupamento
                            const mesProducao = findValue(row, ['MesProducao','Mês Produção','mesProducao']);
                            const anoProducao = findValue(row, ['AnoProducao','Ano Produção','anoProducao']);
                            const mesEntrega = findValue(row, ['MesEntrega','Mês Entrega','mesEntrega']);
                            const anoEntrega = findValue(row, ['AnoEntrega','Ano Entrega','anoEntrega']);
                            const mesEmbalamento = findValue(row, ['MesEmbalamento','Mês Embalamento','mesEmbalamento']);
                            const anoEmbalamento = findValue(row, ['AnoEmbalamento','Ano Embalamento','anoEmbalamento']);
                            
                            const getMesAnoFromParts = (mes, ano) => {
                                if(!mes || !ano || mes === 'sem data') return '';
                                const mesesMap = {'janeiro':'01','fevereiro':'02','março':'03','marco':'03','abril':'04','maio':'05','junho':'06','julho':'07','agosto':'08','setembro':'09','outubro':'10','novembro':'11','dezembro':'12'};
                                const mesNum = mesesMap[mes.toString().toLowerCase()] || mes.toString().padStart(2,'0');
                                return mesNum + '/' + ano;
                            };
                            
                            return { 
                                tipologia, caixa, ligacao, po, pos, ecode, estado, subEstado,
                                dataEncomenda, dataEntregaPrevista, dataProducao, dataEntregaReal, dataEmbalamento,
                                quantidade, qtdEntregue, qtdEmbalada,
                                valor, numFatura, estadoFinal, faturada,
                                mesAnoProducao: getMesAnoFromParts(mesProducao, anoProducao) || getMesAno(dataProducao),
                                mesAnoEntrega: getMesAnoFromParts(mesEntrega, anoEntrega) || getMesAno(dataEntregaReal),
                                mesAnoEmbalamento: getMesAnoFromParts(mesEmbalamento, anoEmbalamento) || getMesAno(dataEmbalamento)
                            };
                        }).filter(r => r.tipologia || r.caixa);
                    };
                    
                    // Processar folha EncomendasTerminadas
                    const terminadas = processarFolha('EncomendasTerminadas');
                    terminadas.forEach(e => e._origem = 'terminada');
                    // Debug: ver colunas raw da folha EncomendasTerminadas
                    if(data.EncomendasTerminadas && data.EncomendasTerminadas[0]) {
                        const rawKeys = Object.keys(data.EncomendasTerminadas[0]);
                        const fatKeys = rawKeys.filter(k => k.toLowerCase().includes('fat') || k.toLowerCase().includes('fatura') || k.toLowerCase().includes('invoice'));
                        console.log('🔍 EncomendasTerminadas - Colunas fatura:', fatKeys);
                        fatKeys.forEach(k => {
                            const vals = data.EncomendasTerminadas.slice(0,5).map(r => JSON.stringify(r[k]));
                            console.log('   →', k, ':', vals.join(', '));
                        });
                        // Mostrar TODOS os valores únicos da coluna NumFatura
                        const numFatKey = fatKeys.find(k => k.includes('NumFat') || k === 'NumFatura') || fatKeys[0];
                        if(numFatKey) {
                            const valsUnicos = [...new Set(data.EncomendasTerminadas.map(r => JSON.stringify(r[numFatKey])))];
                            console.log('📋 Valores únicos de', numFatKey, '(' + valsUnicos.length + '):', valsUnicos.slice(0,30));
                        }
                    }
                    const termComFatura = terminadas.filter(e => e.faturada);
                    const termSemFatura = terminadas.filter(e => !e.faturada);
                    console.log('📋 Terminadas:', terminadas.length, '| Com fatura:', termComFatura.length, '| Sem fatura:', termSemFatura.length, '| Valor faturado terminadas:', termComFatura.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                    if(termComFatura.length > 0) console.log('🔍 Exemplos faturadas:', termComFatura.slice(0,3).map(e => ({caixa:e.caixa, numFatura:e.numFatura, numFaturaType:typeof e.numFatura, numFaturaLen: (e.numFatura||'').toString().length, valor:e.valor})));
                    if(termSemFatura.length > 0) console.log('🔍 Exemplos NÃO faturadas:', termSemFatura.slice(0,3).map(e => ({caixa:e.caixa, numFatura:e.numFatura, numFaturaRaw:JSON.stringify(e.numFatura), valor:e.valor})));
                    const faturasUnicas = [...new Set(terminadas.map(e => (e.numFatura||'').toString().trim()))].filter(f => f);
                    console.log('📋 Faturas únicas EncomendasTerminadas (' + faturasUnicas.length + '):', faturasUnicas.slice(0,20));
                    
                    // Processar folha Encomendas (pendentes) - apenas as produzidas/em stock
                    let pendentes = processarFolha('Encomendas');
                    
                    // Separar faturadas de não-faturadas primeiro
                    const pendentesFaturadas = pendentes.filter(e => e.faturada);
                    pendentesFaturadas.forEach(e => e._origem = 'faturada');
                    
                    // Não-faturadas: filtrar apenas as que estão produzidas (SubEstado = terminada, ou Estado = entregue/em stock)
                    const pendentesProducidas = pendentes.filter(e => {
                        if(e.faturada) return false; // faturadas já foram tratadas acima
                        const subEstado = (e.subEstado || '').toString().toLowerCase().trim();
                        const estado = (e.estado || '').toString().toLowerCase().trim();
                        const estadoFinal = (e.estadoFinal || '').toString().toLowerCase().trim();
                        return subEstado === 'terminada' || 
                               estado === 'entregue' || 
                               estado === 'em stock' ||
                               estado === 'produzida' ||
                               estadoFinal.includes('embalada') ||
                               estadoFinal.includes('fornecido') ||
                               estadoFinal.includes('terminada');
                    });
                    pendentesProducidas.forEach(e => e._origem = 'stock');
                    
                    // Evitar duplicados: PO+POS é a chave única de uma encomenda
                    const idsTerminadas = new Set(terminadas.map(e => String(e.po||'').trim()+'|'+String(e.pos||'').trim()));
                    const novasFaturadas = pendentesFaturadas.filter(e => {
                        const id = String(e.po||'').trim()+'|'+String(e.pos||'').trim();
                        return !idsTerminadas.has(id);
                    });
                    
                    console.log('📦 Pendentes total:', pendentes.length, '| Produzidas/Stock (não fat):', pendentesProducidas.length, '| Faturadas pendentes:', pendentesFaturadas.length, '| Novas faturadas (sem duplicados por PO+POS):', novasFaturadas.length);
                    console.log('📋 Valor faturado pendentes:', pendentesFaturadas.reduce((s,e) => s + (e.valor||0), 0).toFixed(2));
                    if(pendentesFaturadas.length > novasFaturadas.length) {
                        const duplicadas = pendentesFaturadas.filter(e => {
                            const id = (e.po||'')+'|'+(e.pos||'');
                            return idsTerminadas.has(id);
                        });
                        console.log('⚠️ Faturadas duplicadas (mesmo PO+POS já em terminadas):', duplicadas.map(e => ({caixa: e.caixa, po: e.po, pos: e.pos, numFatura: e.numFatura, valor: e.valor})));
                    }
                    
                    // Combinar terminadas + pendentes produzidas + faturadas não terminadas
                    const todasEncomendas = [...terminadas, ...pendentesProducidas, ...novasFaturadas];
                    
                    console.log('✅ Terminadas:', terminadas.length, '| Stock:', pendentesProducidas.length, '| Faturadas novas:', novasFaturadas.length, '| Total:', todasEncomendas.length);
                    console.log('💰 Total faturadas no sistema:', terminadas.filter(e=>e.faturada).length + novasFaturadas.length, '(', terminadas.filter(e=>e.faturada).length, 'terminadas +', novasFaturadas.length, 'pendentes)');
                    
                    setEncomendas(todasEncomendas);
                    
                    // Criar mapeamento Caixa → Ecode para usar na análise
                    const newMapCaixaEcode = {};
                    todasEncomendas.forEach(e => {
                        if(e.caixa && e.ecode) newMapCaixaEcode[e.caixa] = e.ecode;
                    });
                    setMapCaixaEcode(newMapCaixaEcode);
                    localStorage.setItem('kpi_mapCaixaEcode', JSON.stringify(newMapCaixaEcode));
                    
                    // Debug - mostrar exemplo com valores
                    const comValor = todasEncomendas.filter(e => e.valor > 0);
                    console.log('📊 Com valor > 0:', comValor.length);
                    console.log('💰 Valor total:', todasEncomendas.reduce((s,e) => s + e.valor, 0));
                    console.log('🗺️ Mapeamento Caixa→Ecode:', Object.keys(newMapCaixaEcode).length, 'entradas');
                    
                    showMsg(`✅ ${terminadas.length} terminadas + ${pendentesProducidas.length} em stock + ${novasFaturadas.length} faturadas = ${todasEncomendas.length} encomendas!`,'success');
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            // Importar Mapa de Horas (Tempo Disponível)
            const importMapaHoras = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar mapa de horas...','info');
                try {
                    const wb = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { res(XLSX.read(new Uint8Array(e.target.result),{type:'array'})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Procurar folha MapaHoras
                    const sheetName = wb.SheetNames.find(n => n.toLowerCase().includes('mapahoras') || n.toLowerCase().includes('mapa')) || wb.SheetNames[0];
                    const data = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {defval:'', raw:true});
                    
                    const mapa = {};
                    data.forEach(row => {
                        const mesRaw = row['Mes'] || row['mes'] || row['Mês'] || row['B'] || '';
                        const totalRaw = row['Total'] || row['total'] || row['TotalHoras'] || row['AH'] || 0;
                        const total = parseFloat(totalRaw) || 0;
                        
                        if(mesRaw && total > 0) {
                            // Converter formato "2026-01" para "01/2026"
                            let mesAno = mesRaw.toString();
                            if(mesAno.includes('-')) {
                                const parts = mesAno.split('-');
                                mesAno = parts[1] + '/' + parts[0];
                            }
                            if(!mapa[mesAno]) mapa[mesAno] = 0;
                            mapa[mesAno] += Math.round(total * 60); // horas para minutos
                        }
                    });
                    
                    if(Object.keys(mapa).length > 0) {
                        setMapaHoras(prev => ({...prev, ...mapa}));
                        localStorage.setItem('kpi_mapaHoras', JSON.stringify({...mapaHoras, ...mapa}));
                    }
                    
                    const resumo = Object.entries(mapa).map(([mes, mins]) => `${mes}: ${(mins/60).toFixed(0)}h`).join(', ');
                    showMsg(`✅ Mapa de Horas importado: ${resumo}`,'success');
                    console.log('✅ Mapa Horas importado:', mapa);
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            const importObjetivos = async (ev) => {
                const file = ev.target.files[0]; if(!file) return;
                showMsg('⏳ A processar objetivos...','info');
                try {
                    const data = await new Promise((res,rej) => {
                        const reader = new FileReader();
                        reader.onload = (e) => { try { const wb=XLSX.read(new Uint8Array(e.target.result),{type:'array'}); res(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]],{defval:'',raw:false})); } catch(err){rej(err);} };
                        reader.onerror = () => rej(new Error('Erro'));
                        reader.readAsArrayBuffer(file);
                    });
                    
                    // Função para converter tempo para minutos
                    const parseTempoParaMinutos = (tempo) => {
                        if(!tempo) return 0;
                        const t = tempo.toString().trim();
                        
                        // Formato "X days HH:MM:SS" (ex: "1 days 05:10:00")
                        const matchDays = t.match(/(\d+)\s*days?\s*(\d{1,2}):(\d{2})/i);
                        if(matchDays) {
                            const dias = parseInt(matchDays[1]) || 0;
                            const horas = parseInt(matchDays[2]) || 0;
                            const mins = parseInt(matchDays[3]) || 0;
                            return (dias * 24 * 60) + (horas * 60) + mins;
                        }
                        
                        // Formato "HH:MM:SS" ou "HH:MM"
                        const matchTime = t.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
                        if(matchTime) {
                            const horas = parseInt(matchTime[1]) || 0;
                            const mins = parseInt(matchTime[2]) || 0;
                            return (horas * 60) + mins;
                        }
                        
                        // Se for número (minutos diretos)
                        const num = parseFloat(t);
                        if(!isNaN(num)) return num;
                        
                        return 0;
                    };
                    
                    const objs = {};
                    const objsTipo = {};
                    
                    data.forEach(row => {
                        // Objetivos por operação - normalizar nome
                        const operacaoRaw = findValue(row, ['Operação','operacao','OPERAÇÃO','Op']);
                        const operacao = normalizarOperacao(operacaoRaw);
                        const tempoOp = findValue(row, ['Tempo Objetivo','TempoObjetivo','Tempo','tempo','Objetivo','objetivo','Minutos']);
                        if(operacao && tempoOp) {
                            const mins = parseTempoParaMinutos(tempoOp);
                            if(mins > 0) {
                                objs[operacao] = mins;
                                // Também guardar com nome original para compatibilidade
                                if(operacaoRaw !== operacao) objs[operacaoRaw] = mins;
                            }
                        }
                        
                        // Objetivos por tipologia
                        const tipologia = findValue(row, ['Tipologia','tipologia','TIPOLOGIA']);
                        const tempoTipo = findValue(row, ['Tempo Objetivo','TempoObjetivo','Tempo Tipologia','Tempo','tempo']);
                        if(tipologia && tempoTipo) {
                            const mins = parseTempoParaMinutos(tempoTipo);
                            if(mins > 0) objsTipo[tipologia] = mins;
                        }
                    });
                    
                    // Guardar os que foram encontrados
                    if(Object.keys(objs).length > 0) {
                        setObjetivos(prev => ({...prev, ...objs}));
                        localStorage.setItem('kpi_objetivos', JSON.stringify({...objetivos, ...objs}));
                    }
                    if(Object.keys(objsTipo).length > 0) {
                        setObjetivosTipologia(prev => ({...prev, ...objsTipo}));
                        localStorage.setItem('kpi_objetivosTipologia', JSON.stringify({...objetivosTipologia, ...objsTipo}));
                    }
                    
                    const totalOps = Object.keys(objs).length;
                    const totalTipo = Object.keys(objsTipo).length;
                    showMsg(`✅ Importado: ${totalOps > 0 ? totalOps + ' operações' : ''}${totalOps > 0 && totalTipo > 0 ? ' + ' : ''}${totalTipo > 0 ? totalTipo + ' tipologias' : ''}!`,'success');
                } catch(err) { showMsg('❌ Erro: '+err.message,'error'); console.error(err); }
                ev.target.value = '';
            };
            
            useEffect(() => { 
                try { 
                    const s=localStorage.getItem('kpi_objetivos'); if(s) setObjetivos(JSON.parse(s)); 
                    const st=localStorage.getItem('kpi_objetivosTipologia'); if(st) setObjetivosTipologia(JSON.parse(st));
                    const sm=localStorage.getItem('kpi_mapCaixaEcode'); if(sm) setMapCaixaEcode(JSON.parse(sm));
                    const mh=localStorage.getItem('kpi_mapaHoras'); if(mh) setMapaHoras(JSON.parse(mh));
                } catch(e){} 
            }, []);
            
            const kpis = useMemo(() => {
                let encFiltradas = encomendas;
                let opsFiltradas = registosOperacoes;
                let pertFiltradas = registosPerturbacoes;
                
                // Função para extrair ano de mesAno (formato "MM/YYYY")
                const getAno = (mesAno) => {
                    if(!mesAno) return '';
                    const parts = mesAno.split('/');
                    return parts.length === 2 ? parts[1] : '';
                };
                
                // Filtro por ano (aplicado primeiro) - prioridade: entrega > embalamento > produção
                if(filtroAno) {
                    const antesAno = encFiltradas.length;
                    const fatAntesAno = encFiltradas.filter(e => e.faturada).length;
                    encFiltradas = encomendas.filter(e => {
                        const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                        // Se não tem data mas tem fatura, incluir (não excluir faturadas sem data)
                        if(!ano && e.faturada) return true;
                        return ano === filtroAno;
                    });
                    const fatDepoisAno = encFiltradas.filter(e => e.faturada).length;
                    console.log(`🔍 Filtro ano ${filtroAno}: ${antesAno} → ${encFiltradas.length} encomendas | Faturadas: ${fatAntesAno} → ${fatDepoisAno}`);
                    // Debug: mostrar encomendas faturadas que foram excluídas pelo filtro
                    if(fatAntesAno > fatDepoisAno) {
                        const excluidas = encomendas.filter(e => e.faturada && !encFiltradas.includes(e));
                        console.log('⚠️ Faturadas excluídas pelo filtro ano:', excluidas.map(e => ({caixa: e.caixa, mesAnoEntrega: e.mesAnoEntrega, mesAnoEmbalamento: e.mesAnoEmbalamento, mesAnoProducao: e.mesAnoProducao, origem: e._origem, valor: e.valor})));
                    }
                    opsFiltradas = registosOperacoes.filter(r => getAno(r.mesAno) === filtroAno);
                    pertFiltradas = registosPerturbacoes.filter(r => getAno(r.mesAno) === filtroAno);
                }
                
                // Filtro por mês
                if(filtroMes) {
                    const antesMes = encFiltradas.length;
                    const fatAntesMes = encFiltradas.filter(e => e.faturada).length;
                    encFiltradas = encFiltradas.filter(e => {
                        const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                        // Se não tem data de referência mas tem fatura, incluir (não excluir faturadas sem data)
                        if(!mesRef && e.faturada) return true;
                        return mesRef === filtroMes;
                    });
                    const fatDepoisMes = encFiltradas.filter(e => e.faturada).length;
                    console.log(`🔍 Filtro mês ${filtroMes}: ${antesMes} → ${encFiltradas.length} encomendas | Faturadas: ${fatAntesMes} → ${fatDepoisMes}`);
                    // Debug: mostrar encomendas faturadas que foram excluídas pelo filtro de mês
                    if(fatAntesMes > fatDepoisMes) {
                        const todasAno = encomendas.filter(e => {
                            const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                            return ano === (filtroAno || ano);
                        });
                        const excluidas = todasAno.filter(e => e.faturada).filter(e => {
                            const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                            return mesRef !== filtroMes;
                        });
                        console.log('⚠️ Faturadas excluídas pelo filtro mês:', excluidas.map(e => ({caixa: e.caixa, mesAnoEntrega: e.mesAnoEntrega, mesAnoEmbalamento: e.mesAnoEmbalamento, mesAnoProducao: e.mesAnoProducao, mesRef: e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao, origem: e._origem, valor: e.valor})));
                    }
                    if(antesMes > 0 && encFiltradas.length < antesMes) {
                        const filtradas = encomendas.filter(e => {
                            const ano = getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoEntrega) || getAno(e.mesAnoProducao);
                            return ano === (filtroAno || ano);
                        }).filter(e => {
                            const mesRef = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao;
                            return mesRef !== filtroMes;
                        });
                        if(filtradas.length > 0) console.log('🔍 Exemplo excluída pelo filtro mês:', { caixa: filtradas[0].caixa, mesAnoEntrega: filtradas[0].mesAnoEntrega, mesAnoProducao: filtradas[0].mesAnoProducao, mesAnoEmbalamento: filtradas[0].mesAnoEmbalamento, faturada: filtradas[0].faturada, origem: filtradas[0]._origem });
                    }
                    opsFiltradas = opsFiltradas.filter(r => r.mesAno===filtroMes);
                    pertFiltradas = pertFiltradas.filter(r => r.mesAno===filtroMes);
                }
                
                // Filtro por tipologia (com mapeamento entre encomendas e registos)
                if(filtroTipologia) {
                    // Mapeamento de tipologias equivalentes
                    const tipologiasEquivalentes = {
                        'Frac': ['Frac', 'E2-Frac', 'E1'],
                        'E2-Frac': ['Frac', 'E2-Frac'],
                        'E1': ['Frac', 'E1'],
                        'E2': ['E2'],
                        'Praetor': ['Praetor'],
                        'KC390': ['KC390'],
                        'Transporte': ['Transporte'],
                        'Maquinacao': ['Maquinacao', 'Frac']
                    };
                    const tiposValidos = tipologiasEquivalentes[filtroTipologia] || [filtroTipologia];
                    encFiltradas = encFiltradas.filter(e => tiposValidos.includes(e.tipologia));
                    opsFiltradas = opsFiltradas.filter(r => tiposValidos.includes(r.tipologia));
                }
                
                // === KPIs de Encomendas Terminadas ===
                const totalEncomendas = encFiltradas.length;
                const encFaturadas = encFiltradas.filter(e => e.faturada);
                const encNaoFaturadas = encFiltradas.filter(e => !e.faturada);
                const taxaFaturacao = totalEncomendas > 0 ? (encFaturadas.length / totalEncomendas) * 100 : 0;
                
                // Valores
                const valorTotal = encFiltradas.reduce((s,e) => s + (e.valor || 0), 0);
                const valorFaturado = encFaturadas.reduce((s,e) => s + (e.valor || 0), 0);
                const valorPorFaturar = encNaoFaturadas.reduce((s,e) => s + (e.valor || 0), 0);
                
                // Totais ANUAIS (sem filtro de mês) para referência
                const encAnuais = filtroAno ? encomendas.filter(e => {
                    const ano = getAno(e.mesAnoEntrega) || getAno(e.mesAnoEmbalamento) || getAno(e.mesAnoProducao);
                    return ano === filtroAno || (!ano && e.faturada);
                }) : encomendas;
                const totalFaturadasAnual = encAnuais.filter(e => e.faturada).length;
                const valorFaturadoAnual = encAnuais.filter(e => e.faturada).reduce((s,e) => s + (e.valor || 0), 0);
                const totalEncAnual = encAnuais.length;
                
                console.log('💰 KPIs Financeiros (filtrados):', { 
                    totalEnc: totalEncomendas, faturadas: encFaturadas.length, naoFaturadas: encNaoFaturadas.length,
                    valorTotal: valorTotal.toFixed(2), valorFaturado: valorFaturado.toFixed(2), valorPorFaturar: valorPorFaturar.toFixed(2)
                });
                console.log('💰 KPIs Financeiros (anuais):', { 
                    totalEncAnual, totalFaturadasAnual, valorFaturadoAnual: valorFaturadoAnual.toFixed(2)
                });
                
                // Valores por Localização (ANN Compósitos vs ANN Metálicos)
                const valorPorLocalizacao = {};
                encFiltradas.forEach(e => {
                    const loc = e.localizacao || 'Sem Localização';
                    if(!valorPorLocalizacao[loc]) valorPorLocalizacao[loc] = { total: 0, faturado: 0, porFaturar: 0, quantidade: 0 };
                    valorPorLocalizacao[loc].total += e.valor || 0;
                    valorPorLocalizacao[loc].quantidade += e.quantidade || 1;
                    if(e.faturada) {
                        valorPorLocalizacao[loc].faturado += e.valor || 0;
                    } else {
                        valorPorLocalizacao[loc].porFaturar += e.valor || 0;
                    }
                });
                console.log('📊 Valores por Localização:', valorPorLocalizacao);
                
                // Quantidades - produzidas = terminadas + stock (sem faturadas que falta embalamento)
                const encTerminadasEStock = encFiltradas.filter(e => e._origem === 'terminada' || e._origem === 'stock');
                const totalProduzido = encTerminadasEStock.reduce((s,e) => s + (e.quantidade || 0), 0);
                const totalEntregue = encFiltradas.reduce((s,e) => s + (e.qtdEntregue || 0), 0);
                const totalEmbalado = encFiltradas.reduce((s,e) => s + (e.qtdEmbalada || 0), 0);
                
                // Separar por origem: terminadas, stock, faturadas não terminadas
                const encEntregues = encFiltradas.filter(e => e._origem === 'terminada');
                const encEmStock = encFiltradas.filter(e => e._origem === 'stock');
                const encFaturadasNaoTerminadas = encFiltradas.filter(e => e._origem === 'faturada');
                const totalEncEntregues = encEntregues.length;
                const totalEncEmStock = encEmStock.length;
                const totalEncFatNaoTerm = encFaturadasNaoTerminadas.length;
                const unidadesEmStock = encEmStock.reduce((s,e) => s + (e.quantidade || 0), 0);
                
                console.log('📊 Encomendas:', { total: encFiltradas.length, entregues: totalEncEntregues, emStock: totalEncEmStock, fatNaoTerm: totalEncFatNaoTerm, unidadesStock: unidadesEmStock });
                
                // Por Tipologia
                const porTipologia = {};
                encFiltradas.forEach(e => {
                    const tip = e.tipologia || 'Sem Tipologia';
                    if(!porTipologia[tip]) porTipologia[tip] = { quantidade:0, qtdEntregue:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porTipologia[tip].quantidade += e.quantidade || 1;
                    porTipologia[tip].qtdEntregue += e.qtdEntregue || 0;
                    porTipologia[tip].valor += e.valor || 0;
                    if(e.faturada) {
                        porTipologia[tip].valorFaturado += e.valor || 0;
                        porTipologia[tip].faturadas++;
                    }
                    porTipologia[tip].total++;
                });
                
                // Debug
                console.log('📊 encFiltradas:', encFiltradas.length);
                console.log('📊 porTipologia:', porTipologia);
                console.log('📊 Filtro Ano:', filtroAno, 'Mês:', filtroMes);
                
                // Por Caixa/Ligação
                const porCaixa = {};
                encFiltradas.forEach(e => {
                    const cx = e.ligacao || e.caixa || 'Sem Caixa';
                    if(!porCaixa[cx]) porCaixa[cx] = { quantidade:0, qtdEntregue:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porCaixa[cx].quantidade += e.quantidade || 1;
                    porCaixa[cx].qtdEntregue += e.qtdEntregue || 0;
                    porCaixa[cx].valor += e.valor || 0;
                    if(e.faturada) {
                        porCaixa[cx].valorFaturado += e.valor || 0;
                        porCaixa[cx].faturadas++;
                    }
                    porCaixa[cx].total++;
                });
                
                // Por Mês (prioridade: entrega > embalamento > produção)
                const porMes = {};
                encFiltradas.forEach(e => {
                    const mes = e.mesAnoEntrega || e.mesAnoEmbalamento || e.mesAnoProducao || 'Sem Data';
                    if(mes === 'Sem Data' || !mes) return;
                    if(!porMes[mes]) porMes[mes] = { quantidade:0, valor:0, valorFaturado:0, faturadas:0, total:0 };
                    porMes[mes].quantidade += e.quantidade || 1;
                    porMes[mes].valor += e.valor || 0;
                    if(e.faturada) {
                        porMes[mes].valorFaturado += e.valor || 0;
                        porMes[mes].faturadas++;
                    }
                    porMes[mes].total++;
                });
                
                // === KPIs de Operações (OEE) ===
                const tempoTotalOps = opsFiltradas.reduce((s,r) => s + r.duracao, 0);
                const numOperacoes = opsFiltradas.length;
                
                // Tempo Disponível REAL do Mapa de Horas (soma de todos os meses filtrados)
                let tempoDisponivelReal = 0;
                if(Object.keys(mapaHoras).length > 0) {
                    if(filtroMes) {
                        // Mês específico selecionado
                        tempoDisponivelReal = mapaHoras[filtroMes] || 0;
                    } else {
                        // Todos os meses do ano filtrado - somar apenas os meses que têm operações
                        const mesesComOps = [...new Set(opsFiltradas.map(r => r.mesAno))].filter(m => m);
                        mesesComOps.forEach(mes => {
                            tempoDisponivelReal += mapaHoras[mes] || 0;
                        });
                        // Se não encontrou por meses com operações, somar todos os do ano
                        if(tempoDisponivelReal === 0 && filtroAno) {
                            Object.entries(mapaHoras).forEach(([mes, mins]) => {
                                if(mes.endsWith('/' + filtroAno)) {
                                    tempoDisponivelReal += mins;
                                }
                            });
                        }
                    }
                }
                
                const usaMapaHoras = tempoDisponivelReal > 0;
                console.log('⏰ Tempo Disponível:', usaMapaHoras ? 
                    `REAL (Mapa Horas): ${(tempoDisponivelReal/60).toFixed(1)}h` : 
                    `APROXIMADO (Ops): ${(tempoTotalOps/60).toFixed(1)}h`);
                
                // Performance: usar os rácios calculados nas análises (se disponíveis)
                // Por agora, usar um valor conservador baseado no rácio médio
                // Performance real será calculada depois da análise de operações
                
                // Eficiência por tipologia
                const eficienciaPorTipologia = {};
                const tempoPorTipologia = {};
                opsFiltradas.forEach(r => {
                    if(!tempoPorTipologia[r.tipologia]) tempoPorTipologia[r.tipologia] = {real:0, objetivo:0, count:0};
                    tempoPorTipologia[r.tipologia].real += r.duracao;
                    if(objetivos[r.operacao]) tempoPorTipologia[r.tipologia].objetivo += objetivos[r.operacao];
                    tempoPorTipologia[r.tipologia].count++;
                });
                Object.keys(tempoPorTipologia).forEach(t => {
                    const d = tempoPorTipologia[t];
                    eficienciaPorTipologia[t] = { tempoReal:d.real, tempoObjetivo:d.objetivo, eficiencia: d.real > 0 && d.objetivo > 0 ? (d.objetivo / d.real) * 100 : 0, numOps:d.count };
                });
                
                const tempoPerturbacoes = pertFiltradas.reduce((s,r) => s+r.duracao,0);
                const numPerturbacoes = pertFiltradas.length;
                
                const perturbacoesPorTipo = {};
                pertFiltradas.forEach(r => {
                    if(!perturbacoesPorTipo[r.tipo]) perturbacoesPorTipo[r.tipo] = {tempo:0,count:0};
                    perturbacoesPorTipo[r.tipo].tempo += r.duracao;
                    perturbacoesPorTipo[r.tipo].count++;
                });
                
                // DISPONIBILIDADE:
                // Com Mapa Horas: (Tempo Disponível Real - Perturbações) / Tempo Disponível Real
                // Sem Mapa Horas: (Tempo Operações - Perturbações) / Tempo Operações (aproximação)
                const tempoBase = usaMapaHoras ? tempoDisponivelReal : tempoTotalOps;
                const tempoDisponivel = tempoBase > 0 ? tempoBase - tempoPerturbacoes : 0;
                const disponibilidade = tempoBase > 0 ? (tempoDisponivel / tempoBase) * 100 : 0;
                
                // Performance será calculada mais tarde baseada nos rácios reais
                let performance = 0;
                const qualidade = 100;
                let oee = 0;
                
                // Meses únicos das encomendas e operações
                const mesesEnc = Object.keys(porMes).filter(m => m && m !== 'Sem Data');
                const mesesOps = [...new Set(opsFiltradas.map(r => r.mesAno))].filter(m => m);
                const mesesUnicos = [...new Set([...mesesEnc, ...mesesOps])].sort((a,b) => {
                    const [ma,ya] = a.split('/').map(Number);
                    const [mb,yb] = b.split('/').map(Number);
                    return ya !== yb ? ya - yb : ma - mb;
                });
                
                // OEE por mês
                const oeePorMes = {};
                mesesUnicos.forEach(mes => {
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    const pertMes = pertFiltradas.filter(r => r.mesAno === mes);
                    const tempoOpsMes = opsMes.reduce((s,r) => s + r.duracao, 0);
                    const tempoPertMes = pertMes.reduce((s,r) => s + r.duracao, 0);
                    
                    // Usar tempo do Mapa de Horas se disponível, senão usar tempo de operações
                    const tempoBaseMes = mapaHoras[mes] || tempoOpsMes;
                    const tempoDispMes = tempoBaseMes - tempoPertMes;
                    const dispMes = tempoBaseMes > 0 ? (tempoDispMes / tempoBaseMes) * 100 : 0;
                    const perfMes = 0; // Será actualizado depois
                    const oeeMes = 0; // Será actualizado depois
                    oeePorMes[mes] = { 
                        tempoOperacoes: tempoOpsMes, 
                        tempoPerturbacoes: tempoPertMes, 
                        tempoDisponivel: tempoBaseMes,
                        usaMapaHoras: !!(mapaHoras[mes]),
                        disponibilidade: dispMes, 
                        performance: perfMes, 
                        oee: oeeMes 
                    };
                });
                
                // Evolução mensal (encomendas + operações)
                const evolucaoMensal = mesesUnicos.map(mes => {
                    const encMes = porMes[mes] || { quantidade: 0, valor: 0, valorFaturado: 0, total: 0 };
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    const pertMes = pertFiltradas.filter(r => r.mesAno === mes);
                    const tempoOpsMes = opsMes.reduce((s,r) => s + r.duracao, 0);
                    const tempoMapaHorasMes = mapaHoras[mes] || 0;
                    const horasDisponiveisMes = tempoMapaHorasMes > 0 ? tempoMapaHorasMes / 60 : tempoOpsMes / 60;
                    return { 
                        mes, 
                        encomendas: encMes.total,
                        quantidade: encMes.quantidade,
                        valor: encMes.valor,
                        valorFaturado: encMes.valorFaturado,
                        tempoOperacoes: tempoOpsMes,
                        horasOperacoes: tempoOpsMes / 60,
                        horasDisponiveis: horasDisponiveisMes,
                        usaMapaHoras: tempoMapaHorasMes > 0,
                        entregues: encMes.total,
                        perturbacoes: pertMes.reduce((s,r) => s + r.duracao, 0)
                    };
                });
                
                // Tipologias únicas (apenas tipologias reais, não ligações/caixas)
                const tipologias = [...new Set([
                    ...encomendas.map(e => e.tipologia),
                    ...registosOperacoes.map(r => r.tipologia)
                ])].filter(t => t).sort();
                
                // Calcular quantidade produzida por tipologia das encomendas FILTRADAS
                const qtdPorTipologia = {};
                encFiltradas.forEach(e => {
                    const tip = e.tipologia || 'Sem Tipologia';
                    if(!qtdPorTipologia[tip]) qtdPorTipologia[tip] = 0;
                    qtdPorTipologia[tip] += e.qtdEntregue || e.quantidade || 0;
                });
                
                // Calcular quantidade por Caixa/Artigo de TODAS as encomendas (filtradas por ano/mês, mas NÃO por tipologia)
                // Isto permite que E1-Embalagem (tipologia Frac) seja encontrada quando filtramos por tipologia E1
                const encFiltradasSemTipologia = encomendas.filter(e => {
                    const mesAno = e.mesAnoEmbalamento || e.mesAnoEntrega || e.mesAnoProducao;
                    const ano = mesAno ? mesAno.split('/')[1] : '';
                    if(filtroAno && ano !== filtroAno) return false;
                    if(filtroMes && mesAno !== filtroMes) return false;
                    return true;
                });
                
                // Também filtrar encomendas em produção (pendentes) pelo mesmo critério
                // Só incluir as que têm data de produção preenchida (já produzidas, em stock)
                const encProducaoFiltradas = encomendasProducao.filter(e => {
                    // Só contar se tem data de produção (já foi produzida)
                    if(!e.mesAnoProducao || e.mesAnoProducao === '') return false;
                    
                    const mesAno = e.mesAnoProducao;
                    const ano = mesAno ? mesAno.split('/')[1] : '';
                    if(filtroAno && ano !== filtroAno) return false;
                    if(filtroMes && mesAno !== filtroMes) return false;
                    return true;
                });
                
                // Juntar terminadas + produção para cálculo de quantidades do OEE
                const todasEncParaOEE = [...encFiltradasSemTipologia, ...encProducaoFiltradas];
                console.log('📦 Encomendas para OEE:', { terminadas: encFiltradasSemTipologia.length, producao: encProducaoFiltradas.length, total: todasEncParaOEE.length });
                
                const qtdPorCaixaArtigo = {};
                const qtdPorCaixaNormalizada = {}; // Com espaços normalizados
                todasEncParaOEE.forEach(e => {
                    const caixa = e.caixa || '';
                    if(caixa) {
                        if(!qtdPorCaixaArtigo[caixa]) qtdPorCaixaArtigo[caixa] = 0;
                        // Usar quantidade PRODUZIDA (não entregue) para OEE
                        qtdPorCaixaArtigo[caixa] += e.quantidade || e.qtdProduzida || e.qtdEntregue || 0;
                        
                        // Também guardar versão normalizada (sem espaços extras)
                        const caixaNorm = caixa.replace(/\s+/g, ' ').trim();
                        if(!qtdPorCaixaNormalizada[caixaNorm]) qtdPorCaixaNormalizada[caixaNorm] = 0;
                        qtdPorCaixaNormalizada[caixaNorm] += e.quantidade || e.qtdProduzida || e.qtdEntregue || 0;
                    }
                });
                
                // Performance por Caixa/Artigo (baseado nas operações e objetivos por tipologia/caixa)
                const performancePorCaixa = {};
                // Agrupar operações por caixa/artigo
                const opsPorCaixa = {};
                opsFiltradas.forEach(r => {
                    const caixa = r.caixa || r.artigo || 'Sem Caixa';
                    if(!opsPorCaixa[caixa]) opsPorCaixa[caixa] = { tempoReal: 0, count: 0 };
                    opsPorCaixa[caixa].tempoReal += r.duracao;
                    opsPorCaixa[caixa].count++;
                });
                
                // Função para normalizar nomes (remover espaços extras, converter * para x)
                const normalizarNome = (nome) => {
                    return nome.replace(/\s+/g, ' ').replace(/\*/g, 'x').trim().toLowerCase();
                };
                
                // Criar mapa de objetivos normalizados
                const objetivosNorm = {};
                Object.entries(objetivosTipologia).forEach(([nome, tempo]) => {
                    objetivosNorm[normalizarNome(nome)] = tempo;
                    objetivosNorm[nome] = tempo;
                    objetivosNorm[nome.toLowerCase()] = tempo;
                    // Também sem espaços
                    objetivosNorm[nome.replace(/\s+/g, '').toLowerCase()] = tempo;
                });
                
                // Mapeamentos manuais para nomes que não correspondem
                const mapeamentoNomes = {
                    'transporte': 'transportes',
                    'cxs sobras tipo jaula 1600': 'cxs sobras tipo jaula 1600x1200x800',
                };
                
                // Calcular performance para cada caixa
                Object.entries(opsPorCaixa).forEach(([caixa, dados]) => {
                    // Tentar encontrar objetivo para esta caixa
                    const caixaNorm = normalizarNome(caixa);
                    const caixaSemEspacos = caixa.replace(/\s+/g, '').toLowerCase();
                    
                    // Primeiro tentar nome direto, depois normalizado, depois sem espaços, depois mapeamento
                    let tempoObj = objetivosTipologia[caixa] || 
                                   objetivosNorm[caixaNorm] || 
                                   objetivosNorm[caixaSemEspacos] ||
                                   objetivosNorm[caixa.replace(/\s+/g, ' ').trim()] ||
                                   (mapeamentoNomes[caixaNorm] ? objetivosNorm[mapeamentoNomes[caixaNorm]] : 0) ||
                                   0;
                    
                    // Obter quantidade produzida desta caixa (com normalização melhorada)
                    const caixaTrim = caixa.replace(/\s+/g, ' ').trim();
                    let qtdProduzida = qtdPorCaixaArtigo[caixa] || 
                                       qtdPorCaixaArtigo[caixaTrim] || 
                                       qtdPorCaixaNormalizada[caixaTrim] || 0;
                    
                    // Se não encontrou, tentar procurar com normalização mais agressiva
                    if(qtdProduzida === 0) {
                        const caixaLower = caixaNorm;
                        Object.entries(qtdPorCaixaArtigo).forEach(([enc, qtd]) => {
                            // Normalizar: remover espaços extras, lowercase
                            const encNorm = enc.replace(/\s+/g, ' ').trim().toLowerCase();
                            // Também comparar sem NENHUM espaço (mais agressivo)
                            const encSemEspacos = enc.replace(/\s+/g, '').toLowerCase();
                            const caixaSemEspacos = caixa.replace(/\s+/g, '').toLowerCase();
                            
                            if((encNorm === caixaLower || encSemEspacos === caixaSemEspacos) && qtd > 0) {
                                qtdProduzida = qtd;
                            }
                        });
                    }
                    
                    // Debug: mostrar caixas sem quantidade
                    if(qtdProduzida === 0 && dados.tempoReal > 60) {
                        console.log('⚠️ Sem quantidade:', caixa, '| Normalizado:', caixaNorm, '| SemEspaços:', caixa.replace(/\s+/g, '').toLowerCase());
                    }
                    
                    // Caso especial: Transporte usa o NÚMERO DE ENCOMENDAS TERMINADAS (entregas feitas)
                    if(caixaNorm === 'transporte' || caixaNorm === 'transportes') {
                        // Usar apenas encomendas terminadas (não pendentes)
                        qtdProduzida = encFiltradasSemTipologia.length;
                        console.log('🚛 Transporte:', qtdProduzida, 'entregas');
                    }
                    
                    const tempoObjetivoTotal = tempoObj > 0 && qtdProduzida > 0 ? tempoObj * qtdProduzida : 0;
                    
                    performancePorCaixa[caixa] = {
                        tempoReal: dados.tempoReal,
                        tempoObjetivo: tempoObjetivoTotal,
                        tempoObjUnitario: tempoObj,
                        quantidade: qtdProduzida,
                        performance: dados.tempoReal > 0 && tempoObjetivoTotal > 0 ? (tempoObjetivoTotal / dados.tempoReal) * 100 : 0,
                        numOps: dados.count
                    };
                });
                
                // Mapeamento de tipologias (Registos Produção → Encomendas)
                const mapTipologia = {
                    'E2-Frac': 'Frac',
                    'E1': 'Frac',
                    'Maquinacao': 'Frac',
                    'Transporte': 'Transporte'
                };
                
                // Função para obter quantidade - primeiro por artigos da operação, depois por tipologia
                const getQtdPorOperacao = (tipologia, artigos, operacao) => {
                    // Caso especial: Transporte usa TODAS as caixas entregues
                    if(operacao && operacao.toLowerCase().includes('transporte')) {
                        let totalEntregue = 0;
                        Object.values(qtdPorTipologia).forEach(q => totalEntregue += q);
                        return totalEntregue;
                    }
                    
                    // Se temos artigos específicos, somar quantidade desses artigos
                    if(artigos && artigos.length > 0) {
                        let qtd = 0;
                        artigos.forEach(art => {
                            // Tentar nome exato
                            if(qtdPorCaixaArtigo[art]) {
                                qtd += qtdPorCaixaArtigo[art];
                            } else {
                                // Tentar versão normalizada (sem espaços extras)
                                const artNorm = art.replace(/\s+/g, ' ').trim();
                                if(qtdPorCaixaNormalizada[artNorm]) {
                                    qtd += qtdPorCaixaNormalizada[artNorm];
                                }
                            }
                        });
                        // Se temos artigos específicos, retornar a quantidade encontrada (mesmo que seja 0)
                        // NÃO usar fallback de tipologia para operações com artigos específicos
                        return qtd;
                    }
                    
                    // Só usar tipologia como fallback se NÃO temos artigos específicos
                    // (ex: operações genéricas sem artigo definido)
                    if(qtdPorTipologia[tipologia]) return qtdPorTipologia[tipologia];
                    // Tentar mapeamento
                    const tipMapped = mapTipologia[tipologia];
                    if(tipMapped && qtdPorTipologia[tipMapped]) return qtdPorTipologia[tipMapped];
                    return 0;
                };
                
                // Debug
                console.log('📊 Qtd por Tipologia (filtrado):', qtdPorTipologia);
                console.log('📊 Qtd por Caixa/Artigo:', qtdPorCaixaArtigo);
                console.log('📊 Encomendas filtradas:', encFiltradas.length);
                
                // Análise por Unidade/Tipologia/Operação
                const analiseOperacoes = {};
                opsFiltradas.forEach(r => {
                    const key = `${r.unidadeProducao}|${r.tipologia}|${r.operacao}`;
                    // Buscar objetivo - tentar nome original e normalizado
                    const opNorm = normalizarOperacao(r.operacao);
                    const tempoObj = objetivos[r.operacao] || objetivos[opNorm] || objetivosTipologia[r.tipologia] || 0;
                    if(!analiseOperacoes[key]) {
                        analiseOperacoes[key] = {
                            unidadeProducao: r.unidadeProducao || 'Sem Unidade',
                            caixa: r.artigo || 'Sem Caixa',
                            tipologia: r.tipologia || 'Sem Tipologia',
                            operacao: r.operacao || 'Sem Operação',
                            tempoTotal: 0,
                            tempoObjetivo: tempoObj,
                            numRegistos: 0,
                            artigos: new Set() // Recolher artigos únicos
                        };
                    }
                    analiseOperacoes[key].tempoTotal += r.duracao || 0;
                    analiseOperacoes[key].numRegistos++;
                    if(r.artigo) {
                        analiseOperacoes[key].artigos.add(r.artigo);
                        // Atualizar caixa com o último artigo (ou juntar vários)
                        analiseOperacoes[key].caixa = r.artigo;
                    }
                });
                
                // Calcular métricas derivadas
                const analiseArray = Object.values(analiseOperacoes).map(a => {
                    // Buscar quantidade produzida - primeiro por artigos, depois por tipologia
                    const artigos = Array.from(a.artigos || []);
                    // Se há vários artigos, juntar os nomes
                    const caixaDisplay = artigos.length > 1 ? artigos.join(', ') : (artigos[0] || a.caixa);
                    const qtdProduzida = getQtdPorOperacao(a.tipologia, artigos, a.operacao);
                    const tempoMedioPorCaixa = qtdProduzida > 0 ? a.tempoTotal / qtdProduzida : 0;
                    const tempoObjetivoH = a.tempoObjetivo / 60; // converter para horas
                    const tempoMedioH = tempoMedioPorCaixa / 60;
                    const racio = tempoMedioPorCaixa > 0 && a.tempoObjetivo > 0 ? (a.tempoObjetivo / tempoMedioPorCaixa) * 100 : 0;
                    return {
                        ...a,
                        caixaDisplay,
                        qtdProduzida,
                        tempoTotalH: a.tempoTotal / 60,
                        tempoObjetivoH,
                        tempoMedioPorCaixa,
                        tempoMedioH,
                        racio
                    };
                }).sort((a,b) => {
                    // Ordenar por rácio do mais alto para o mais baixo
                    // Sem rácio (0) vai para o fim
                    if(a.racio > 0 && b.racio === 0) return -1;
                    if(a.racio === 0 && b.racio > 0) return 1;
                    return b.racio - a.racio;
                });
                
                // Calcular OEE com fórmula correcta:
                // Disponibilidade = (Tempo Disponível - Perturbações) / Tempo Disponível
                // Performance = Tempo Objetivo Total Peças / (Tempo Disponível - Perturbações)
                // Qualidade = 100% (fixo)
                // OEE = Disponibilidade × Performance × Qualidade
                
                // Somar total de peças produzidas e tempo objetivo
                let totalPecasProduzidas = 0;
                let tempoObjetivoTotalPecas = 0;
                
                Object.entries(performancePorCaixa).forEach(([caixa, dados]) => {
                    if(dados.quantidade > 0) {
                        totalPecasProduzidas += dados.quantidade;
                        tempoObjetivoTotalPecas += dados.tempoObjetivo; // já é quantidade × tempo unitário
                    }
                });
                
                // Tempo disponível para Performance:
                // = Tempo Disponível Real (Mapa Horas) - Perturbações
                // OU = Tempo Operações - Perturbações (se sem Mapa Horas)
                const tempoParagens = tempoPerturbacoes;
                const tempoUtilParaPerformance = tempoDisponivel; // já é tempoBase - perturbações
                
                // PERFORMANCE = Tempo Objetivo Total / Tempo Útil (Disponível - Perturbações)
                if(tempoUtilParaPerformance > 0 && tempoObjetivoTotalPecas > 0) {
                    performance = (tempoObjetivoTotalPecas / tempoUtilParaPerformance) * 100;
                } else {
                    performance = 0;
                }
                
                // Eficiência geral (para compatibilidade)
                const eficienciaGeral = performance;
                
                // EFICIÊNCIA PRODUTIVA (nova fórmula):
                // = Nº Peças Produzidas / (Cadência Teórica × (Tempo Disponível - Paragens Não Planeadas))
                // Como temos múltiplas caixas com cadências diferentes:
                // = Σ Peças Produzidas / Σ Peças Esperadas
                // Onde Peças Esperadas por caixa = Cadência da caixa × Tempo Útil proporcional
                // Cadência = 1 / Tempo Objetivo Unitário (peças/min)
                // Tempo Útil proporcional = proporção do tempo real da caixa aplicada ao tempo útil total
                
                let eficienciaProdutiva = 0;
                const tempoUtilTotal = tempoDisponivel; // tempoBase - perturbações
                const tempoRealTotal = Object.values(performancePorCaixa).reduce((s,d) => s + d.tempoReal, 0);
                
                if(tempoUtilTotal > 0 && tempoRealTotal > 0 && totalPecasProduzidas > 0) {
                    let pecasEsperadas = 0;
                    Object.entries(performancePorCaixa).forEach(([caixa, dados]) => {
                        if(dados.tempoObjUnitario > 0 && dados.tempoReal > 0) {
                            // Proporção do tempo desta caixa no total
                            const proporcaoTempo = dados.tempoReal / tempoRealTotal;
                            // Tempo útil atribuído a esta caixa
                            const tempoUtilCaixa = tempoUtilTotal * proporcaoTempo;
                            // Cadência teórica = 1 peça / tempoObjUnitario minutos
                            const cadenciaTeor = 1 / dados.tempoObjUnitario;
                            // Peças esperadas neste tempo útil
                            pecasEsperadas += cadenciaTeor * tempoUtilCaixa;
                        }
                    });
                    
                    if(pecasEsperadas > 0) {
                        eficienciaProdutiva = (totalPecasProduzidas / pecasEsperadas) * 100;
                    }
                    
                    console.log('📊 Eficiência Produtiva:', {
                        totalPecasProduzidas,
                        pecasEsperadas: pecasEsperadas.toFixed(0),
                        tempoUtilTotal: (tempoUtilTotal/60).toFixed(1) + 'h',
                        eficienciaProdutiva: eficienciaProdutiva.toFixed(1) + '%'
                    });
                }
                
                // OEE = Disponibilidade × Performance × Qualidade
                oee = disponibilidade > 0 && performance > 0 ? (disponibilidade/100)*(performance/100)*(qualidade/100)*100 : 0;
                
                // Debug
                console.log('📊 OEE calc:', { 
                    totalPecasProduzidas, 
                    tempoObjetivoTotalPecas: (tempoObjetivoTotalPecas/60).toFixed(1) + 'h',
                    tempoBase: (tempoBase/60).toFixed(1) + 'h (' + (usaMapaHoras ? 'Mapa Horas' : 'Aproximação Ops') + ')',
                    tempoParagens: (tempoParagens/60).toFixed(1) + 'h',
                    tempoUtilParaPerformance: (tempoUtilParaPerformance/60).toFixed(1) + 'h',
                    disponibilidade: disponibilidade.toFixed(1) + '%',
                    performance: performance.toFixed(1) + '%',
                    qualidade: qualidade + '%',
                    oee: oee.toFixed(1) + '%'
                });
                console.log('📊 performancePorCaixa:', performancePorCaixa);
                
                // Atualizar OEE por mês com performance calculada individualmente por mês
                Object.keys(oeePorMes).forEach(mes => {
                    const tempoBaseMes = oeePorMes[mes].tempoDisponivel;
                    const tempoPertMes = oeePorMes[mes].tempoPerturbacoes;
                    const tempoUtilMes = tempoBaseMes - tempoPertMes;
                    
                    // Calcular tempo objetivo para as operações DESTE mês
                    let tempoObjMes = 0;
                    const opsMes = opsFiltradas.filter(r => r.mesAno === mes);
                    // Agrupar operações do mês por caixa
                    const opsPorCaixaMes = {};
                    opsMes.forEach(r => {
                        const caixa = r.caixa || r.artigo || 'Sem Caixa';
                        if(!opsPorCaixaMes[caixa]) opsPorCaixaMes[caixa] = 0;
                        opsPorCaixaMes[caixa] += r.duracao;
                    });
                    // Usar a performance global por caixa como proxy
                    Object.entries(opsPorCaixaMes).forEach(([caixa, tempoReal]) => {
                        const dados = performancePorCaixa[caixa];
                        if(dados && dados.tempoReal > 0 && dados.tempoObjetivo > 0) {
                            // Proporção do tempo objetivo para este mês
                            const proporcao = tempoReal / dados.tempoReal;
                            tempoObjMes += dados.tempoObjetivo * proporcao;
                        }
                    });
                    
                    const perfMes = tempoUtilMes > 0 && tempoObjMes > 0 ? (tempoObjMes / tempoUtilMes) * 100 : performance;
                    oeePorMes[mes].performance = perfMes;
                    oeePorMes[mes].oee = oeePorMes[mes].disponibilidade > 0 && perfMes > 0 ? 
                        (oeePorMes[mes].disponibilidade/100) * (perfMes/100) * 100 : 0;
                });
                
                // Anos únicos disponíveis (de todas as encomendas e operações, não filtradas)
                const getAnoFromMesAno = (mesAno) => {
                    if(!mesAno) return '';
                    const parts = mesAno.split('/');
                    return parts.length === 2 ? parts[1] : '';
                };
                const anosEnc = encomendas.map(e => getAnoFromMesAno(e.mesAnoEmbalamento) || getAnoFromMesAno(e.mesAnoEntrega) || getAnoFromMesAno(e.mesAnoProducao));
                const anosOps = registosOperacoes.map(r => getAnoFromMesAno(r.mesAno));
                const anosUnicos = [...new Set([...anosEnc, ...anosOps])].filter(a => a && a >= '2026').sort().reverse();
                
                return { 
                    totalEncomendas, encFaturadas: encFaturadas.length, encNaoFaturadas: encNaoFaturadas.length,
                    taxaFaturacao, valorTotal, valorFaturado, valorPorFaturar, valorPorLocalizacao,
                    totalFaturadasAnual, valorFaturadoAnual, totalEncAnual,
                    totalProduzido, totalEntregue, totalEmbalado, totalEncEntregues, totalEncEmStock, totalEncFatNaoTerm, unidadesEmStock,
                    porTipologia, porCaixa, porMes,
                    tempoTotalOps, numOperacoes, eficienciaGeral, eficienciaPorTipologia, performancePorCaixa,
                    tempoPerturbacoes, numPerturbacoes, perturbacoesPorTipo,
                    disponibilidade, performance, qualidade, oee, oeePorMes, eficienciaProdutiva,
                    evolucaoMensal, mesesUnicos, tipologias, analiseArray, anosUnicos
                };
            }, [encomendas, encomendasProducao, registosProducao, registosOperacoes, registosPerturbacoes, objetivos, objetivosTipologia, mapCaixaEcode, mapaHoras, filtroAno, filtroMes, filtroTipologia]);
            
            useEffect(() => {
                if(kpis.evolucaoMensal.length===0) return;
                const ctx = document.getElementById('chartEvolucao');
                if(!ctx) return;
                if(chartRefs.current.evolucao) chartRefs.current.evolucao.destroy();
                chartRefs.current.evolucao = new Chart(ctx, {
                    type:'bar',
                    data:{ labels:kpis.evolucaoMensal.map(d=>d.mes), datasets:[
                        { label:'Valor Faturado (€)', data:kpis.evolucaoMensal.map(d=>d.valorFaturado), backgroundColor:'rgba(16,185,129,0.7)', borderColor:'#10b981', borderWidth:1, yAxisID:'y' },
                        { type:'line', label:'Encomendas', data:kpis.evolucaoMensal.map(d=>d.encomendas), borderColor:'#f59e0b', backgroundColor:'transparent', borderWidth:2, tension:0.4, yAxisID:'y1' }
                    ]},
                    options:{ responsive:true, maintainAspectRatio:false, interaction:{mode:'index',intersect:false}, plugins:{legend:{labels:{color:'#94a3b8'}}}, scales:{ x:{ticks:{color:'#64748b'},grid:{color:'rgba(148,163,184,0.1)'}}, y:{type:'linear',position:'left',ticks:{color:'#3b82f6',callback:v=>formatCurrency(v)},grid:{color:'rgba(148,163,184,0.1)'}}, y1:{type:'linear',position:'right',ticks:{color:'#f59e0b'},grid:{drawOnChartArea:false}} } }
                });
            }, [kpis.evolucaoMensal]);
            
            // Gráfico de Produtividade (€ faturados / hora trabalhada)
            useEffect(() => {
                if(kpis.evolucaoMensal.length === 0 || activeTab !== 'produtividade') return;
                const ctx = document.getElementById('chartProdutividade');
                if(!ctx) return;
                if(chartRefs.current.produtividade) chartRefs.current.produtividade.destroy();
                
                // Calcular produtividade por mês: valor faturado / horas disponíveis (Mapa de Horas quando disponível)
                const prodFaturadoData = kpis.evolucaoMensal.map(d => {
                    const horas = d.horasDisponiveis || 0;
                    return horas > 0 ? (d.valorFaturado || 0) / horas : 0;
                });
                
                chartRefs.current.produtividade = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: kpis.evolucaoMensal.map(d => d.mes),
                        datasets: [{
                            label: '€ Faturado/hora',
                            data: prodFaturadoData,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16,185,129,0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 6,
                            pointBackgroundColor: '#10b981'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#94a3b8' } },
                            tooltip: { callbacks: { label: (ctx) => ctx.parsed.y.toFixed(2) + ' €/h' } }
                        },
                        scales: {
                            x: { ticks: { color: '#64748b' }, grid: { color: 'rgba(148,163,184,0.1)' } },
                            y: { ticks: { color: '#3b82f6', callback: v => v.toFixed(0) + ' €' }, grid: { color: 'rgba(148,163,184,0.1)' } }
                        }
                    }
                });
            }, [kpis.evolucaoMensal, activeTab]);
            
            // Gráfico de Perturbações Top 5
            useEffect(() => {
                if(Object.keys(kpis.perturbacoesPorTipo || {}).length === 0 || activeTab !== 'perturbacoes') return;
                const ctx = document.getElementById('chartPerturbacoes');
                if(!ctx) return;
                if(chartRefs.current.perturbacoes) chartRefs.current.perturbacoes.destroy();
                
                // Top 5 perturbações por tempo
                const top5 = Object.entries(kpis.perturbacoesPorTipo)
                    .sort((a, b) => b[1].tempo - a[1].tempo)
                    .slice(0, 5);
                
                const cores = ['#f59e0b', '#ef4444', '#8b5cf6', '#10b981', '#3b82f6'];
                
                chartRefs.current.perturbacoes = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: top5.map(([tipo]) => tipo.length > 30 ? tipo.substring(0, 30) + '...' : tipo),
                        datasets: [{
                            label: 'Tempo (horas)',
                            data: top5.map(([, d]) => d.tempo / 60),
                            backgroundColor: cores,
                            borderColor: cores,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            legend: { display: false },
                            tooltip: { callbacks: { label: (ctx) => ctx.parsed.x.toFixed(1) + 'h' } }
                        },
                        scales: {
                            x: { ticks: { color: '#64748b', callback: v => v + 'h' }, grid: { color: 'rgba(148,163,184,0.1)' } },
                            y: { ticks: { color: '#94a3b8' }, grid: { display: false } }
                        }
                    }
                });
            }, [kpis.perturbacoesPorTipo, activeTab]);
            
            const exportarPDF = async () => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('l','mm','a4');
                doc.setFontSize(20); doc.setFont('helvetica','bold'); doc.text('Relatório de KPIs',14,20);
                doc.setFontSize(10); doc.setFont('helvetica','normal'); doc.text('Gerado em: '+new Date().toLocaleDateString('pt-PT'),14,28);
                if(filtroMes) doc.text('Período: '+filtroMes,14,34);
                if(filtroTipologia) doc.text('Tipologia: '+filtroTipologia,100,34);
                
                doc.autoTable({ startY:45, head:[['Indicador','Valor','Meta']], body:[
                    ['Taxa de Conclusão',kpis.taxaConclusao.toFixed(1)+'%','90%'],
                    ['Taxa de Faturação',kpis.taxaFaturacao.toFixed(1)+'%','100%'],
                    ['OEE',kpis.oee.toFixed(1)+'%','85%'],
                    ['Eficiência Geral',kpis.eficienciaGeral.toFixed(1)+'%','100%'],
                    ['Eficiência Produtiva',kpis.eficienciaProdutiva.toFixed(1)+'%','100%'],
                    ['Lead Time Médio',kpis.leadTimeMedia.toFixed(1)+' dias','< 7 dias'],
                    ['Taxa de Atraso',kpis.taxaAtraso.toFixed(1)+'%','< 5%']
                ], styles:{fontSize:9}, headStyles:{fillColor:[59,130,246]} });
                
                const y = doc.lastAutoTable.finalY + 15;
                doc.autoTable({ startY:y, head:[['Descrição','Valor']], body:[
                    ['Valor Faturado',formatCurrency(kpis.valorFaturado)],
                    ['Valor Pendente',formatCurrency(kpis.valorPendente)]
                ], styles:{fontSize:9}, headStyles:{fillColor:[16,185,129]} });
                
                doc.save('Relatorio_KPIs_'+new Date().toLocaleDateString('pt-PT').replace(/\//g,'-')+'.pdf');
                showMsg('✅ PDF exportado!','success');
            };
            
            const temDados = encomendas.length>0 || registosProducao.length>0 || registosOperacoes.length>0;
            
            return e('div',{className:'app'},
                e('header',{className:'header'},
                    e('div',{className:'header-left'},
                        e('div',{className:'logo'},'📊'),
                        e('div',null, 
                            e('h1',null,'Sistema de KPIs'), 
                            e('p',null, lastUpdate ? 'Última atualização: ' + lastUpdate.toLocaleString('pt-PT') : 'Indicadores de Produção e Encomendas')
                        )
                    ),
                    e('div',{style:{display:'flex',gap:'8px',alignItems:'center',flexWrap:'wrap'}},
                        e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading||!urlPowerAutomate,style:{background:isLoading?'#64748b':!urlPowerAutomate?'#475569':''}},
                            isLoading ? '⏳ A carregar...' : '🔄 Atualizar'
                        ),
                        e('button',{className:'btn btn-secondary',onClick:()=>setActiveTab('importar')},'📥 Importar'),
                        e('button',{className:'btn btn-secondary',onClick:()=>setShowConfig(!showConfig)},'⚙️'),
                        temDados && e('button',{className:'btn btn-secondary',onClick:exportarPDF},'📄 PDF')
                    )
                ),
                
                // Modal de Configuração
                showConfig && e('div',{className:'section',style:{marginBottom:'24px',background:'linear-gradient(135deg, var(--bg-secondary), var(--bg-card))'}},
                    e('div',{className:'section-header'},
                        e('h3',{className:'section-title'},'⚙️ Configuração Power Automate'),
                        e('button',{className:'btn btn-secondary',onClick:()=>setShowConfig(false),style:{padding:'6px 12px'}},'✕')
                    ),
                    e('div',{style:{display:'grid',gap:'16px'}},
                        e('div',null,
                            e('label',{style:{display:'block',marginBottom:'6px',fontSize:'13px',color:'var(--text-secondary)'}},'🔗 URL do Fluxo Power Automate:'),
                            e('input',{type:'text',value:urlPowerAutomate,onChange:ev=>setUrlPowerAutomate(ev.target.value),placeholder:'https://prod-XX.westeurope.logic.azure.com/...',style:{width:'100%',padding:'10px 14px',borderRadius:'var(--radius-sm)',background:'var(--bg-primary)',border:'1px solid var(--border-color)',color:'var(--text-primary)',fontSize:'13px'}})
                        ),
                        urlPowerAutomate && e('div',{style:{display:'flex',gap:'12px'}},
                            e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading},
                                isLoading ? '⏳ A testar...' : '🧪 Testar Ligação'
                            )
                        ),
                        e('div',{style:{padding:'12px',background:'var(--accent-blue-soft)',borderRadius:'var(--radius-sm)',fontSize:'12px',color:'var(--text-secondary)'}},
                            e('strong',{style:{color:'var(--accent-blue)'}},'ℹ️ Como configurar: '),
                            e('ol',{style:{margin:'8px 0 0 16px'}},
                                e('li',null,'Cria um fluxo no Power Automate com trigger HTTP'),
                                e('li',null,'Adiciona ações para ler os ficheiros Excel'),
                                e('li',null,'Retorna JSON com: producao, perturbacoes, encomendas, objetivosOperacao, objetivosTipologia, mapaHoras'),
                                e('li',null,'Cola o URL HTTP POST aqui')
                            )
                        ),
                        e('div',{style:{padding:'12px',background:'var(--accent-green-soft)',borderRadius:'var(--radius-sm)',fontSize:'12px'}},
                            e('strong',{style:{color:'var(--accent-green)'}},'📱 Instalar como App: '),
                            'No browser, clica no menu (⋮) e seleciona "Instalar aplicação" ou "Adicionar ao ecrã inicial"'
                        )
                    )
                ),
                
                e('div',{className:'tabs'},
                    e('button',{className:`tab ${activeTab==='dashboard'?'active':''}`,onClick:()=>setActiveTab('dashboard')},'📊 Dashboard'),
                    e('button',{className:`tab ${activeTab==='operacoes'?'active':''}`,onClick:()=>setActiveTab('operacoes')},'🔧 Operações'),
                    e('button',{className:`tab ${activeTab==='perturbacoes'?'active':''}`,onClick:()=>setActiveTab('perturbacoes')},'⚠️ Perturbações'),
                    e('button',{className:`tab ${activeTab==='produtividade'?'active':''}`,onClick:()=>setActiveTab('produtividade')},'📈 Produtividade'),
                    e('button',{className:`tab ${activeTab==='oee'?'active':''}`,onClick:()=>setActiveTab('oee')},'⚙️ OEE'),
                    e('button',{className:`tab ${activeTab==='detalhes'?'active':''}`,onClick:()=>setActiveTab('detalhes')},'📋 Detalhes')
                ),
                
                temDados && activeTab!=='importar' && e('div',{className:'filter-bar'},
                    e('select',{className:'filter-select',value:filtroAno,onChange:ev=>setFiltroAno(ev.target.value)},
                        e('option',{value:''},'📆 Todos os anos'),
                        (kpis.anosUnicos || ['2026']).map(a=>e('option',{key:a,value:a},a))
                    ),
                    e('select',{className:'filter-select',value:filtroMes,onChange:ev=>setFiltroMes(ev.target.value)},
                        e('option',{value:''},'📅 Todos os meses'),
                        kpis.mesesUnicos.map(m=>e('option',{key:m,value:m},m))
                    ),
                    e('select',{className:'filter-select',value:filtroTipologia,onChange:ev=>setFiltroTipologia(ev.target.value)},
                        e('option',{value:''},'🏷️ Todas tipologias'),
                        kpis.tipologias.map(t=>e('option',{key:t,value:t},t))
                    ),
                    (filtroAno||filtroMes||filtroTipologia) && e('button',{className:'btn btn-secondary',onClick:()=>{setFiltroAno('2026');setFiltroMes('');setFiltroTipologia('');}},'✕ Limpar')
                ),
                
                activeTab==='importar' && e('div',null,
                    // Power Automate
                    e('div',{className:'section',style:{marginBottom:'24px'}},
                        e('div',{className:'section-header'},
                            e('h3',{className:'section-title'},'🔄 Carregar via Power Automate'),
                            e('div',{style:{display:'flex',gap:'8px'}},
                                e('button',{className:'btn btn-primary',onClick:carregarDadosPowerAutomate,disabled:isLoading||!urlPowerAutomate},
                                    isLoading ? '⏳ A carregar...' : '🔄 Carregar Todos os Dados'
                                )
                            )
                        ),
                        e('div',{className:'stats-grid-4',style:{display:'grid',gridTemplateColumns:'repeat(4, 1fr)',gap:'16px',marginTop:'16px'}},
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-blue)'}},registosOperacoes.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Operações')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-amber)'}},registosPerturbacoes.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Perturbações')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-green)'}},encomendas.length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Encomendas')
                            ),
                            e('div',{style:{padding:'16px',background:'var(--bg-primary)',borderRadius:'var(--radius-sm)',textAlign:'center'}},
                                e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-cyan)'}},Object.keys(mapaHoras).length),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},'Meses Mapa Horas')
                            )
                        ),
                        !urlPowerAutomate && e('div',{style:{marginTop:'16px',padding:'12px',background:'var(--accent-amber-soft)',borderRadius:'var(--radius-sm)',fontSize:'13px',color:'var(--accent-amber)'}},
                            '⚠️ Configure o URL do Power Automate clicando em ⚙️ no canto superior direito'
                        )
                    ),
                    
                    // Importação manual
                    e('div',{className:'section'},
                        e('h3',{className:'section-title',style:{marginBottom:'20px'}},'📁 Importar Ficheiros Excel (manual)'),
                        e('div',{className:'kpi-grid'},
                            e('label',{className:'upload-zone',style:{gridColumn:'span 2',background:'linear-gradient(135deg, var(--accent-blue-soft), var(--accent-purple-soft))'}},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importRegistosProducao}),
                                e('div',{className:'upload-icon'},'📊'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Registos Produção (Évora)'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},
                                    registosOperacoes.length>0 || registosPerturbacoes.length>0 
                                        ? `✅ ${registosOperacoes.length} operações + ${registosPerturbacoes.length} perturbações`
                                        : 'Ficheiro com folhas Produção + Perturbações'
                                )
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importEncomendas}),
                                e('div',{className:'upload-icon'},'🧾'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Encomendas'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},encomendas.length>0?`✅ ${encomendas.length} registos`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importObjetivos}),
                                e('div',{className:'upload-icon'},'🎯'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Objetivos Operações'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(objetivos).length>0?`✅ ${Object.keys(objetivos).length} operações`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone'},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importObjetivos}),
                                e('div',{className:'upload-icon'},'📋'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Objetivos Tipologias'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(objetivosTipologia).length>0?`✅ ${Object.keys(objetivosTipologia).length} tipologias`:'Clique para importar')
                            ),
                            e('label',{className:'upload-zone',style:{background:'linear-gradient(135deg, var(--accent-green-soft), var(--accent-cyan-soft))'}},
                                e('input',{type:'file',accept:'.xlsx,.xls',onChange:importMapaHoras}),
                                e('div',{className:'upload-icon'},'⏰'),
                                e('div',{style:{fontWeight:'600',marginBottom:'8px'}},'Mapa de Horas (Tempo Disponível)'),
                                e('div',{style:{fontSize:'12px',color:'var(--text-muted)'}},Object.keys(mapaHoras).length>0?`✅ ${Object.keys(mapaHoras).length} meses carregados`:'Ficheiro Configurações App Produção')
                            )
                        )
                    )
                ),
                
                activeTab==='dashboard' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'📊'), e('div',{className:'empty-state-title'},'Nenhum dado importado'), e('div',{className:'empty-state-text'},'Vá ao separador "Importar" para carregar os ficheiros Excel.'))) :
                    e('div',null,
                        // KPI cards
                        e('div',{className:'kpi-grid'},
                            e(KPICard,{icon:'📦',iconColor:'blue',label:'Encomendas',value:formatNumber(kpis.totalEncomendas),valueColor:'blue',meta:`${formatNumber(kpis.totalEncEntregues)} entregues · ${formatNumber(kpis.totalEncEmStock)} stock` + (kpis.totalEncFatNaoTerm > 0 ? ` · ${formatNumber(kpis.totalEncFatNaoTerm)} fat.` : '')}),
                            e(KPICard,{icon:'💵',iconColor:'green',label:'Valor Faturado',value:formatCurrency(kpis.valorFaturado),valueColor:'green',meta:`${kpis.encFaturadas} de ${kpis.totalEncomendas} faturadas`}),
                            e(KPICard,{icon:'📊',iconColor:'red',label:'Perturbações',value:minutosParaHoras(kpis.tempoPerturbacoes),valueColor:kpis.tempoPerturbacoes>0?'red':'green',meta:`${kpis.numPerturbacoes} ocorrências`})
                        ),
                        // Gauges OEE e Eficiência Produtiva
                        e('div',{className:'section',style:{textAlign:'center'}},
                            e('div',{style:{display:'flex',justifyContent:'center',alignItems:'flex-start',gap:'40px',flexWrap:'wrap'}},
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.oee,label:'OEE Geral'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'D × P × Q')
                                ),
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.eficienciaProdutiva,label:'Eficiência Produtiva'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'Peças / (Cadência × T.Útil)')
                                )
                            )
                        ),
                        e('div',{className:'grid-2'},
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'💰 Valores Financeiros'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Valor Faturado'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},formatCurrency(kpis.valorFaturado))),
                                // Totais anuais quando mês filtrado
                                filtroMes && e('div',{style:{marginTop:'12px',paddingTop:'12px',borderTop:'1px dashed var(--border-color)'}},
                                    e('div',{style:{fontSize:'11px',color:'var(--text-muted)',marginBottom:'8px',fontStyle:'italic'}},'📅 Total Anual ('+filtroAno+'):'),
                                    e('div',{className:'summary-row'}, e('span',{className:'summary-label',style:{fontSize:'12px'}},'Faturado no Ano'), e('span',{className:'summary-value',style:{color:'var(--accent-green)',fontSize:'13px'}},formatCurrency(kpis.valorFaturadoAnual))),
                                    e('div',{className:'summary-row'}, e('span',{className:'summary-label',style:{fontSize:'12px'}},'Enc. Faturadas / Total'), e('span',{className:'summary-value',style:{fontSize:'13px'}},kpis.totalFaturadasAnual + ' / ' + kpis.totalEncAnual))
                                ),
                                // Valores por Localização
                                Object.keys(kpis.valorPorLocalizacao || {}).length > 0 && e('div',{style:{marginTop:'16px',paddingTop:'16px',borderTop:'1px solid var(--border-color)'}},
                                    e('div',{style:{fontSize:'13px',fontWeight:'600',marginBottom:'12px',color:'var(--text-secondary)'}},'Por Localização:'),
                                    Object.entries(kpis.valorPorLocalizacao).filter(([loc]) => loc && loc !== 'Sem Localização').sort((a,b) => b[1].total - a[1].total).map(([loc, dados]) => 
                                        e('div',{key:loc,className:'summary-row',style:{marginBottom:'4px'}}, 
                                            e('span',{className:'summary-label'},loc), 
                                            e('span',{className:'summary-value',style:{color:'var(--accent-cyan)'}},formatCurrency(dados.total))
                                        )
                                    )
                                )
                            ),
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Resumo Encomendas'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Terminadas Entregues e Faturadas'), e('span',{className:'summary-value'},formatNumber(kpis.totalEncEntregues))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Em Stock'), e('span',{className:'summary-value',style:{color:'var(--accent-amber)'}},formatNumber(kpis.totalEncEmStock))),
                                kpis.totalEncFatNaoTerm > 0 && e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Faturadas (Entregues mas falta Embalamento)'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},formatNumber(kpis.totalEncFatNaoTerm))),
                                e('div',{className:'summary-row',style:{borderTop:'1px solid var(--border-color)',paddingTop:'8px',marginTop:'4px'}}, e('span',{className:'summary-label',style:{fontWeight:'600'}},'Total'), e('span',{className:'summary-value',style:{fontWeight:'700'}},formatNumber(kpis.totalEncomendas))),
                                e('div',{className:'summary-row',style:{borderTop:'2px solid var(--border-color)',paddingTop:'12px',marginTop:'8px'}}, e('span',{className:'summary-label'},'Unidades Produzidas'), e('span',{className:'summary-value',style:{color:'var(--accent-blue)'}},formatNumber(kpis.totalProduzido))),
                                kpis.unidadesEmStock > 0 && e('div',{style:{fontSize:'11px',color:'var(--text-muted)',textAlign:'right',marginTop:'2px'}},'(inclui '+formatNumber(kpis.unidadesEmStock)+' em stock)')
                            )
                        ),
                        // Tabela por Tipologia
                        Object.keys(kpis.porTipologia).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📦 Quantidade por Tipologia'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipologia'), e('th',null,'Quantidade'), e('th',null,'Valor Total'), e('th',null,'Encomendas'))),
                                e('tbody',null, Object.entries(kpis.porTipologia).sort((a,b)=>b[1].quantidade-a[1].quantidade).slice(0,10).map(([t,d])=>{
                                    return e('tr',{key:t}, 
                                        e('td',null,e('strong',null,t)), 
                                        e('td',null,formatNumber(d.quantidade)), 
                                        e('td',null,formatCurrency(d.valor)), 
                                        e('td',null,formatNumber(d.total))
                                    );
                                }))
                            )
                        ),
                        // Gráfico evolução mensal
                        kpis.evolucaoMensal.length>0 && e('div',{className:'section'}, e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📈 Evolução Mensal'), e('div',{className:'chart-container'}, e('canvas',{id:'chartEvolucao'})))
                    )
                ),
                
                // SEPARADOR OPERAÇÕES
                activeTab==='operacoes' && (!registosOperacoes.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'🔧'), e('div',{className:'empty-state-title'},'Sem dados de operações'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Registos de Produção para ver a análise.'))) :
                    e('div',null,
                        // Tabela de Análise de Operações
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'🔧 Análise de Operações por Unidade / Tipologia'),
                            e('div',{style:{overflowX:'auto'}},
                                e('table',{className:'data-table'},
                                    e('thead',null, 
                                        e('tr',null, 
                                            e('th',null,'Unidade Produção'),
                                            e('th',null,'Caixa'),
                                            e('th',null,'Tipologia'),
                                            e('th',null,'Operação'),
                                            e('th',null,'Tempo Total (h)'),
                                            e('th',null,'Qtd Prod.'),
                                            e('th',null,'T. Obj/cx (h)'),
                                            e('th',null,'T. Médio/cx (h)'),
                                            e('th',null,'Rácio T.Obj/T.Real')
                                        )
                                    ),
                                    e('tbody',null, 
                                        (kpis.analiseArray || []).map((a, idx) => {
                                            const racioColor = a.racio >= 100 ? 'excellent' : a.racio >= 80 ? 'good' : a.racio > 0 ? 'warning' : '';
                                            return e('tr',{key:idx}, 
                                                e('td',null, a.unidadeProducao),
                                                e('td',null, e('strong',null, a.caixaDisplay || a.caixa)),
                                                e('td',null, a.tipologia),
                                                e('td',null, a.operacao),
                                                e('td',null, a.tempoTotalH.toFixed(1)),
                                                e('td',null, formatNumber(a.qtdProduzida)),
                                                e('td',null, a.tempoObjetivoH > 0 ? a.tempoObjetivoH.toFixed(2) : 'N/A'),
                                                e('td',null, a.tempoMedioH.toFixed(2)),
                                                e('td',null, e('span',{className:`status-badge ${racioColor}`}, a.racio > 0 ? a.racio.toFixed(0) + '%' : 'N/A'))
                                            );
                                        })
                                    )
                                )
                            )
                        ),
                        // Resumo por Unidade de Produção
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'🏭 Resumo por Unidade de Produção'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Unidade'), e('th',null,'Tempo Total (h)'), e('th',null,'Nº Operações'), e('th',null,'Média/Op (h)'))),
                                e('tbody',null, 
                                    Object.entries(
                                        (kpis.analiseArray || []).reduce((acc, a) => {
                                            if(!acc[a.unidadeProducao]) acc[a.unidadeProducao] = {tempo:0, ops:0};
                                            acc[a.unidadeProducao].tempo += a.tempoTotalH;
                                            acc[a.unidadeProducao].ops += a.numRegistos;
                                            return acc;
                                        }, {})
                                    ).sort((a,b) => b[1].tempo - a[1].tempo).map(([unidade, d]) =>
                                        e('tr',{key:unidade},
                                            e('td',null, e('strong',null, unidade)),
                                            e('td',null, d.tempo.toFixed(1)),
                                            e('td',null, formatNumber(d.ops)),
                                            e('td',null, d.ops > 0 ? (d.tempo / d.ops).toFixed(2) : 'N/A')
                                        )
                                    )
                                )
                            )
                        )
                    )
                ),
                
                // SEPARADOR PERTURBAÇÕES
                activeTab==='perturbacoes' && (!registosPerturbacoes.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'⚠️'), e('div',{className:'empty-state-title'},'Sem dados de perturbações'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Registos de Produção para ver as perturbações.'))) :
                    e('div',null,
                        // Gráfico de Perturbações Top 5
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'⚠️ Perturbações - Top 5'),
                            e('div',{className:'chart-container',style:{height:'300px'}}, e('canvas',{id:'chartPerturbacoes'}))
                        ),
                        // Tabela detalhada de perturbações
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📋 Detalhe de Perturbações'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo'), e('th',null,'Tempo (h)'), e('th',null,'Ocorrências'), e('th',null,'% do Total'))),
                                e('tbody',null, 
                                    Object.entries(kpis.perturbacoesPorTipo || {})
                                        .sort((a,b) => (b[1].tempo||0) - (a[1].tempo||0))
                                        .map(([tipo, dados]) => {
                                            const tempo = dados.tempo || 0;
                                            const count = dados.count || 0;
                                            const percentagem = kpis.tempoPerturbacoes > 0 ? (tempo / kpis.tempoPerturbacoes * 100) : 0;
                                            return e('tr',{key:tipo},
                                                e('td',null, e('strong',null, tipo)),
                                                e('td',null, (tempo/60).toFixed(1)),
                                                e('td',null, count),
                                                e('td',null, e('span',{className:'status-badge warning'}, percentagem.toFixed(1) + '%'))
                                            );
                                        })
                                )
                            )
                        ),
                        // Resumo
                        e('div',{className:'kpi-grid'},
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, (kpis.tempoPerturbacoes/60).toFixed(1) + 'h'),
                                e('div',{className:'kpi-label'},'Tempo Total Perturbações')
                            ),
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, formatNumber(kpis.numPerturbacoes)),
                                e('div',{className:'kpi-label'},'Total Ocorrências')
                            ),
                            e('div',{className:'kpi-card'},
                                e('div',{className:'kpi-value'}, Object.keys(kpis.perturbacoesPorTipo || {}).length),
                                e('div',{className:'kpi-label'},'Tipos Diferentes')
                            )
                        )
                    )
                ),
                
                // SEPARADOR PRODUTIVIDADE
                activeTab==='produtividade' && (!encomendas.length ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'📈'), e('div',{className:'empty-state-title'},'Sem dados de encomendas'), e('div',{className:'empty-state-text'},'Importe o ficheiro de Encomendas para ver a produtividade.'))) :
                    e('div',null,
                        // Gráfico de Produtividade (€/hora)
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'💰 Produtividade (€ Faturado / Hora Disponível)'),
                            Object.keys(mapaHoras).length > 0 
                                ? e('div',{style:{marginBottom:'12px',fontSize:'11px',color:'var(--accent-green)'}},'✅ Calculado com Mapa de Horas')
                                : e('div',{style:{marginBottom:'12px',fontSize:'11px',color:'var(--accent-amber)'}},'⚠️ Aproximação pelo tempo de operações — importe o Mapa de Horas para dados reais'),
                            e('div',{className:'chart-container',style:{height:'300px'}}, e('canvas',{id:'chartProdutividade'}))
                        ),
                        // KPIs de Produtividade
                        (() => {
                            const totalHorasDisp = kpis.evolucaoMensal.reduce((s,d) => s + (d.horasDisponiveis || 0), 0);
                            const euroHoraTotal = totalHorasDisp > 0 ? kpis.valorTotal / totalHorasDisp : 0;
                            const euroHoraFaturado = totalHorasDisp > 0 ? kpis.valorFaturado / totalHorasDisp : 0;
                            return e('div',null,
                                e('div',{className:'kpi-grid'},
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value',style:{color:'var(--accent-green)'}}, formatCurrency(kpis.valorFaturado)),
                                        e('div',{className:'kpi-label'},'Valor Faturado')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, totalHorasDisp.toFixed(1) + 'h'),
                                        e('div',{className:'kpi-label'}, Object.keys(mapaHoras).length > 0 ? 'Horas Disponíveis (MH)' : 'Horas Trabalhadas')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value',style:{color:'var(--accent-green)'}}, totalHorasDisp > 0 ? formatCurrency(euroHoraFaturado) + '/h' : 'N/A'),
                                        e('div',{className:'kpi-label'},'€ Faturado / Hora')
                                    )
                                ),
                                e('div',{className:'kpi-grid',style:{marginTop:'12px'}},
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, formatNumber(kpis.totalEncomendas)),
                                        e('div',{className:'kpi-label'},'Total Encomendas')
                                    ),
                                    e('div',{className:'kpi-card'},
                                        e('div',{className:'kpi-value'}, formatNumber(kpis.encFaturadas)),
                                        e('div',{className:'kpi-label'},'Faturadas')
                                    )
                                )
                            );
                        })(),
                        // Tabela de produtividade por mês
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Produtividade Mensal'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Mês'), e('th',null,'Faturado'), e('th',null,'Horas'), e('th',null,'€/Hora'), e('th',null,'Enc.'), e('th',null,'Fonte'))),
                                e('tbody',null, 
                                    kpis.evolucaoMensal.map(m => {
                                        const horas = m.horasDisponiveis || 0;
                                        const euroHoraFat = horas > 0 ? (m.valorFaturado || 0) / horas : 0;
                                        return e('tr',{key:m.mes},
                                            e('td',null, e('strong',null, m.mes)),
                                            e('td',null, e('span',{style:{color:'var(--accent-green)'}}, formatCurrency(m.valorFaturado || 0))),
                                            e('td',null, horas.toFixed(1)),
                                            e('td',null, e('span',{className:`status-badge ${euroHoraFat >= 50 ? 'excellent' : euroHoraFat >= 30 ? 'good' : 'warning'}`}, formatCurrency(euroHoraFat))),
                                            e('td',null, formatNumber(m.entregues || 0)),
                                            e('td',null, e('span',{style:{fontSize:'10px',color: m.usaMapaHoras ? 'var(--accent-green)' : 'var(--accent-amber)'}}, m.usaMapaHoras ? '✅ MH' : '~ Ops'))
                                        );
                                    })
                                )
                            )
                        )
                    )
                ),
                
                activeTab==='oee' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'⚙️'), e('div',{className:'empty-state-title'},'Sem dados para OEE'))) :
                    e('div',null,
                        e('div',{className:'section',style:{textAlign:'center'}},
                            e('h3',{className:'section-title',style:{marginBottom:'20px'}},'⚙️ OEE - Overall Equipment Effectiveness'),
                            // Dois gauges lado a lado
                            e('div',{style:{display:'flex',justifyContent:'center',alignItems:'flex-start',gap:'40px',flexWrap:'wrap'}},
                                // Gauge OEE Geral
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.oee,label:'OEE Geral'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'D × P × Q')
                                ),
                                // Gauge Eficiência Produtiva
                                e('div',{style:{textAlign:'center'}},
                                    e(Gauge,{value:kpis.eficienciaProdutiva,label:'Eficiência Produtiva'}),
                                    e('div',{style:{marginTop:'8px',fontSize:'11px',color:'var(--text-muted)'}},'Peças Produzidas / (Cadência × T.Útil)'),
                                    e('div',{style:{marginTop:'4px',fontSize:'10px',color: Object.keys(mapaHoras).length > 0 ? 'var(--accent-green)' : 'var(--accent-amber)'}},
                                        Object.keys(mapaHoras).length > 0 ? '✅ Mapa de Horas' : '⚠️ Aproximação'
                                    )
                                )
                            ),
                            // Componentes OEE
                            e('div',{style:{marginTop:'40px',display:'flex',justifyContent:'space-around',gap:'30px',flexWrap:'wrap',maxWidth:'700px',margin:'40px auto 0'}},
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-blue)'}},kpis.disponibilidade.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Disponibilidade'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-blue)',marginTop:'4px',opacity:0.8}},'(T.Disponível - Perturbações) / T.Disponível')
                                ),
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-green)'}},kpis.performance.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Performance'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-green)',marginTop:'4px',opacity:0.8}},'T.Objetivo Total / T.Útil')
                                ),
                                e('div',{style:{textAlign:'center',minWidth:'140px'}}, 
                                    e('div',{style:{fontSize:'28px',fontWeight:'700',color:'var(--accent-purple)'}},kpis.qualidade.toFixed(1)+'%'), 
                                    e('div',{style:{fontSize:'13px',color:'var(--text-muted)',marginTop:'6px'}},'Qualidade'),
                                    e('div',{style:{fontSize:'10px',color:'var(--accent-purple)',marginTop:'4px',opacity:0.8}},'Peças Boas / Peças Totais')
                                )
                            ),
                            e('div',{style:{marginTop:'20px',fontSize:'12px',color:'var(--text-muted)'}},'OEE = Disponibilidade × Performance × Qualidade'),
                            // Indicador da fonte de dados
                            e('div',{style:{marginTop:'16px',padding:'10px 16px',background: Object.keys(mapaHoras).length > 0 ? 'var(--accent-green-soft)' : 'var(--accent-amber-soft)',borderRadius:'var(--radius-sm)',display:'inline-block',fontSize:'12px'}},
                                Object.keys(mapaHoras).length > 0 
                                    ? e('span',{style:{color:'var(--accent-green)'}}, '✅ Tempo Disponível: Mapa de Horas (real)')
                                    : e('span',{style:{color:'var(--accent-amber)'}}, '⚠️ Tempo Disponível: Aproximação pelo tempo de operações — importe o Mapa de Horas para dados reais')
                            )
                        ),
                        // Diferença entre OEE e Eficiência Produtiva
                        e('div',{className:'section',style:{padding:'20px'}},
                            e('div',{style:{display:'flex',gap:'20px',flexWrap:'wrap'}},
                                // OEE
                                e('div',{style:{flex:'1',minWidth:'250px',background:'rgba(139,92,246,0.08)',borderLeft:'3px solid var(--accent-purple)',borderRadius:'var(--radius-sm)',padding:'16px'}},
                                    e('div',{style:{fontWeight:'700',fontSize:'14px',color:'var(--accent-purple)',marginBottom:'8px'}},'⚙️ OEE — Eficiência Global do Equipamento'),
                                    e('div',{style:{fontSize:'12px',color:'var(--text-muted)',lineHeight:'1.6'}},
                                        'Mede a eficiência global considerando ',
                                        e('strong',null,'todos os factores de perda'),
                                        ': tempo parado (perturbações), velocidade abaixo do objectivo e defeitos. Penaliza por tudo o que reduz a produção face ao potencial máximo.'
                                    ),
                                    e('div',{style:{marginTop:'10px',fontSize:'11px',color:'var(--accent-purple)',fontFamily:'JetBrains Mono, monospace'}},'OEE = Disponibilidade × Performance × Qualidade')
                                ),
                                // Eficiência Produtiva
                                e('div',{style:{flex:'1',minWidth:'250px',background:'rgba(34,197,94,0.08)',borderLeft:'3px solid var(--accent-green)',borderRadius:'var(--radius-sm)',padding:'16px'}},
                                    e('div',{style:{fontWeight:'700',fontSize:'14px',color:'var(--accent-green)',marginBottom:'8px'}},'📊 Eficiência Produtiva'),
                                    e('div',{style:{fontSize:'12px',color:'var(--text-muted)',lineHeight:'1.6'}},
                                        'Mede se a quantidade produzida atingiu o ',
                                        e('strong',null,'objectivo teórico'),
                                        ' para o tempo útil disponível. Compara as peças reais com as peças que deveriam ter sido produzidas à cadência teórica, descontando apenas as paragens não planeadas.'
                                    ),
                                    e('div',{style:{marginTop:'10px',fontSize:'11px',color:'var(--accent-green)',fontFamily:'JetBrains Mono, monospace'}},'EP = Peças Produzidas / (Cadência Teórica × T.Útil)')
                                )
                            ),
                            e('div',{style:{marginTop:'14px',fontSize:'11px',color:'var(--text-muted)',textAlign:'center',fontStyle:'italic'}},
                                'O OEE é sempre ≤ Eficiência Produtiva porque multiplica pela Disponibilidade e Qualidade. A Eficiência Produtiva isola apenas o ritmo de produção face ao objectivo.'
                            )
                        ),
                        e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📐 Detalhe do Cálculo OEE'),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Disponível Total'), e('span',{className:'summary-value',style:{color:'var(--accent-cyan)'}},minutosParaHoras(Object.keys(mapaHoras).length > 0 ? (filtroMes ? (mapaHoras[filtroMes]||0) : Object.entries(mapaHoras).filter(([m])=> !filtroAno || m.endsWith('/'+filtroAno)).reduce((s,e)=>s+e[1],0)) : kpis.tempoTotalOps))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Perturbações'), e('span',{className:'summary-value',style:{color:'var(--accent-red)'}},minutosParaHoras(kpis.tempoPerturbacoes))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Útil (Disponível - Perturbações)'), e('span',{className:'summary-value',style:{color:'var(--accent-green)'}},minutosParaHoras(Math.max(0, (Object.keys(mapaHoras).length > 0 ? (filtroMes ? (mapaHoras[filtroMes]||0) : Object.entries(mapaHoras).filter(([m])=> !filtroAno || m.endsWith('/'+filtroAno)).reduce((s,e)=>s+e[1],0)) : kpis.tempoTotalOps) - kpis.tempoPerturbacoes)))),
                            e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Operações Registado'), e('span',{className:'summary-value'},minutosParaHoras(kpis.tempoTotalOps))),
                            e('div',{className:'summary-row',style:{borderTop:'2px solid var(--border-color)',paddingTop:'12px',marginTop:'4px'}}, 
                                e('span',{className:'summary-label',style:{fontWeight:'600'}},'Fórmulas Utilizadas:'), 
                                e('span',{style:{fontSize:'11px',color:'var(--text-muted)'}},
                                    'Disp = (T.Disponível - Perturbações) / T.Disponível | Perf = T.Objetivo Total / T.Útil | OEE = D × P × Q'
                                )
                            )
                        ),
                        Object.keys(kpis.performancePorCaixa||{}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Performance por Caixa/Artigo'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Caixa/Artigo'), e('th',null,'Tempo Real'), e('th',null,'T.Obj/Cx'), e('th',null,'Qtd'), e('th',null,'T.Obj Total'), e('th',null,'Performance'))),
                                e('tbody',null, Object.entries(kpis.performancePorCaixa).filter(([c,d])=>c!=='Sem Caixa'&&d.tempoReal>0).sort((a,b)=>b[1].tempoReal-a[1].tempoReal).slice(0,25).map(([caixa,d])=>
                                    e('tr',{key:caixa}, 
                                        e('td',null,e('strong',null,caixa)), 
                                        e('td',null,minutosParaHoras(d.tempoReal)), 
                                        e('td',null,d.tempoObjUnitario>0?minutosParaHoras(d.tempoObjUnitario):'N/A'),
                                        e('td',null,d.quantidade||'-'),
                                        e('td',null,d.tempoObjetivo>0?minutosParaHoras(d.tempoObjetivo):'N/A'), 
                                        e('td',null,e('span',{className:`status-badge ${d.performance>=100?'excellent':d.performance>=80?'good':d.performance>0?'warning':''}`},d.performance>0?d.performance.toFixed(1)+'%':'N/A'))
                                    )
                                ))
                            )
                        ),
                        Object.keys(kpis.perturbacoesPorTipo).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'⚠️ Perturbações por Tipo'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo'), e('th',null,'Tempo Total'), e('th',null,'Ocorrências'), e('th',null,'% do Total'))),
                                e('tbody',null, Object.entries(kpis.perturbacoesPorTipo).sort((a,b)=>b[1].tempo-a[1].tempo).map(([t,d])=>
                                    e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,minutosParaHoras(d.tempo)), e('td',null,d.count), e('td',null,e('span',{className:'status-badge warning'},(d.tempo/kpis.tempoPerturbacoes*100).toFixed(1)+'%')))
                                ))
                            )
                        ),
                        Object.keys(kpis.oeePorMes||{}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📅 OEE por Mês'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Mês'), e('th',null,'T. Disponível'), e('th',null,'T. Operações'), e('th',null,'Perturbações'), e('th',null,'Disponibilidade'), e('th',null,'Performance'), e('th',null,'OEE'))),
                                e('tbody',null, Object.entries(kpis.oeePorMes).sort((a,b)=>{const[ma,ya]=a[0].split('/').map(Number),[mb,yb]=b[0].split('/').map(Number);return yb!==ya?yb-ya:mb-ma;}).map(([mes,d])=>
                                    e('tr',{key:mes}, 
                                        e('td',null,e('strong',null,mes)), 
                                        e('td',null,
                                            e('span',{style:{color: d.usaMapaHoras ? 'var(--accent-cyan)' : 'var(--text-muted)'}},
                                                minutosParaHoras(d.tempoDisponivel),
                                                d.usaMapaHoras ? ' ✅' : ' ~'
                                            )
                                        ),
                                        e('td',null,minutosParaHoras(d.tempoOperacoes)), 
                                        e('td',null,e('span',{style:{color:'var(--accent-red)'}},minutosParaHoras(d.tempoPerturbacoes))), 
                                        e('td',null,e('span',{className:`status-badge ${d.disponibilidade>=90?'excellent':d.disponibilidade>=80?'good':'warning'}`},d.disponibilidade.toFixed(1)+'%')),
                                        e('td',null,e('span',{className:`status-badge ${d.performance>=100?'excellent':d.performance>=80?'good':d.performance>0?'warning':''}`},d.performance>0?d.performance.toFixed(1)+'%':'N/A')),
                                        e('td',null,e('span',{className:`status-badge ${d.oee>=85?'excellent':d.oee>=60?'good':d.oee>0?'warning':'critical'}`,style:{fontWeight:'700'}},d.oee>0?d.oee.toFixed(1)+'%':'N/A'))
                                    )
                                ))
                            )
                        )
                    )
                ),
                
                activeTab==='detalhes' && (!temDados ? 
                    e('div',{className:'section'}, e('div',{className:'empty-state'}, e('div',{className:'empty-state-icon'},'📋'), e('div',{className:'empty-state-title'},'Sem dados'))) :
                    e('div',null,
                        Object.keys(kpis.porTipologia || {}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📦 Quantidade Entregue por Tipologia'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipologia'), e('th',null,'Qtd Entregue'), e('th',null,'Valor Faturado'), e('th',null,'Eficiência'))),
                                e('tbody',null, Object.entries(kpis.porTipologia).sort((a,b)=>b[1].qtdEntregue-a[1].qtdEntregue).map(([t,d])=>{
                                    const ef = kpis.eficienciaPorTipologia && kpis.eficienciaPorTipologia[t] ? kpis.eficienciaPorTipologia[t].eficiencia : 0;
                                    return e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,formatNumber(d.qtdEntregue)), e('td',null,formatCurrency(d.valorFaturado)), e('td',null,e('span',{className:`status-badge ${ef>=100?'excellent':ef>=80?'good':ef>0?'warning':''}`},ef>0?ef.toFixed(0)+'%':'N/A')));
                                }))
                            )
                        ),
                        Object.keys(kpis.porCaixa || {}).length>0 && e('div',{className:'section'},
                            e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📋 Quantidade Entregue por Tipo de Caixa'),
                            e('table',{className:'data-table'},
                                e('thead',null, e('tr',null, e('th',null,'Tipo Caixa'), e('th',null,'Qtd Entregue'), e('th',null,'Valor Faturado'))),
                                e('tbody',null, Object.entries(kpis.porCaixa).sort((a,b)=>b[1].qtdEntregue-a[1].qtdEntregue).map(([t,d])=>{
                                    return e('tr',{key:t}, e('td',null,e('strong',null,t)), e('td',null,formatNumber(d.qtdEntregue)), e('td',null,formatCurrency(d.valorFaturado)));
                                }))
                            )
                        ),
                        e('div',{className:'grid-2'},
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'📊 Estatísticas Operações'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Total'), e('span',{className:'summary-value'},formatNumber(kpis.numOperacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Total'), e('span',{className:'summary-value'},minutosParaHoras(kpis.tempoTotalOps))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Média/Operação'), e('span',{className:'summary-value'},kpis.numOperacoes>0?minutosParaHoras(Math.round(kpis.tempoTotalOps/kpis.numOperacoes)):'N/A'))
                            ),
                            e('div',{className:'section'},
                                e('h3',{className:'section-title',style:{marginBottom:'16px'}},'⚠️ Estatísticas Perturbações'),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Total'), e('span',{className:'summary-value'},formatNumber(kpis.numPerturbacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'Tempo Perdido'), e('span',{className:'summary-value',style:{color:'var(--accent-red)'}},minutosParaHoras(kpis.tempoPerturbacoes))),
                                e('div',{className:'summary-row'}, e('span',{className:'summary-label'},'% do Tempo Ops'), e('span',{className:'summary-value'},kpis.tempoTotalOps>0?(kpis.tempoPerturbacoes/kpis.tempoTotalOps*100).toFixed(1)+'%':'N/A'))
                            )
                        )
                    )
                ),
                
                msg && e('div',{className:`msg-toast ${msgType}`},msg)
            );
        }
        
        ReactDOM.render(e(App), document.getElementById('root'));
    </script>
</body>
</html>
